# db.Repository

Repository pattern implementation with blueprint and goqu

## Usage
 
```go
package main

import (
	"context"
	"fmt"
	"github.com/oddbit-project/blueprint/db"
	"github.com/oddbit-project/blueprint/provider/pgsql"
	"log"
	"time"
)

type UserRecord struct {
	Id        int       `db:"id_user" goqu:"skipinsert"` // field is autogenerated
	CreatedAt time.Time `db:"created_at"`
	UpdatedAt time.Time `db:"updated_at"`
	Name      string    `db:"name"`
	Email     string    `db:"email"`
}

func main() {
	pgConfig := pgsql.NewClientConfig() // use defaults
	pgConfig.DSN = "postgres://username:password@localhost:5432/database?sslmode=allow"

	client, err := pgsql.NewClient(pgConfig)
	if err != nil {
		log.Fatal(err)
	}

	// create a repository for the table users
	// Note: context is internally stored and then propagated to the appropriate sqlx methods; this is
	// not the advised way of using contexts, but the rationale is to allow clean thread or application shutdown
	// via context, without the overhead of adding an extra parameter to every function
	repo := db.NewRepository(context.Background(), client, "users")

	user1 := &UserRecord{
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
		Name:      "John Connor",
		Email:     "jconnor@skynet.com",
	}

	// Add user
	if err = repo.Insert(user1); err != nil {
		log.Fatal(err)
	}

	// Read all users
	users := make([]*UserRecord, 0)
	if err = repo.Fetch(repo.SqlSelect(), &users); err != nil {
		log.Fatal(err)
	}
	
	// search for sarah by email
	sarah := &UserRecord{}
	if err = repo.FetchRecord(map[string]any{"email": "sconnor@skynet.com"}, sarah); err != nil {
		if db.EmptyResult(err) {
			fmt.Println("Sarah Connor not found")
		} else {
			log.Fatal(err)
		}
			
	}
	
	// Count all users
	count, err := repo.Count()
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf("Total users: %d\n", count)
	
	// Count users with specific criteria
	activeCount, err := repo.CountWhere(map[string]any{"active": true})
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf("Active users: %d\n", activeCount)
}
```

## Counter Interface

The Repository implements a Counter interface that provides methods for counting records:

```go
type Counter interface {
	Count() (int64, error)
	CountWhere(fieldValues map[string]any) (int64, error)
}
```

- `Count()` - Returns the total number of rows in the table
- `CountWhere(fieldValues map[string]any)` - Returns the number of rows matching the specified field values

## GridOps Interface

The Repository also implements a GridOps interface that provides methods for working with data grids:

```go
type GridOps interface {
	Grid(record any) (*Grid, error)
	QueryGrid(record any, args GridQuery, dest any) error
}
```

- `Grid(record any) (*Grid, error)` - Creates a Grid object based on the provided record type, using field tags to determine which fields can be sorted, filtered, or searched
- `QueryGrid(record any, args GridQuery, dest any) error` - Creates a Grid object and executes a query using the provided GridQuery parameters

### Example Usage

```go
type UserRecord struct {
	ID       int    `db:"id" json:"id" grid:"sort,filter"`
	Username string `db:"username" json:"username" grid:"sort,search,filter"`
	Email    string `db:"email" json:"email" grid:"sort,search,filter"`
	Active   bool   `db:"active" json:"active" grid:"filter"`
}

func main() {
	// ... setup connection and repository as shown earlier ...
	repo := db.NewRepository(context.Background(), client, "users")

	// Create a GridQuery for searching and filtering
	query, err := db.NewGridQuery(db.SearchAny, 10, 0)
	if err != nil {
		log.Fatal(err)
	}

	// Set search parameters
	query.SearchText = "john"
	query.FilterFields = map[string]any{
		"active": true,
	}
	query.SortFields = map[string]string{
		"username": db.SortAscending,
	}

	// Execute the query
	var users []*UserRecord
	if err := repo.QueryGrid(&UserRecord{}, query, &users); err != nil {
		log.Fatal(err)
	}

	fmt.Printf("Found %d active users matching 'john'\n", len(users))

	// Alternatively, create and configure a Grid manually
	grid, err := repo.Grid(&UserRecord{})
	if err != nil {
		log.Fatal(err)
	}

	// Add custom filter function
	grid.AddFilterFunc("active", func(value any) (any, error) {
		switch v := value.(type) {
		case string:
			switch v {
			case "yes", "true", "1":
				return true, nil
			case "no", "false", "0":
				return false, nil
			default:
				return nil, fmt.Errorf("invalid boolean value: %v", v)
			}
		case bool:
			return v, nil
		default:
			return nil, fmt.Errorf("unsupported type: %T", value)
		}
	})

	// Validate and build the query
	if err := grid.ValidQuery(query); err != nil {
		log.Fatal(err)
	}

	statement, err := grid.Build(repo.SqlSelect(), query)
	if err != nil {
		log.Fatal(err)
	}

	// Execute the query
	var filteredUsers []*UserRecord
	if err := repo.Fetch(statement, &filteredUsers); err != nil {
		log.Fatal(err)
	}
}
```

For more detailed information about grid functionality, see the [Data Grid documentation](dbgrid.md).