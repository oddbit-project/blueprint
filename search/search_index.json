{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Blueprint documentation","text":""},{"location":"#configuration","title":"Configuration","text":"<ul> <li>Config</li> </ul>"},{"location":"#database","title":"Database","text":"<ul> <li>Database Package Overview</li> <li>Structs and Tags</li> <li>Client Interface</li> <li>Repository Pattern</li> <li>Data Grid System</li> <li>Field Specifications</li> <li>Query Builder</li> <li>Database Functions</li> <li>Migration System</li> <li>SQL Update API</li> </ul>"},{"location":"#security","title":"Security","text":"<ul> <li>Secure Credentials</li> <li>HMAC Provider</li> <li>htpasswd Authentication</li> <li>TLS</li> </ul>"},{"location":"#providers","title":"Providers","text":"<ul> <li>Clickhouse</li> <li>HMAC Provider</li> <li>htpasswd</li> <li>JWT Provider</li> <li>Kafka</li> <li>MQTT</li> <li>NATS</li> <li>PostgreSQL</li> <li>TLS</li> </ul>"},{"location":"#logging","title":"Logging","text":"<ul> <li>Logging</li> </ul>"},{"location":"#http-server","title":"HTTP Server","text":"<ul> <li>HTTP Server Framework - Complete overview and quick start</li> <li>API Reference - Complete server API documentation</li> <li>Middleware Components - All middleware and utilities</li> <li>Integration Examples - REST API, web app, and microservice examples</li> <li>Troubleshooting Guide - Debugging and common issues</li> <li>Performance Guide - Optimization and production deployment</li> <li>Authentication - Token and JWT authentication providers</li> <li>Security &amp; Headers - Security middleware and CSRF protection</li> <li>Session Management - Cookie-based session system</li> <li>Request Utilities - Request helper functions</li> </ul>"},{"location":"#utilities","title":"Utilities","text":"<ul> <li>BatchWriter</li> <li>ThreadPool</li> </ul>"},{"location":"batchwriter/batchwriter/","title":"BatchWriter","text":"<p>The BatchWriter is a high-performance, thread-safe component for buffering, batching, and asynchronously processing data records.</p>"},{"location":"batchwriter/batchwriter/#overview","title":"Overview","text":"<p>BatchWriter solves the common problem of efficiently collecting individual records and processing them in batches. It offers:</p> <ul> <li>Thread-safe batch processing with configurable batch sizes</li> <li>Time-based automatic flushing</li> <li>Multiple record addition strategies (blocking, non-blocking, context-aware)</li> <li>Comprehensive performance metrics</li> <li>Memory optimization through buffer reuse</li> <li>Graceful shutdown with proper cleanup</li> <li>Panic recovery for flush operations</li> </ul>"},{"location":"batchwriter/batchwriter/#usage","title":"Usage","text":""},{"location":"batchwriter/batchwriter/#basic-usage","title":"Basic Usage","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"github.com/oddbit-project/blueprint/batchwriter\"\n    \"github.com/oddbit-project/blueprint/log\"\n    \"time\"\n)\n\nfunc main() {\n    ctx := context.Background()\n    logger := log.NewLogger()\n\n    // Process records in batches of 100 or every 5 seconds, whichever comes first\n    writer, err := batchwriter.NewBatchWriter(\n        ctx,\n        100,                 // capacity\n        5*time.Second,       // flush interval \n        func(records ...any) {\n            // Process the batch of records\n            fmt.Printf(\"Processing %d records\\n\", len(records))\n            for _, record := range records {\n                // Process each record\n                fmt.Printf(\"Record: %v\\n\", record)\n            }\n        },\n    )\n    if err != nil {\n        panic(err)\n    }\n\n    // Set a logger for operations\n    writer.SetLogger(logger)\n\n    // Add records (blocking if buffer is full)\n    writer.Add(\"record1\")\n    writer.Add(\"record2\")\n\n    // Try to add without blocking\n    if !writer.TryAdd(\"record3\") {\n        fmt.Println(\"Buffer full, record dropped\")\n    }\n\n    // Add with context awareness\n    timeoutCtx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)\n    defer cancel()\n\n    if err := writer.AddWithContext(timeoutCtx, \"record4\"); err != nil {\n        fmt.Printf(\"Failed to add record: %v\\n\", err)\n    }\n\n    // Get current metrics\n    metrics := writer.GetMetrics()\n    fmt.Printf(\"Records processed: %d\\n\", metrics.RecordsProcessed)\n\n    // Force an immediate flush\n    writer.FlushNow()\n\n    // Gracefully stop the writer\n    writer.Stop()\n}\n</code></pre>"},{"location":"batchwriter/batchwriter/#advanced-configuration","title":"Advanced Configuration","text":"<p>The BatchWriter supports functional options for advanced configuration:</p> <pre><code>// Configure with options\nwriter, err := batchwriter.NewBatchWriter(\n    ctx,\n    1000,                               // Batch capacity\n    time.Second,                        // Flush interval\n    processBatch,                       // Batch processing function\n    batchwriter.WithClearBuffers(true), // Enable buffer clearing to help with GC\n    batchwriter.WithLogger(logger),     // Set logger for operations\n    batchwriter.WithQueueCapacity(50),  // Configure input queue capacity (default: 10)\n)\n</code></pre>"},{"location":"batchwriter/batchwriter/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Add - Blocking operation, use for critical data that must be processed</li> <li>TryAdd - Non-blocking, ~24% faster than Add, use for high-throughput scenarios where occasional drops are acceptable</li> <li>Buffer Clearing - Minimal performance impact (~2% slower) but helps with memory usage for long-running services</li> </ul>"},{"location":"batchwriter/batchwriter/#api-reference","title":"API Reference","text":""},{"location":"batchwriter/batchwriter/#types","title":"Types","text":""},{"location":"batchwriter/batchwriter/#batchwriter_1","title":"BatchWriter","text":"<pre><code>type BatchWriter struct {\n    // Contains unexported fields\n}\n</code></pre> <p>The main type providing batch writing functionality.</p>"},{"location":"batchwriter/batchwriter/#metrics","title":"Metrics","text":"<pre><code>type Metrics struct {\n    RecordsAdded      uint64        // Total number of records added\n    RecordsProcessed  uint64        // Total number of records processed by flush\n    RecordsDropped    uint64        // Total number of records dropped (TryAdd failures)\n    RecordsInBuffer   uint64        // Current number of records in write buffer\n    QueueCapacity     int           // Capacity of the input channel\n    FlushCount        uint64        // Number of flushes performed\n    LastFlushDuration time.Duration // Duration of the last flush operation\n    AvgFlushDuration  time.Duration // Average flush duration\n    TotalFlushTime    time.Duration // Total time spent in flush operations\n}\n</code></pre> <p>Provides comprehensive performance metrics for the BatchWriter.</p>"},{"location":"batchwriter/batchwriter/#flushfn","title":"FlushFn","text":"<pre><code>type FlushFn func(records ...any)\n</code></pre> <p>Function type for processing batches of records.</p>"},{"location":"batchwriter/batchwriter/#functions","title":"Functions","text":""},{"location":"batchwriter/batchwriter/#newbatchwriter","title":"NewBatchWriter","text":"<pre><code>func NewBatchWriter(\n    ctx context.Context,\n    capacity int,\n    flushInterval time.Duration,\n    flushFn FlushFn,\n    opts ...BatchWriterOption,\n) (*BatchWriter, error)\n</code></pre> <p>Creates a new BatchWriter with the specified parameters: - <code>ctx</code> - Context for lifecycle management - <code>capacity</code> - Maximum batch size - <code>flushInterval</code> - Maximum time between flushes - <code>flushFn</code> - Function to process batches - <code>opts</code> - Optional configuration options</p> <p>Returns error if: - <code>capacity</code> &lt; 1 (<code>ErrCapacityTooSmall</code>) - <code>flushFn</code> is nil (<code>ErrNilFlushFunction</code>) - <code>flushInterval</code> &lt; 1ms (<code>ErrInvalidFlushInterval</code>)</p>"},{"location":"batchwriter/batchwriter/#option-functions","title":"Option Functions","text":"<pre><code>func WithLogger(logger *log.Logger) BatchWriterOption\nfunc WithClearBuffers(clear bool) BatchWriterOption\nfunc WithQueueCapacity(capacity int) BatchWriterOption\n</code></pre>"},{"location":"batchwriter/batchwriter/#methods","title":"Methods","text":""},{"location":"batchwriter/batchwriter/#add","title":"Add","text":"<pre><code>func (b *BatchWriter) Add(record any)\n</code></pre> <p>Adds a record to the batch. Blocks if the input channel is full.</p>"},{"location":"batchwriter/batchwriter/#tryadd","title":"TryAdd","text":"<pre><code>func (b *BatchWriter) TryAdd(record any) bool\n</code></pre> <p>Attempts to add a record without blocking. Returns true if successful, false if the input channel is full (controlled by WithQueueCapacity, default: 10).</p>"},{"location":"batchwriter/batchwriter/#addwithcontext","title":"AddWithContext","text":"<pre><code>func (b *BatchWriter) AddWithContext(ctx context.Context, record any) error\n</code></pre> <p>Attempts to add a record with context cancellation support. Returns error if context is done.</p>"},{"location":"batchwriter/batchwriter/#flushnow","title":"FlushNow","text":"<pre><code>func (b *BatchWriter) FlushNow()\n</code></pre> <p>Forces an immediate flush of the current buffer.</p>"},{"location":"batchwriter/batchwriter/#stop","title":"Stop","text":"<pre><code>func (b *BatchWriter) Stop()\n</code></pre> <p>Gracefully stops the BatchWriter and flushes any remaining records. Blocks until processing is complete.</p>"},{"location":"batchwriter/batchwriter/#getmetrics","title":"GetMetrics","text":"<pre><code>func (b *BatchWriter) GetMetrics() Metrics\n</code></pre> <p>Returns the current performance metrics.</p>"},{"location":"batchwriter/batchwriter/#setlogger","title":"SetLogger","text":"<pre><code>func (b *BatchWriter) SetLogger(logger *log.Logger)\n</code></pre> <p>Sets a logger for operations.</p>"},{"location":"batchwriter/batchwriter/#error-handling","title":"Error Handling","text":"<ul> <li>If the flush function panics, the panic is recovered and logged if a logger is configured</li> <li>All BatchWriter operations continue to function normally after a panic in the flush function</li> <li>Errors from the flush function are not returned directly; use the logger to capture them</li> </ul>"},{"location":"batchwriter/batchwriter/#thread-safety","title":"Thread Safety","text":"<p>All BatchWriter operations are thread-safe. It can be safely used from multiple goroutines without additional synchronization.</p>"},{"location":"batchwriter/batchwriter/#benchmarks","title":"Benchmarks","text":"Operation Operations/sec ns/op B/op allocs/op Add 5,699,919 226.4 7 0 TryAdd 42,758,880 38.67 7 0 With Buffer Clearing 4,841,886 213.5 7 0 <p>These benchmarks were run on an Intel Core i5-10400F CPU @ 2.90GHz (12 logical cores), demonstrating:</p> <ol> <li>TryAdd is significantly faster (~5.8x) than the blocking Add method</li> <li>With Buffer Clearing enabled, performance is still excellent, with only a minor impact compared to regular Add</li> <li>Memory efficiency is outstanding with only 7 bytes per operation and zero allocations</li> </ol>"},{"location":"config/config/","title":"blueprint.config","text":"<p>Configuration providers for blueprint</p>"},{"location":"config/config/#overview","title":"Overview","text":"<p>The blueprint configuration system provides flexible configuration management through multiple providers:</p> <ul> <li>JsonProvider: Reads configuration from JSON files, streams, or raw data</li> <li>EnvProvider: Reads configuration from environment variables with advanced features</li> <li>Default Values: Both providers support default values via struct tags</li> <li>Thread Safety: EnvProvider and JsonProvider include thread-safe concurrent access</li> <li>Nested Structures: Full support for complex nested configuration structures</li> </ul>"},{"location":"config/config/#using-json-files","title":"Using JSON files","text":"<p>Example configuration file config.json: <pre><code>{\n  \"server\": {\n    \"host\": \"localhost\",\n    \"port\": 1234\n  }\n}\n</code></pre></p>"},{"location":"config/config/#basic-usage","title":"Basic Usage","text":"<pre><code>package main\n\nimport \"github.com/oddbit-project/blueprint/config/provider\"\n\ntype ServerConfig struct {\n    Host         string            `json:\"host\"`\n    Port         int               `json:\"port\"`\n    CertFile     string            `json:\"certFile\"`\n    CertKeyFile  string            `json:\"certKeyFile\"`\n    ReadTimeout  int               `json:\"readTimeout\"`\n    WriteTimeout int               `json:\"writeTimeout\"`\n    Debug        bool              `json:\"debug\"`\n    Options      map[string]string `json:\"options\"`\n}\n\nfunc main() {\n    if cfg, err := provider.NewJsonProvider(\"config.json\"); err == nil {\n        serverConfig := &amp;ServerConfig{}\n        // extract struct serverConfig from \"server\" key\n        if err := cfg.GetKey(\"server\", serverConfig); err == nil {\n            // run server using config\n        } else {\n            // error reading config key\n        }\n    } else {\n        // error reading config file\n    }\n}\n</code></pre>"},{"location":"config/config/#json-provider-with-default-values","title":"JSON Provider with Default Values","text":"<pre><code>type ServerConfig struct {\n    Host         string            `json:\"host\" default:\"localhost\"`\n    Port         int               `json:\"port\" default:\"8080\"`\n    CertFile     string            `json:\"certFile\" default:\"\"`\n    CertKeyFile  string            `json:\"certKeyFile\" default:\"\"`\n    ReadTimeout  int               `json:\"readTimeout\" default:\"30\"`\n    WriteTimeout int               `json:\"writeTimeout\" default:\"30\"`\n    Debug        bool              `json:\"debug\" default:\"false\"`\n    Options      map[string]string `json:\"options\"`\n}\n\nfunc main() {\n    // JSON file with partial configuration\n    // Missing fields will use default values from struct tags\n    cfg, err := provider.NewJsonProvider(\"config.json\")\n    if err != nil {\n        panic(err)\n    }\n\n    // Get entire configuration with defaults applied\n    var appConfig struct {\n        Server ServerConfig `json:\"server\"`\n    }\n    if err := cfg.Get(&amp;appConfig); err != nil {\n        panic(err)\n    }\n\n    // appConfig.Server.Host will be \"localhost\" if not in JSON\n    // appConfig.Server.Port will be 8080 if not in JSON\n}\n</code></pre>"},{"location":"config/config/#multiple-data-sources","title":"Multiple Data Sources","text":"<pre><code>// From file\ncfg, err := provider.NewJsonProvider(\"config.json\")\n\n// From []byte\njsonData := []byte(`{\"host\": \"example.com\", \"port\": 9090}`)\ncfg, err := provider.NewJsonProvider(jsonData)\n\n// From io.Reader\nfile, _ := os.Open(\"config.json\")\ncfg, err := provider.NewJsonProvider(file)\n\n// From json.RawMessage\nvar rawMsg json.RawMessage\n// ... populate rawMsg\ncfg, err := provider.NewJsonProvider(rawMsg)\n</code></pre>"},{"location":"config/config/#using-environment-variables","title":"Using Environment variables","text":""},{"location":"config/config/#basic-usage_1","title":"Basic Usage","text":"<pre><code>type ServerConfig struct {\n    Host         string\n    Port         int\n    CertFile     string\n    CertKeyFile  string\n    ReadTimeout  int\n    WriteTimeout int\n    Debug        bool\n    Options      map[string]string\n}\n\nfunc main() {\n    cfg := provider.NewEnvProvider(\"SERVER_\", true) // prefix and convertCamelCase enabled\n    serverConfig := &amp;ServerConfig{}\n    if err := cfg.GetKey(\"\", serverConfig); err == nil { // read SERVER_ env vars to struct\n        // run server using config\n    } else {\n        fmt.Println(err)\n    }\n}\n</code></pre>"},{"location":"config/config/#environment-variables-with-default-values","title":"Environment Variables with Default Values","text":"<pre><code>type ServerConfig struct {\n    Host         string `env:\"HOST\" default:\"localhost\"`\n    Port         int    `env:\"PORT\" default:\"8080\"`\n    CertFile     string `env:\"CERT_FILE\" default:\"\"`\n    CertKeyFile  string `env:\"CERT_KEY_FILE\" default:\"\"`\n    ReadTimeout  int    `env:\"READ_TIMEOUT\" default:\"30\"`\n    WriteTimeout int    `env:\"WRITE_TIMEOUT\" default:\"30\"`\n    Debug        bool   `env:\"DEBUG\" default:\"false\"`\n    MaxConns     int    `env:\"MAX_CONNECTIONS\" default:\"100\"`\n}\n\nfunc main() {\n    // Set only some environment variables\n    os.Setenv(\"SERVER_HOST\", \"production.example.com\")\n    os.Setenv(\"SERVER_PORT\", \"9090\")\n    // DEBUG, READ_TIMEOUT, etc. will use defaults\n\n    cfg := provider.NewEnvProvider(\"SERVER_\", true)\n    serverConfig := &amp;ServerConfig{}\n\n    if err := cfg.Get(serverConfig); err != nil {\n        panic(err)\n    }\n\n    // serverConfig.Host = \"production.example.com\" (from env var)\n    // serverConfig.Port = 9090 (from env var)\n    // serverConfig.Debug = false (from default tag)\n    // serverConfig.ReadTimeout = 30 (from default tag)\n}\n</code></pre>"},{"location":"config/config/#nested-structures","title":"Nested Structures","text":"<pre><code>type DatabaseConfig struct {\n    Host     string `env:\"HOST\" default:\"localhost\"`\n    Port     int    `env:\"PORT\" default:\"5432\"`\n    Database string `env:\"NAME\" default:\"myapp\"`\n    Username string `env:\"USER\" default:\"user\"`\n    Password string `env:\"PASSWORD\" default:\"\"`\n}\n\ntype ServerConfig struct {\n    Host string `env:\"HOST\" default:\"localhost\"`\n    Port int    `env:\"PORT\" default:\"8080\"`\n}\n\ntype AppConfig struct {\n    Database DatabaseConfig `env:\"DATABASE\"`\n    Server   ServerConfig   `env:\"SERVER\"`\n}\n\nfunc main() {\n    // Environment variables:\n    // APP_DATABASE_HOST=db.example.com\n    // APP_DATABASE_PORT=5432\n    // APP_SERVER_HOST=api.example.com\n    // APP_SERVER_PORT=9090\n\n    cfg := provider.NewEnvProvider(\"APP_\", true)\n    config := &amp;AppConfig{}\n\n    if err := cfg.Get(config); err != nil {\n        panic(err)\n    }\n\n    // config.Database.Host = \"db.example.com\" (from APP_DATABASE_HOST)\n    // config.Database.Database = \"myapp\" (from default tag)\n    // config.Server.Host = \"api.example.com\" (from APP_SERVER_HOST)\n}\n</code></pre>"},{"location":"config/config/#camelcase-conversion","title":"CamelCase Conversion","text":"<pre><code>type Config struct {\n    DatabaseURL      string `env:\"DATABASE_URL\"`\n    MaxConnections   int    `env:\"MAX_CONNECTIONS\" default:\"10\"`\n    EnableTLS        bool   `env:\"ENABLE_TLS\" default:\"true\"`\n    ConnectionTimeout int   `env:\"CONNECTION_TIMEOUT\" default:\"30\"`\n}\n\nfunc main() {\n    // With convertCamelCase=true:\n    // Field \"DatabaseURL\" maps to \"DATABASE_URL\"\n    // Field \"MaxConnections\" maps to \"MAX_CONNECTIONS\"\n    // Field \"EnableTLS\" maps to \"ENABLE_TLS\"\n\n    cfg := provider.NewEnvProvider(\"APP_\", true) // convertCamelCase=true\n    config := &amp;Config{}\n\n    if err := cfg.Get(config); err != nil {\n        panic(err)\n    }\n}\n</code></pre>"},{"location":"config/config/#supported-environment-variable-types","title":"Supported Environment Variable Types","text":"<ul> <li>string: Direct string value</li> <li>int: Parsed with <code>strconv.Atoi()</code></li> <li>bool: Parsed with <code>strconv.ParseBool()</code> (supports \"true\", \"false\", \"1\", \"0\", etc.)</li> <li>float64: Parsed with <code>strconv.ParseFloat()</code></li> <li>[]string: Comma-separated values, automatically trimmed</li> </ul> <p>Example: <pre><code># String\nexport APP_HOST=localhost\n\n# Integer\nexport APP_PORT=8080\n\n# Boolean\nexport APP_DEBUG=true\n\n# Float\nexport APP_TIMEOUT=30.5\n\n# String slice\nexport APP_FEATURES=feature1,feature2,feature3\n</code></pre></p>"},{"location":"config/config/#advanced-features","title":"Advanced Features","text":""},{"location":"config/config/#configuration-interface","title":"Configuration Interface","text":"<p>Both providers implement the <code>ConfigInterface</code> which provides:</p> <pre><code>type ConfigProvider interface {\n    Get(dest interface{}) error                                    // Get entire config\n    GetKey(key string, dest interface{}) error                     // Get specific key\n    GetStringKey(key string) (string, error)                       // Get string value\n    GetBoolKey(key string) (bool, error)                           // Get boolean value\n    GetIntKey(key string) (int, error)                             // Get integer value\n    GetFloat64Key(key string) (float64, error)                     // Get float value\n    GetSliceKey(key, separator string) ([]string, error)           // Get string slice\n    GetConfigNode(key string) (ConfigInterface, error)             // Get nested config\n    KeyExists(key string) bool                                     // Check key existence\n    KeyListExists(keys []string) bool                              // Check multiple keys\n}\n</code></pre>"},{"location":"config/config/#thread-safety","title":"Thread Safety","text":"<p>Both <code>EnvProvider</code> and <code>JsonProvider</code> are thread-safe and use read-write mutexes for concurrent access:</p> <pre><code>cfg := provider.NewEnvProvider(\"APP_\", true)\n\n// Safe to use from multiple goroutines\ngo func() {\n    var config AppConfig\n    cfg.Get(&amp;config)\n}()\n\ngo func() {\n    host, _ := cfg.GetStringKey(\"HOST\")\n    fmt.Println(host)\n}()\n</code></pre>"},{"location":"config/config/#nested-configuration-access","title":"Nested Configuration Access","text":"<p>For JSON configurations, you can access nested nodes:</p> <pre><code>// config.json\n{\n  \"database\": {\n    \"host\": \"localhost\",\n    \"port\": 5432\n  },\n  \"server\": {\n    \"host\": \"0.0.0.0\",\n    \"port\": 8080\n  }\n}\n\n// Access nested configuration\ncfg, _ := provider.NewJsonProvider(\"config.json\")\ndbNode, _ := cfg.GetConfigNode(\"database\")\nhost, _ := dbNode.GetStringKey(\"host\") // \"localhost\"\n</code></pre>"},{"location":"config/config/#default-values-behavior","title":"Default Values Behavior","text":"<p>Default values are applied when:</p> <p>EnvProvider: Environment variable is not set JsonProvider: JSON field is missing or has zero value</p> <pre><code>type Config struct {\n    Host  string `json:\"host\" env:\"HOST\" default:\"localhost\"`\n    Port  int    `json:\"port\" env:\"PORT\" default:\"8080\"`\n    Debug bool   `json:\"debug\" env:\"DEBUG\" default:\"false\"`\n}\n\n// With empty JSON: {}\n// Or missing environment variables\n// All fields will use their default values\n</code></pre>"},{"location":"config/config/#using-wrappers","title":"Using Wrappers","text":""},{"location":"config/config/#strorfile","title":"StrOrFile","text":"<p>The StrOrFile() wrapper attempts to identify a valid file path on the argument string. If a valid path is detected (string either starts with \"/\" or \"./\"), will attempt to load the contents  of the file and return it as a string value. If no valid filepath is detected, or file is not found, will just return the argument string:</p> <pre><code>import \"github.com/oddbit-project/blueprint/config\"\n\nmyPass := config.StrOrFile(\"some password\") // myPass = \"some password\"\nmyPass := config.StrOrFile(\"./credentials.txt\") // myPass = contents of credentials.txt\n</code></pre> <p>This is particularly useful for secrets management:</p> <pre><code>type DatabaseConfig struct {\n    Host     string `env:\"HOST\" default:\"localhost\"`\n    Password string `env:\"PASSWORD\" default:\"\"`\n}\n\nfunc main() {\n    cfg := provider.NewEnvProvider(\"DB_\", false)\n    dbConfig := &amp;DatabaseConfig{}\n    cfg.Get(dbConfig)\n\n    // If DB_PASSWORD=\"/path/to/secret\", password will be file contents\n    // If DB_PASSWORD=\"plain_password\", password will be the literal string\n    actualPassword := config.StrOrFile(dbConfig.Password)\n}\n</code></pre>"},{"location":"config/config/#best-practices","title":"Best Practices","text":""},{"location":"config/config/#1-use-default-values-for-development","title":"1. Use Default Values for Development","text":"<pre><code>type Config struct {\n    DatabaseURL string `env:\"DATABASE_URL\" default:\"postgres://localhost/myapp_dev\"`\n    RedisURL    string `env:\"REDIS_URL\" default:\"redis://localhost:6379\"`\n    Port        int    `env:\"PORT\" default:\"8080\"`\n    LogLevel    string `env:\"LOG_LEVEL\" default:\"info\"`\n}\n</code></pre>"},{"location":"config/config/#2-combine-multiple-providers","title":"2. Combine Multiple Providers","text":"<pre><code>func LoadConfig() (*Config, error) {\n    config := &amp;Config{}\n\n    // Try JSON first\n    if jsonCfg, err := provider.NewJsonProvider(\"config.json\"); err == nil {\n        if err := jsonCfg.Get(config); err == nil {\n            return config, nil\n        }\n    }\n\n    // Fallback to environment variables\n    envCfg := provider.NewEnvProvider(\"APP_\", true)\n    return config, envCfg.Get(config)\n}\n</code></pre>"},{"location":"config/config/#3-validate-configuration","title":"3. Validate Configuration","text":"<pre><code>func (c *Config) Validate() error {\n    if c.Port &lt; 1 || c.Port &gt; 65535 {\n        return fmt.Errorf(\"invalid port: %d\", c.Port)\n    }\n    if c.DatabaseURL == \"\" {\n        return fmt.Errorf(\"database URL is required\")\n    }\n    return nil\n}\n\nfunc main() {\n    config := &amp;Config{}\n    cfg := provider.NewEnvProvider(\"APP_\", true)\n\n    if err := cfg.Get(config); err != nil {\n        log.Fatal(err)\n    }\n\n    if err := config.Validate(); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>"},{"location":"crypt/secure-credentials/","title":"Secure Credentials","text":"<p>The secure credentials system in Blueprint provides a way to handle sensitive information like passwords securely in memory. It encrypts credentials using AES-256-GCM and provides methods to safely store, retrieve, and clear sensitive data with thread-safe operations.</p>"},{"location":"crypt/secure-credentials/#features","title":"Features","text":"<ul> <li>In-memory encryption of sensitive data using AES-256-GCM</li> <li>Multiple loading sources: environment variables, files, or configuration objects</li> <li>Secure memory clearing with explicit zeroing of sensitive data</li> <li>Thread-safe operations with RWMutex for concurrent access</li> <li>Flexible configuration with priority-based credential resolution</li> <li>Key management utilities for generation, encoding, and decoding</li> </ul>"},{"location":"crypt/secure-credentials/#complete-api-reference","title":"Complete API Reference","text":""},{"location":"crypt/secure-credentials/#core-types","title":"Core Types","text":""},{"location":"crypt/secure-credentials/#credential","title":"Credential","text":"<p>The main structure for storing encrypted credentials in memory.</p> <pre><code>type Credential struct {\n    // Internal fields (not directly accessible)\n}\n</code></pre> <p>Methods:</p>"},{"location":"crypt/secure-credentials/#newcredential","title":"NewCredential","text":"<p><pre><code>func NewCredential(data []byte, encryptionKey []byte, allowEmpty bool) (*Credential, error)\n</code></pre> Creates a new secure credential container.</p> <p>Parameters: - <code>data</code>: The sensitive data to encrypt (password, secret, etc.) - <code>encryptionKey</code>: 32-byte encryption key for AES-256 - <code>allowEmpty</code>: Whether to allow empty credentials</p> <p>Returns: - <code>*Credential</code>: New credential instance - <code>error</code>: ErrEmptyCredential if data is empty and allowEmpty is false, ErrInvalidKey if key is not 32 bytes</p>"},{"location":"crypt/secure-credentials/#get","title":"Get","text":"<p><pre><code>func (sc *Credential) Get() (string, error)\n</code></pre> Decrypts and returns the credential as a string.</p> <p>Returns: - <code>string</code>: Decrypted credential value - <code>error</code>: ErrEmptyCredential if credential is empty, ErrDecryption if decryption fails</p>"},{"location":"crypt/secure-credentials/#getbytes","title":"GetBytes","text":"<p><pre><code>func (sc *Credential) GetBytes() ([]byte, error)\n</code></pre> Decrypts and returns the raw credential bytes. Use this method sparingly to minimize exposure of sensitive data in memory.</p> <p>Returns: - <code>[]byte</code>: Decrypted credential bytes - <code>error</code>: ErrEmptyCredential if credential is empty, ErrDecryption if decryption fails</p>"},{"location":"crypt/secure-credentials/#update","title":"Update","text":"<p><pre><code>func (sc *Credential) Update(plaintext string) error\n</code></pre> Updates the credential with a new plaintext value.</p> <p>Parameters: - <code>plaintext</code>: New credential value</p> <p>Returns: - <code>error</code>: ErrEncryption if encryption fails</p>"},{"location":"crypt/secure-credentials/#updatebytes","title":"UpdateBytes","text":"<p><pre><code>func (sc *Credential) UpdateBytes(data []byte) error\n</code></pre> Updates the credential with new byte data.</p> <p>Parameters: - <code>data</code>: New credential data</p> <p>Returns: - <code>error</code>: ErrEncryption if encryption fails</p>"},{"location":"crypt/secure-credentials/#clear","title":"Clear","text":"<p><pre><code>func (sc *Credential) Clear()\n</code></pre> Zeroes out all sensitive data from memory. Call this when the credential is no longer needed.</p>"},{"location":"crypt/secure-credentials/#isempty","title":"IsEmpty","text":"<p><pre><code>func (sc *Credential) IsEmpty() bool\n</code></pre> Returns true if the credential is empty.</p> <p>Returns: - <code>bool</code>: True if credential contains no data</p>"},{"location":"crypt/secure-credentials/#configuration-types","title":"Configuration Types","text":""},{"location":"crypt/secure-credentials/#defaultcredentialconfig","title":"DefaultCredentialConfig","text":"<pre><code>type DefaultCredentialConfig struct {\n    Password       string `json:\"password\"`       // Direct password (highest priority)\n    PasswordEnvVar string `json:\"passwordEnvVar\"` // Environment variable name (second priority)\n    PasswordFile   string `json:\"passwordFile\"`   // File path (lowest priority)\n}\n</code></pre> <p>Standard configuration structure with priority-based credential resolution.</p> <p>Methods: - <code>Fetch() (string, error)</code>: Retrieves credential from configured source - <code>IsEmpty() bool</code>: Returns true if all fields are empty</p>"},{"location":"crypt/secure-credentials/#keyconfig","title":"KeyConfig","text":"<pre><code>type KeyConfig struct {\n    Key       string `json:\"key\"`       // Direct key value (highest priority)\n    KeyEnvVar string `json:\"keyEnvVar\"` // Environment variable name (second priority)\n    KeyFile   string `json:\"keyFile\"`   // File path (lowest priority)\n}\n</code></pre> <p>Similar to DefaultCredentialConfig but for key management scenarios.</p> <p>Methods: - <code>Fetch() (string, error)</code>: Retrieves key from configured source - <code>IsEmpty() bool</code>: Returns true if all fields are empty</p>"},{"location":"crypt/secure-credentials/#credentialconfig-interface","title":"CredentialConfig Interface","text":"<pre><code>type CredentialConfig interface {\n    Fetch() (string, error)\n    IsEmpty() bool\n}\n</code></pre> <p>Interface for implementing custom credential configuration sources.</p>"},{"location":"crypt/secure-credentials/#factory-functions","title":"Factory Functions","text":""},{"location":"crypt/secure-credentials/#credentialfromenv","title":"CredentialFromEnv","text":"<p><pre><code>func CredentialFromEnv(envName string, encryptionKey []byte, allowEmpty bool) (*Credential, error)\n</code></pre> Creates a credential from an environment variable.</p> <p>Parameters: - <code>envName</code>: Environment variable name - <code>encryptionKey</code>: 32-byte encryption key - <code>allowEmpty</code>: Whether to allow empty values</p> <p>Returns: - <code>*Credential</code>: New credential instance - <code>error</code>: ErrEmptyCredential if variable is empty and allowEmpty is false</p>"},{"location":"crypt/secure-credentials/#credentialfromfile","title":"CredentialFromFile","text":"<p><pre><code>func CredentialFromFile(filename string, encryptionKey []byte, allowEmpty bool) (*Credential, error)\n</code></pre> Creates a credential from a file.</p> <p>Parameters: - <code>filename</code>: Path to secrets file - <code>encryptionKey</code>: 32-byte encryption key - <code>allowEmpty</code>: Whether to allow empty files</p> <p>Returns: - <code>*Credential</code>: New credential instance - <code>error</code>: ErrSecretsFileNotFound if file doesn't exist, ErrEmptyCredential if file is empty and allowEmpty is false</p>"},{"location":"crypt/secure-credentials/#credentialfromconfig","title":"CredentialFromConfig","text":"<p><pre><code>func CredentialFromConfig(cfg CredentialConfig, encryptionKey []byte, allowEmpty bool) (*Credential, error)\n</code></pre> Creates a credential from a configuration object.</p> <p>Parameters: - <code>cfg</code>: Configuration implementing CredentialConfig interface - <code>encryptionKey</code>: 32-byte encryption key - <code>allowEmpty</code>: Whether to allow empty credentials</p> <p>Returns: - <code>*Credential</code>: New credential instance - <code>error</code>: Configuration-specific errors or ErrEmptyCredential</p>"},{"location":"crypt/secure-credentials/#utility-functions","title":"Utility Functions","text":""},{"location":"crypt/secure-credentials/#generatekey","title":"GenerateKey","text":"<p><pre><code>func GenerateKey() ([]byte, error)\n</code></pre> Generates a cryptographically secure 32-byte key for AES-256.</p> <p>Returns: - <code>[]byte</code>: 32-byte random key - <code>error</code>: Error if random number generation fails</p>"},{"location":"crypt/secure-credentials/#encodekey","title":"EncodeKey","text":"<p><pre><code>func EncodeKey(key []byte) string\n</code></pre> Encodes a key as a base64 string for storage.</p> <p>Parameters: - <code>key</code>: Raw key bytes</p> <p>Returns: - <code>string</code>: Base64-encoded key</p>"},{"location":"crypt/secure-credentials/#decodekey","title":"DecodeKey","text":"<p><pre><code>func DecodeKey(encodedKey string) ([]byte, error)\n</code></pre> Decodes a base64-encoded key.</p> <p>Parameters: - <code>encodedKey</code>: Base64-encoded key string</p> <p>Returns: - <code>[]byte</code>: Decoded key bytes - <code>error</code>: Error if decoding fails</p>"},{"location":"crypt/secure-credentials/#randomkey32","title":"RandomKey32","text":"<p><pre><code>func RandomKey32() []byte\n</code></pre> Generates a random 32-byte key. Panics on error.</p> <p>Returns: - <code>[]byte</code>: 32-byte random key</p>"},{"location":"crypt/secure-credentials/#randomcredential","title":"RandomCredential","text":"<p><pre><code>func RandomCredential(l int) (*Credential, error)\n</code></pre> Creates a credential with random data of specified length.</p> <p>Parameters: - <code>l</code>: Length of random data</p> <p>Returns: - <code>*Credential</code>: Credential with random data - <code>error</code>: Error if random generation fails</p>"},{"location":"crypt/secure-credentials/#error-constants","title":"Error Constants","text":"<pre><code>var (\n    ErrEncryption          = errors.New(\"encryption error\")\n    ErrDecryption          = errors.New(\"decryption error\")\n    ErrInvalidKey          = errors.New(\"invalid encryption key\")\n    ErrEmptyCredential     = errors.New(\"empty credential\")\n    ErrSecretsFileNotFound = errors.New(\"secrets file not found\")\n)\n</code></pre>"},{"location":"crypt/secure-credentials/#enhanced-usage-examples","title":"Enhanced Usage Examples","text":""},{"location":"crypt/secure-credentials/#basic-credential-creation-and-usage","title":"Basic Credential Creation and Usage","text":"<pre><code>import (\n    \"github.com/oddbit-project/blueprint/crypt/secure\"\n    \"log\"\n)\n\nfunc basicCredentialExample() {\n    // Generate a secure encryption key\n    key, err := secure.GenerateKey()\n    if err != nil {\n        log.Fatalf(\"Failed to generate key: %v\", err)\n    }\n\n    // Create a credential with sensitive data\n    credential, err := secure.NewCredential([]byte(\"my-secret-password\"), key, false)\n    if err != nil {\n        log.Fatalf(\"Failed to create credential: %v\", err)\n    }\n\n    // Use the credential when needed\n    password, err := credential.Get()\n    if err != nil {\n        log.Fatalf(\"Failed to get credential: %v\", err)\n    }\n\n    // Use the password for authentication\n    authenticateUser(password)\n\n    // Clear the credential when done\n    credential.Clear()\n}\n</code></pre>"},{"location":"crypt/secure-credentials/#configuration-based-credential-loading","title":"Configuration-Based Credential Loading","text":"<pre><code>func configBasedExample() {\n    // Generate or load encryption key\n    key, _ := secure.GenerateKey()\n\n    // Configuration with priority: direct &gt; env var &gt; file\n    config := &amp;secure.DefaultCredentialConfig{\n        Password:       \"\",                    // Not set - check env var\n        PasswordEnvVar: \"DATABASE_PASSWORD\",   // Check this env var\n        PasswordFile:   \"/etc/secrets/db.txt\", // Fallback to file\n    }\n\n    // Create credential from configuration\n    credential, err := secure.CredentialFromConfig(config, key, false)\n    if err != nil {\n        log.Fatalf(\"Failed to load credential: %v\", err)\n    }\n\n    // Use credential\n    dbPassword, err := credential.Get()\n    if err != nil {\n        log.Fatalf(\"Failed to get password: %v\", err)\n    }\n\n    // Connect to database\n    connectToDatabase(\"user\", dbPassword, \"localhost\")\n\n    // Clear when done\n    credential.Clear()\n}\n</code></pre>"},{"location":"crypt/secure-credentials/#proper-error-handling","title":"Proper Error Handling","text":"<pre><code>func errorHandlingExample() {\n    key, err := secure.GenerateKey()\n    if err != nil {\n        log.Fatalf(\"Key generation failed: %v\", err)\n    }\n\n    // Try to create credential with potential errors\n    credential, err := secure.NewCredential([]byte(\"\"), key, false)\n    if err != nil {\n        switch err {\n        case secure.ErrEmptyCredential:\n            log.Println(\"Credential is empty\")\n        case secure.ErrInvalidKey:\n            log.Println(\"Invalid encryption key\")\n        default:\n            log.Printf(\"Unexpected error: %v\", err)\n        }\n        return\n    }\n\n    // Try to get credential value\n    value, err := credential.Get()\n    if err != nil {\n        switch err {\n        case secure.ErrDecryption:\n            log.Println(\"Failed to decrypt credential\")\n        case secure.ErrEmptyCredential:\n            log.Println(\"Credential is empty\")\n        default:\n            log.Printf(\"Unexpected error: %v\", err)\n        }\n        return\n    }\n\n    log.Printf(\"Successfully retrieved credential: %s\", value)\n}\n</code></pre>"},{"location":"crypt/secure-credentials/#key-management","title":"Key Management","text":"<pre><code>func keyManagementExample() {\n    // Generate a new key\n    key := secure.RandomKey32()\n\n    // Encode key for storage (e.g., in config file)\n    encodedKey := secure.EncodeKey(key)\n    log.Printf(\"Encoded key: %s\", encodedKey)\n\n    // Later, decode the key\n    decodedKey, err := secure.DecodeKey(encodedKey)\n    if err != nil {\n        log.Fatalf(\"Failed to decode key: %v\", err)\n    }\n\n    // Verify keys match\n    if len(decodedKey) != 32 {\n        log.Fatal(\"Decoded key has wrong length\")\n    }\n\n    // Use decoded key for credentials\n    credential, err := secure.NewCredential([]byte(\"secret\"), decodedKey, false)\n    if err != nil {\n        log.Fatalf(\"Failed to create credential with decoded key: %v\", err)\n    }\n\n    credential.Clear()\n}\n</code></pre>"},{"location":"crypt/secure-credentials/#memory-security-practices","title":"Memory Security Practices","text":"<pre><code>func memorySecurityExample() {\n    key, _ := secure.GenerateKey()\n\n    // Create credential\n    credential, err := secure.NewCredential([]byte(\"sensitive-data\"), key, false)\n    if err != nil {\n        log.Fatalf(\"Failed to create credential: %v\", err)\n    }\n\n    // Minimize exposure time\n    func() {\n        // Get credential only when needed\n        secret, err := credential.Get()\n        if err != nil {\n            return\n        }\n\n        // Use immediately\n        result := performSecureOperation(secret)\n\n        // Clear local variable (good practice)\n        secret = \"\"\n\n        processResult(result)\n    }()\n\n    // Always clear credential when done\n    credential.Clear()\n\n    // Clear key from memory\n    for i := range key {\n        key[i] = 0\n    }\n}\n</code></pre>"},{"location":"crypt/secure-credentials/#configuration-guide","title":"Configuration Guide","text":""},{"location":"crypt/secure-credentials/#priority-resolution","title":"Priority Resolution","text":"<p>All configuration structures follow the same priority order:</p> <ol> <li>Direct value (highest priority) - <code>Password</code> or <code>Key</code> field</li> <li>Environment variable (second priority) - <code>PasswordEnvVar</code> or <code>KeyEnvVar</code> field</li> <li>File (lowest priority) - <code>PasswordFile</code> or <code>KeyFile</code> field</li> </ol>"},{"location":"crypt/secure-credentials/#environment-variable-handling","title":"Environment Variable Handling","text":"<p>When using environment variables: - Variables are read once and then cleared for security - Empty variables are treated as not set - The <code>env.SetEnvVar(envVar, \"\")</code> call clears the variable after reading</p>"},{"location":"crypt/secure-credentials/#file-based-credentials","title":"File-Based Credentials","text":"<p>When using file-based credentials: - Files must be readable by the application - File contents are read as plaintext - Leading/trailing whitespace is trimmed - Empty files result in empty credentials</p>"},{"location":"crypt/secure-credentials/#custom-configuration","title":"Custom Configuration","text":"<p>Implement the <code>CredentialConfig</code> interface for custom sources:</p> <pre><code>type DatabaseCredentialConfig struct {\n    ConnectionString string\n    QueryTimeout     time.Duration\n}\n\nfunc (c *DatabaseCredentialConfig) Fetch() (string, error) {\n    // Custom logic to fetch credential from database\n    return fetchFromDatabase(c.ConnectionString), nil\n}\n\nfunc (c *DatabaseCredentialConfig) IsEmpty() bool {\n    return c.ConnectionString == \"\"\n}\n\n// Use with CredentialFromConfig\ncredential, err := secure.CredentialFromConfig(config, key, false)\n</code></pre>"},{"location":"crypt/secure-credentials/#troubleshooting","title":"Troubleshooting","text":""},{"location":"crypt/secure-credentials/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"crypt/secure-credentials/#errinvalidkey-invalid-encryption-key","title":"ErrInvalidKey - Invalid Encryption Key","text":"<p>Problem: Encryption key is not exactly 32 bytes.</p> <p>Symptoms: <pre><code>credential, err := secure.NewCredential(data, key, false)\n// err == secure.ErrInvalidKey\n</code></pre></p> <p>Solutions: <pre><code>// Generate proper 32-byte key\nkey, err := secure.GenerateKey()\nif err != nil {\n    // Handle generation error\n}\n\n// Or create from existing data\nkey := make([]byte, 32)\ncopy(key, []byte(\"your-key-data\")) // Ensure exactly 32 bytes\n\n// Verify key length before use\nif len(key) != 32 {\n    log.Fatal(\"Key must be exactly 32 bytes\")\n}\n</code></pre></p>"},{"location":"crypt/secure-credentials/#errsecretsfilenotfound-file-access-issues","title":"ErrSecretsFileNotFound - File Access Issues","text":"<p>Problem: Secrets file doesn't exist or isn't readable.</p> <p>Common causes: - File path is incorrect - File permissions prevent reading - File doesn't exist</p> <p>Debugging: <pre><code>import \"os\"\n\nfunc debugFileAccess(filename string) {\n    // Check if file exists\n    if _, err := os.Stat(filename); os.IsNotExist(err) {\n        log.Printf(\"File does not exist: %s\", filename)\n        return\n    }\n\n    // Check if file is readable\n    file, err := os.Open(filename)\n    if err != nil {\n        log.Printf(\"Cannot read file: %v\", err)\n        return\n    }\n    file.Close()\n\n    log.Printf(\"File is accessible: %s\", filename)\n}\n</code></pre></p> <p>Solutions: - Verify file path is absolute or relative to working directory - Check file permissions: <code>chmod 644 /path/to/secrets.txt</code> - Ensure file exists before application starts - Use proper error handling for missing files</p>"},{"location":"crypt/secure-credentials/#erremptycredential-empty-credential-issues","title":"ErrEmptyCredential - Empty Credential Issues","text":"<p>Problem: Credential is empty when <code>allowEmpty=false</code>.</p> <p>Debugging: <pre><code>func debugEmptyCredential(config *secure.DefaultCredentialConfig) {\n    if config.IsEmpty() {\n        log.Println(\"All configuration fields are empty\")\n        return\n    }\n\n    // Check each source\n    if config.Password != \"\" {\n        log.Println(\"Using direct password\")\n    } else if config.PasswordEnvVar != \"\" {\n        envValue := os.Getenv(config.PasswordEnvVar)\n        if envValue == \"\" {\n            log.Printf(\"Environment variable %s is empty\", config.PasswordEnvVar)\n        } else {\n            log.Printf(\"Environment variable %s has value\", config.PasswordEnvVar)\n        }\n    } else if config.PasswordFile != \"\" {\n        content, err := os.ReadFile(config.PasswordFile)\n        if err != nil {\n            log.Printf(\"Cannot read file %s: %v\", config.PasswordFile, err)\n        } else if len(content) == 0 {\n            log.Printf(\"File %s is empty\", config.PasswordFile)\n        } else {\n            log.Printf(\"File %s has content\", config.PasswordFile)\n        }\n    }\n}\n</code></pre></p>"},{"location":"crypt/secure-credentials/#memory-management-issues","title":"Memory Management Issues","text":"<p>Problem: Sensitive data remains in memory longer than necessary.</p> <p>Best practices: <pre><code>func properMemoryManagement() {\n    key, _ := secure.GenerateKey()\n    credential, _ := secure.NewCredential([]byte(\"secret\"), key, false)\n\n    // Minimize scope of sensitive data\n    {\n        secret, err := credential.Get()\n        if err != nil {\n            return\n        }\n\n        // Use secret immediately\n        useSecret(secret)\n\n        // Clear local variable\n        secret = \"\"\n    }\n\n    // Clear credential when done\n    credential.Clear()\n\n    // Clear key\n    for i := range key {\n        key[i] = 0\n    }\n}\n</code></pre></p>"},{"location":"crypt/secure-credentials/#concurrent-access-issues","title":"Concurrent Access Issues","text":"<p>Problem: Race conditions when accessing credentials from multiple goroutines.</p> <p>Solution: The <code>Credential</code> type is thread-safe, but ensure proper usage:</p> <pre><code>func concurrentAccess() {\n    key, _ := secure.GenerateKey()\n    credential, _ := secure.NewCredential([]byte(\"shared-secret\"), key, false)\n\n    var wg sync.WaitGroup\n\n    // Multiple goroutines can safely read\n    for i := 0; i &lt; 10; i++ {\n        wg.Add(1)\n        go func() {\n            defer wg.Done()\n            secret, err := credential.Get()\n            if err != nil {\n                return\n            }\n            // Use secret\n            processSecret(secret)\n        }()\n    }\n\n    wg.Wait()\n\n    // Clear once when all operations complete\n    credential.Clear()\n}\n</code></pre>"},{"location":"crypt/secure-credentials/#debugging-techniques","title":"Debugging Techniques","text":""},{"location":"crypt/secure-credentials/#enable-debug-logging","title":"Enable Debug Logging","text":"<pre><code>import \"log\"\n\nfunc debugCredentialCreation() {\n    key, err := secure.GenerateKey()\n    if err != nil {\n        log.Printf(\"Key generation failed: %v\", err)\n        return\n    }\n    log.Printf(\"Generated key length: %d\", len(key))\n\n    data := []byte(\"test-password\")\n    log.Printf(\"Data length: %d\", len(data))\n\n    credential, err := secure.NewCredential(data, key, false)\n    if err != nil {\n        log.Printf(\"Credential creation failed: %v\", err)\n        return\n    }\n    log.Println(\"Credential created successfully\")\n\n    if credential.IsEmpty() {\n        log.Println(\"Credential is empty\")\n    } else {\n        log.Println(\"Credential contains data\")\n    }\n}\n</code></pre>"},{"location":"crypt/secure-credentials/#validate-configuration","title":"Validate Configuration","text":"<pre><code>func validateConfiguration(config *secure.DefaultCredentialConfig) error {\n    if config.IsEmpty() {\n        return fmt.Errorf(\"configuration is completely empty\")\n    }\n\n    // Check environment variable if specified\n    if config.PasswordEnvVar != \"\" {\n        if os.Getenv(config.PasswordEnvVar) == \"\" {\n            return fmt.Errorf(\"environment variable %s is not set\", config.PasswordEnvVar)\n        }\n    }\n\n    // Check file if specified\n    if config.PasswordFile != \"\" {\n        if _, err := os.Stat(config.PasswordFile); err != nil {\n            return fmt.Errorf(\"cannot access file %s: %v\", config.PasswordFile, err)\n        }\n    }\n\n    return nil\n}\n</code></pre>"},{"location":"crypt/secure-credentials/#best-practices","title":"Best Practices","text":""},{"location":"crypt/secure-credentials/#development-environment","title":"Development Environment","text":""},{"location":"crypt/secure-credentials/#simplified-configuration","title":"Simplified Configuration","text":"<pre><code>func developmentSetup() *secure.Credential {\n    // Use simple, fixed key for development\n    key := make([]byte, 32)\n    copy(key, []byte(\"development-key-not-secure\"))\n\n    // Allow empty credentials for optional services\n    config := &amp;secure.DefaultCredentialConfig{\n        Password: \"dev-password\", // Direct password for simplicity\n    }\n\n    credential, err := secure.CredentialFromConfig(config, key, true)\n    if err != nil {\n        log.Fatalf(\"Development credential setup failed: %v\", err)\n    }\n\n    return credential\n}\n</code></pre>"},{"location":"crypt/secure-credentials/#development-best-practices","title":"Development Best Practices","text":"<ul> <li>Use fixed, non-random keys for consistent testing</li> <li>Allow empty credentials for optional services</li> <li>Store development secrets in easily accessible files</li> <li>Log credential operations for debugging</li> <li>Don't worry about memory clearing in development</li> </ul>"},{"location":"crypt/secure-credentials/#staging-environment","title":"Staging Environment","text":""},{"location":"crypt/secure-credentials/#realistic-security-testing","title":"Realistic Security Testing","text":"<pre><code>func stagingSetup() *secure.Credential {\n    // Generate random key but store it for test repeatability\n    keyFile := \"/etc/staging/encryption.key\"\n\n    var key []byte\n    if content, err := os.ReadFile(keyFile); err == nil {\n        key, _ = secure.DecodeKey(string(content))\n    } else {\n        key, _ = secure.GenerateKey()\n        encoded := secure.EncodeKey(key)\n        os.WriteFile(keyFile, []byte(encoded), 0600)\n    }\n\n    // Use environment variables like production\n    config := &amp;secure.DefaultCredentialConfig{\n        PasswordEnvVar: \"STAGING_DB_PASSWORD\",\n    }\n\n    credential, err := secure.CredentialFromConfig(config, key, false)\n    if err != nil {\n        log.Fatalf(\"Staging credential setup failed: %v\", err)\n    }\n\n    return credential\n}\n</code></pre>"},{"location":"crypt/secure-credentials/#staging-best-practices","title":"Staging Best Practices","text":"<ul> <li>Use realistic key generation and storage</li> <li>Test environment variable handling</li> <li>Validate all credential sources work correctly</li> <li>Test file permission scenarios</li> <li>Simulate production-like security constraints</li> </ul>"},{"location":"crypt/secure-credentials/#production-environment","title":"Production Environment","text":""},{"location":"crypt/secure-credentials/#maximum-security-configuration","title":"Maximum Security Configuration","text":"<pre><code>func productionSetup() *secure.Credential {\n    // Load key from secure key management service or hardware token\n    key := loadProductionKey()\n\n    // Strict configuration - no direct passwords\n    config := &amp;secure.DefaultCredentialConfig{\n        PasswordEnvVar: \"PROD_SERVICE_PASSWORD\",\n        PasswordFile:   \"/run/secrets/service_password\", // Docker secrets or similar\n    }\n\n    credential, err := secure.CredentialFromConfig(config, key, false)\n    if err != nil {\n        log.Fatalf(\"Production credential setup failed: %v\", err)\n    }\n\n    return credential\n}\n\nfunc loadProductionKey() []byte {\n    // Example: Load from hardware security module\n    // or cloud key management service\n    keyData := os.Getenv(\"ENCRYPTION_KEY_B64\")\n    if keyData == \"\" {\n        log.Fatal(\"ENCRYPTION_KEY_B64 environment variable required\")\n    }\n\n    key, err := secure.DecodeKey(keyData)\n    if err != nil {\n        log.Fatalf(\"Invalid encryption key: %v\", err)\n    }\n\n    return key\n}\n</code></pre>"},{"location":"crypt/secure-credentials/#production-best-practices","title":"Production Best Practices","text":"<ul> <li>Never use direct password fields in configuration</li> <li>Use secure key management services for encryption keys</li> <li>Implement key rotation procedures</li> <li>Clear credentials immediately after use</li> <li>Monitor for credential access failures</li> <li>Use file-based secrets for container orchestration</li> <li>Implement proper logging without exposing secrets</li> </ul>"},{"location":"crypt/secure-credentials/#performance-optimization","title":"Performance Optimization","text":""},{"location":"crypt/secure-credentials/#minimize-decryption-operations","title":"Minimize Decryption Operations","text":"<pre><code>type ServiceWithCredentials struct {\n    credential *secure.Credential\n    cachedAuth string\n    authExpiry time.Time\n    mutex      sync.RWMutex\n}\n\nfunc (s *ServiceWithCredentials) getAuthToken() (string, error) {\n    s.mutex.RLock()\n    if time.Now().Before(s.authExpiry) &amp;&amp; s.cachedAuth != \"\" {\n        defer s.mutex.RUnlock()\n        return s.cachedAuth, nil\n    }\n    s.mutex.RUnlock()\n\n    // Need to refresh - acquire write lock\n    s.mutex.Lock()\n    defer s.mutex.Unlock()\n\n    // Double-check after acquiring write lock\n    if time.Now().Before(s.authExpiry) &amp;&amp; s.cachedAuth != \"\" {\n        return s.cachedAuth, nil\n    }\n\n    // Get fresh credential\n    password, err := s.credential.Get()\n    if err != nil {\n        return \"\", err\n    }\n\n    // Authenticate and cache result\n    token := authenticateAndGetToken(password)\n    s.cachedAuth = token\n    s.authExpiry = time.Now().Add(5 * time.Minute)\n\n    return token, nil\n}\n</code></pre>"},{"location":"crypt/secure-credentials/#batch-operations","title":"Batch Operations","text":"<pre><code>func performBatchOperations(credentials []*secure.Credential) error {\n    // Get all credentials at once to minimize lock contention\n    passwords := make([]string, len(credentials))\n    for i, cred := range credentials {\n        password, err := cred.Get()\n        if err != nil {\n            return fmt.Errorf(\"failed to get credential %d: %v\", i, err)\n        }\n        passwords[i] = password\n    }\n\n    // Perform all operations\n    results := performOperations(passwords)\n\n    // Clear passwords immediately\n    for i := range passwords {\n        passwords[i] = \"\"\n    }\n\n    return processResults(results)\n}\n</code></pre>"},{"location":"crypt/secure-credentials/#security-guidelines","title":"Security Guidelines","text":""},{"location":"crypt/secure-credentials/#key-management_1","title":"Key Management","text":"<ul> <li>Generate unique keys per application instance</li> <li>Store keys in secure key management systems</li> <li>Implement key rotation procedures</li> <li>Never log or expose encryption keys</li> <li>Use hardware security modules when available</li> </ul>"},{"location":"crypt/secure-credentials/#memory-security","title":"Memory Security","text":"<ul> <li>Call <code>Clear()</code> on credentials when done</li> <li>Minimize lifetime of decrypted data</li> <li>Avoid storing credentials in variables longer than necessary</li> <li>Clear temporary variables containing sensitive data</li> </ul>"},{"location":"crypt/secure-credentials/#access-control","title":"Access Control","text":"<ul> <li>Limit which code can access credentials</li> <li>Use dependency injection to control credential access</li> <li>Implement audit logging for credential operations</li> <li>Monitor for unauthorized access attempts</li> </ul>"},{"location":"crypt/secure-credentials/#error-handling","title":"Error Handling","text":"<ul> <li>Don't expose sensitive information in error messages</li> <li>Log errors appropriately without revealing secrets</li> <li>Implement proper fallback mechanisms</li> <li>Validate all inputs before creating credentials</li> </ul>"},{"location":"db/","title":"Database Package","text":"<p>The Blueprint database package provides a comprehensive, interface-driven abstraction layer for SQL database operations.  It combines the power of the Repository pattern with advanced features like dynamic query building, field metadata extraction,  and database migrations.</p> <p>The database package functionality focus on working with structs, not individual variables; most functions won't work with individual variables;</p> <p>Not all funcionality is available for ClickHouse databases </p>"},{"location":"db/#overview","title":"Overview","text":"<p>The db package is designed around the principle of interface-based composition, offering different levels of abstraction to suit various use cases:</p> <ul> <li>High-level: Repository pattern with automatic query building</li> <li>Medium-level: Grid system for dynamic, filterable queries  </li> <li>Low-level: Raw SQL functions and query builders</li> </ul>"},{"location":"db/#architecture","title":"Architecture","text":"<p>The package consists of several interconnected components:</p> <pre><code>db/\n\u251c\u2500\u2500 Core Interfaces\n\u2502   \u251c\u2500\u2500 Client          - Database connection management\n\u2502   \u251c\u2500\u2500 Repository      - High-level CRUD operations\n\u2502   \u2514\u2500\u2500 Transaction     - Transactional operations\n\u251c\u2500\u2500 Query Building\n\u2502   \u251c\u2500\u2500 Grid            - Dynamic query building with filtering/sorting\n\u2502   \u251c\u2500\u2500 QueryBuilder    - SQL generation and dialect abstraction\n\u2502   \u2514\u2500\u2500 Functions       - Raw SQL operations and utilities\n\u251c\u2500\u2500 Metadata System\n\u2502   \u251c\u2500\u2500 Field           - Struct field analysis and mapping\n\u2502   \u2514\u2500\u2500 Types           - Type detection and validation\n\u2514\u2500\u2500 Migration System\n    \u251c\u2500\u2500 Manager         - Migration execution and tracking\n    \u2514\u2500\u2500 Sources         - Migration source implementations\n</code></pre>"},{"location":"db/#quick-start","title":"Quick Start","text":""},{"location":"db/#basic-repository-usage","title":"Basic Repository Usage","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"github.com/oddbit-project/blueprint/db\"\n    \"github.com/oddbit-project/blueprint/provider/pgsql\"\n    \"log\"\n    \"time\"\n)\n\ntype User struct {\n    ID        int       `db:\"id\" goqu:\"skipinsert\"`\n    Name      string    `db:\"name\"`\n    Email     string    `db:\"email\"`\n    CreatedAt time.Time `db:\"created_at\"`\n}\n\nfunc main() {\n    // Setup database connection\n    pgConfig := pgsql.NewClientConfig()\n    pgConfig.DSN = \"postgres://user:pass@localhost/db?sslmode=disable\"\n\n    client, err := pgsql.NewClient(pgConfig)\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer client.Disconnect()\n\n    // Create repository\n    repo := db.NewRepository(context.Background(), client, \"users\")\n\n    // Insert single user\n    user := &amp;User{\n        Name:      \"John Doe\",\n        Email:     \"john@example.com\", \n        CreatedAt: time.Now(),\n    }\n\n    if err := repo.Insert(user); err != nil {\n        log.Fatal(err)\n    }\n\n    // Batch insert multiple users\n    batchUsers := []*User{\n        {Name: \"Alice\", Email: \"alice@example.com\", CreatedAt: time.Now()},\n        {Name: \"Bob\", Email: \"bob@example.com\", CreatedAt: time.Now()},\n        {Name: \"Charlie\", Email: \"charlie@example.com\", CreatedAt: time.Now()},\n    }\n\n    if err := repo.Insert(db.ToAnySlice(batchUsers)...); err != nil {\n        log.Fatal(err)\n    }\n\n    // Fetch all users\n    var users []*User\n    if err := repo.Fetch(repo.SqlSelect(), &amp;users); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>"},{"location":"db/#grid-based-dynamic-queries","title":"Grid-based Dynamic Queries","text":"<pre><code>type User struct {\n    ID       int    `db:\"id\" json:\"id\" grid:\"sort,filter\"`\n    Username string `db:\"username\" json:\"username\" grid:\"sort,search,filter\"`\n    Email    string `db:\"email\" json:\"email\" grid:\"search,filter\"`\n    Active   bool   `db:\"active\" json:\"active\" grid:\"filter\"`\n}\n\nfunc main() {\n    // ... setup repository ...\n\n    // Create dynamic query\n    query, _ := db.NewGridQuery(db.SearchAny, 10, 0)\n    query.SearchText = \"john\"\n    query.FilterFields = map[string]any{\"active\": true}\n    query.SortFields = map[string]string{\"username\": db.SortAscending}\n\n    // Execute query\n    var users []*User\n    err := repo.QueryGrid(&amp;User{}, query, &amp;users)\n    if err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>"},{"location":"db/#core-components","title":"Core Components","text":""},{"location":"db/#structs-and-tags","title":"Structs and Tags","text":"<p>Comprehensive guide to creating database structs and using the tag system. Covers all available tags for field mapping, query behavior, grid functionality, and data serialization.</p> <p>Key Features: - Complete tag reference (db, goqu, grid, json, auto, etc.) - Struct composition and embedding patterns - Best practices for field definition - Multi-database support with different field mappings</p>"},{"location":"db/#client-interface","title":"Client Interface","text":"<p>Database connection management and configuration. Provides the foundation for all database operations with support for connection options and health checking.</p> <p>Key Features: - Connection lifecycle management - Provider abstraction (PostgreSQL, ClickHouse) - Connection health monitoring - Configuration flexibility</p>"},{"location":"db/#repository-pattern","title":"Repository Pattern","text":"<p>High-level interface for CRUD operations with automatic query generation and transaction support.</p> <p>Key Features: - Interface-based design with composition - Automatic query building from structs - Transaction support - Counting and aggregation operations - Grid integration for dynamic queries</p>"},{"location":"db/#data-grid-system","title":"Data Grid System","text":"<p>Dynamic query building with filtering, sorting, searching, and pagination capabilities based on struct field tags.</p> <p>Key Features: - Struct tag-driven configuration - Dynamic filtering and sorting - Text search across multiple fields - Custom filter functions - Pagination support</p>"},{"location":"db/#field-metadata","title":"Field Metadata","text":"<p>Struct field analysis and mapping system that powers the Repository and Grid components.</p> <p>Key Features: - Automatic field discovery from struct tags - Alias mapping (JSON, XML, custom) - Embedded struct support - Type-aware processing - Caching for performance</p>"},{"location":"db/#query-builder","title":"Query Builder","text":"<p>Low-level SQL generation with dialect abstraction and advanced features like RETURNING clauses.</p> <p>Key Features: - SQL dialect abstraction - Type-safe query building - RETURNING clause support - Batch operations - Integration with field metadata</p>"},{"location":"db/#database-functions","title":"Database Functions","text":"<p>Low-level database operations and utilities for advanced use cases.</p> <p>Key Features: - Raw SQL execution - Intelligent result scanning - Context-aware operations - Type detection and conversion - Error handling utilities</p>"},{"location":"db/#migration-system","title":"Migration System","text":"<p>Database schema migration management with progress tracking and multiple source types.</p> <p>Key Features: - Interface-based migration sources - Progress tracking and callbacks - SHA2-based change detection - Rollback protection - Multiple source implementations</p>"},{"location":"db/#integration-with-providers","title":"Integration with Providers","text":"<p>The db package integrates seamlessly with Blueprint's provider system:</p> <ul> <li>PostgreSQL Provider: Full-featured PostgreSQL support with advanced types</li> <li>ClickHouse Provider: Analytics database support with specialized features</li> </ul>"},{"location":"db/#design-principles","title":"Design Principles","text":""},{"location":"db/#interface-driven-design","title":"Interface-Driven Design","text":"<p>All major components are defined by interfaces, allowing for easy testing, mocking, and extensibility.</p>"},{"location":"db/#composition-over-inheritance","title":"Composition Over Inheritance","text":"<p>The Repository interface composes multiple smaller interfaces (Reader, Writer, Updater, etc.) for flexibility.</p>"},{"location":"db/#context-aware-operations","title":"Context-Aware Operations","text":"<p>All database operations accept and propagate Go contexts for proper cancellation and timeout handling.</p>"},{"location":"db/#type-safety","title":"Type Safety","text":"<p>Extensive use of Go's type system to catch errors at compile time and provide clear APIs.</p>"},{"location":"db/#performance-focus","title":"Performance Focus","text":"<p>Built-in caching, connection pooling, and efficient query generation for production use.</p>"},{"location":"db/#when-to-use-each-component","title":"When to Use Each Component","text":""},{"location":"db/#use-repository-when","title":"Use Repository When:","text":"<ul> <li>Building standard CRUD applications</li> <li>Need automatic query generation</li> <li>Want transaction support</li> <li>Require counting and aggregation</li> </ul>"},{"location":"db/#use-grid-when","title":"Use Grid When:","text":"<ul> <li>Building data tables with server-side processing</li> <li>Need dynamic filtering and sorting</li> <li>Implementing search functionality</li> <li>Creating flexible APIs</li> </ul>"},{"location":"db/#use-functions-when","title":"Use Functions When:","text":"<ul> <li>Need raw SQL control</li> <li>Implementing complex queries</li> <li>Building custom abstractions</li> <li>Performance-critical operations</li> </ul>"},{"location":"db/#use-query-builder-when","title":"Use Query Builder When:","text":"<ul> <li>Need portable SQL generation</li> <li>Building complex queries programmatically</li> <li>Require RETURNING clause support</li> <li>Want type-safe query construction</li> </ul>"},{"location":"db/#error-handling","title":"Error Handling","text":"<p>The package provides consistent error handling patterns:</p> <pre><code>// Check for empty results\nif db.EmptyResult(err) {\n    // Handle no rows found\n}\n\n// Grid errors include scope and field information\nif gridErr, ok := err.(db.GridError); ok {\n    fmt.Printf(\"Grid error in %s for field %s: %s\", \n        gridErr.Scope, gridErr.Field, gridErr.Message)\n}\n</code></pre>"},{"location":"db/#best-practices","title":"Best Practices","text":"<ol> <li>Use Contexts: Always pass contexts for proper cancellation handling</li> <li>Handle Empty Results: Check for <code>db.EmptyResult(err)</code> when fetching single records</li> <li>Use Transactions: Wrap related operations in transactions for consistency</li> <li>Cache Field Specs: Repository automatically caches field metadata for performance</li> <li>Validate Grid Queries: Always validate Grid queries before building SQL</li> <li>Use Appropriate Abstraction: Choose the right level based on your needs</li> </ol>"},{"location":"db/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Field Spec Caching: Struct metadata is cached automatically</li> <li>Connection Pooling: Managed by underlying provider packages</li> <li>Prepared Statements: Used automatically where beneficial</li> <li>Batch Operations: Available for bulk inserts and updates</li> <li>Lazy Loading: Grid field specs are built on-demand</li> </ul>"},{"location":"db/#see-also","title":"See Also","text":"<ul> <li>Getting Started Guide</li> <li>Provider Documentation</li> <li>Configuration Management</li> <li>Security Best Practices</li> </ul>"},{"location":"db/client/","title":"Database Client","text":"<p>The Client interface provides the foundation for database connections in the Blueprint db package. It abstracts database connection management and provides a consistent interface across different database providers.</p>"},{"location":"db/client/#overview","title":"Overview","text":"<p>The Client interface and SqlClient implementation handle:</p> <ul> <li>Database connection lifecycle management</li> <li>Connection health monitoring</li> <li>Configuration through connection options</li> <li>Provider abstraction for different database types</li> </ul>"},{"location":"db/client/#client-interface","title":"Client Interface","text":"<pre><code>type Client interface {\n    GetClient() *sqlx.DB\n    IsConnected() bool\n    Connect() error\n    Disconnect()\n}\n</code></pre>"},{"location":"db/client/#methods","title":"Methods","text":""},{"location":"db/client/#getclient-sqlxdb","title":"GetClient() *sqlx.DB","text":"<p>Returns the underlying sqlx.DB connection. This provides direct access to the database connection for advanced operations.</p>"},{"location":"db/client/#isconnected-bool","title":"IsConnected() bool","text":"<p>Returns true if the client has an active database connection.</p>"},{"location":"db/client/#connect-error","title":"Connect() error","text":"<p>Establishes a connection to the database using the configured DSN and options. This method: - Opens a connection using the specified driver - Applies any connection options - Performs a health check with Ping()</p>"},{"location":"db/client/#disconnect","title":"Disconnect()","text":"<p>Closes the database connection and cleans up resources. Safe to call multiple times.</p>"},{"location":"db/client/#sqlclient-implementation","title":"SqlClient Implementation","text":"<p>The SqlClient struct provides the standard implementation of the Client interface:</p> <pre><code>type SqlClient struct {\n    Conn        *sqlx.DB\n    Dsn         string\n    DriverName  string\n    connOptions ConnectionOptions\n}\n</code></pre>"},{"location":"db/client/#fields","title":"Fields","text":"<ul> <li>Conn: The active sqlx.DB connection (nil when disconnected)</li> <li>Dsn: Database connection string</li> <li>DriverName: SQL driver name (e.g., \"postgres\", \"clickhouse\")</li> <li>connOptions: Optional connection configuration</li> </ul>"},{"location":"db/client/#connectionoptions-interface","title":"ConnectionOptions Interface","text":"<pre><code>type ConnectionOptions interface {\n    Apply(db *sqlx.DB) error\n}\n</code></pre> <p>Connection options allow customization of the database connection after it's established. This is used by provider packages to configure:</p> <ul> <li>Connection pool settings</li> <li>Timeout values</li> <li>SSL/TLS configuration</li> <li>Database-specific parameters</li> </ul>"},{"location":"db/client/#usage-examples","title":"Usage Examples","text":""},{"location":"db/client/#basic-connection","title":"Basic Connection","text":"<pre><code>package main\n\nimport (\n    \"github.com/oddbit-project/blueprint/db\"\n    \"github.com/oddbit-project/blueprint/provider/pgsql\"\n    \"log\"\n)\n\nfunc main() {\n    // Create client with basic configuration\n    client := db.NewSqlClient(\n        \"postgres://user:pass@localhost/dbname?sslmode=disable\",\n        \"postgres\",\n        nil, // no connection options\n    )\n\n    // Connect to database\n    if err := client.Connect(); err != nil {\n        log.Fatal(\"Failed to connect:\", err)\n    }\n    defer client.Disconnect()\n\n    // Check connection status\n    if client.IsConnected() {\n        log.Println(\"Connected to database\")\n    }\n\n    // Get underlying sqlx.DB for direct operations\n    db := client.GetClient()\n    rows, err := db.Query(\"SELECT version()\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer rows.Close()\n}\n</code></pre>"},{"location":"db/client/#using-provider-packages","title":"Using Provider Packages","text":"<p>The recommended approach is to use provider packages that handle client creation and configuration:</p> <pre><code>package main\n\nimport (\n    \"github.com/oddbit-project/blueprint/provider/pgsql\"\n    \"log\"\n)\n\nfunc main() {\n    // Create PostgreSQL client with provider\n    config := pgsql.NewClientConfig()\n    config.DSN = \"postgres://user:pass@localhost/dbname?sslmode=disable\"\n    config.MaxOpenConns = 25\n    config.MaxIdleConns = 5\n\n    client, err := pgsql.NewClient(config)\n    if err != nil {\n        log.Fatal(\"Failed to create client:\", err)\n    }\n    defer client.Disconnect()\n\n    // Client is automatically connected and configured\n    if client.IsConnected() {\n        log.Println(\"PostgreSQL client ready\")\n    }\n}\n</code></pre>"},{"location":"db/client/#connection-with-custom-options","title":"Connection with Custom Options","text":"<pre><code>package main\n\nimport (\n    \"github.com/jmoiron/sqlx\"\n    \"github.com/oddbit-project/blueprint/db\"\n    \"time\"\n)\n\n// Custom connection options\ntype CustomOptions struct {\n    MaxOpenConns int\n    MaxIdleConns int\n    MaxLifetime  time.Duration\n}\n\nfunc (opts *CustomOptions) Apply(db *sqlx.DB) error {\n    db.SetMaxOpenConns(opts.MaxOpenConns)\n    db.SetMaxIdleConns(opts.MaxIdleConns)\n    db.SetConnMaxLifetime(opts.MaxLifetime)\n    return nil\n}\n\nfunc main() {\n    options := &amp;CustomOptions{\n        MaxOpenConns: 20,\n        MaxIdleConns: 5,\n        MaxLifetime:  time.Hour,\n    }\n\n    client := db.NewSqlClient(\n        \"postgres://user:pass@localhost/dbname?sslmode=disable\",\n        \"postgres\",\n        options,\n    )\n\n    if err := client.Connect(); err != nil {\n        log.Fatal(err)\n    }\n    defer client.Disconnect()\n}\n</code></pre>"},{"location":"db/client/#connection-health-checking","title":"Connection Health Checking","text":"<pre><code>func checkConnectionHealth(client db.Client) error {\n    if !client.IsConnected() {\n        return errors.New(\"client not connected\")\n    }\n\n    // Perform health check\n    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n    defer cancel()\n\n    return client.GetClient().PingContext(ctx)\n}\n\nfunc maintainConnection(client db.Client) {\n    ticker := time.NewTicker(30 * time.Second)\n    defer ticker.Stop()\n\n    for range ticker.C {\n        if err := checkConnectionHealth(client); err != nil {\n            log.Printf(\"Connection health check failed: %v\", err)\n\n            // Attempt reconnection\n            if err := client.Connect(); err != nil {\n                log.Printf(\"Reconnection failed: %v\", err)\n            } else {\n                log.Println(\"Reconnected successfully\")\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"db/client/#integration-with-repository","title":"Integration with Repository","text":"<p>The Client is typically used as the foundation for Repository instances:</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"github.com/oddbit-project/blueprint/db\"\n    \"github.com/oddbit-project/blueprint/provider/pgsql\"\n)\n\nfunc main() {\n    // Create and configure client\n    config := pgsql.NewClientConfig()\n    config.DSN = \"postgres://user:pass@localhost/dbname?sslmode=disable\"\n\n    client, err := pgsql.NewClient(config)\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer client.Disconnect()\n\n    // Create repository using the client\n    repo := db.NewRepository(context.Background(), client, \"users\")\n\n    // Repository operations use the client's connection\n    count, err := repo.Count()\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    log.Printf(\"User count: %d\", count)\n}\n</code></pre>"},{"location":"db/client/#error-handling","title":"Error Handling","text":"<p>The Client interface uses standard Go error handling patterns:</p> <pre><code>func connectWithRetry(client db.Client, maxRetries int) error {\n    var lastErr error\n\n    for i := 0; i &lt; maxRetries; i++ {\n        if err := client.Connect(); err != nil {\n            lastErr = err\n            log.Printf(\"Connection attempt %d failed: %v\", i+1, err)\n            time.Sleep(time.Duration(i+1) * time.Second)\n            continue\n        }\n        return nil\n    }\n\n    return fmt.Errorf(\"failed to connect after %d attempts: %w\", maxRetries, lastErr)\n}\n</code></pre>"},{"location":"db/client/#provider-implementations","title":"Provider Implementations","text":"<p>Different database providers implement the Client interface through their own client types:</p>"},{"location":"db/client/#postgresql-client","title":"PostgreSQL Client","text":"<pre><code>// Provider-specific client with PostgreSQL optimizations\nclient, err := pgsql.NewClient(config)\n</code></pre>"},{"location":"db/client/#clickhouse-client","title":"ClickHouse Client","text":"<pre><code>// Provider-specific client with ClickHouse optimizations  \nclient, err := clickhouse.NewClient(config)\n</code></pre> <p>Each provider client: - Implements the Client interface - Provides database-specific connection options - Handles provider-specific configuration - Optimizes for the target database type</p>"},{"location":"db/client/#best-practices","title":"Best Practices","text":""},{"location":"db/client/#connection-management","title":"Connection Management","text":"<ol> <li>Always defer Disconnect(): Ensure connections are properly closed</li> <li>Check connection status: Use IsConnected() before operations</li> <li>Handle connection failures: Implement retry logic for robustness</li> <li>Monitor connection health: Periodically check connection status</li> </ol>"},{"location":"db/client/#configuration","title":"Configuration","text":"<ol> <li>Use provider packages: They handle database-specific optimizations</li> <li>Configure connection pools: Set appropriate pool sizes for your workload</li> <li>Set timeouts: Configure appropriate timeout values</li> <li>Use SSL/TLS: Enable encryption for production deployments</li> </ol>"},{"location":"db/client/#error-handling_1","title":"Error Handling","text":"<ol> <li>Handle connection errors: Network issues, authentication failures, etc.</li> <li>Implement reconnection logic: For long-running applications</li> <li>Log connection events: For debugging and monitoring</li> <li>Graceful degradation: Handle database unavailability</li> </ol>"},{"location":"db/client/#performance-considerations","title":"Performance Considerations","text":""},{"location":"db/client/#connection-pooling","title":"Connection Pooling","text":"<ul> <li>Provider packages handle connection pooling automatically</li> <li>Configure pool sizes based on your application's concurrency needs</li> <li>Monitor pool utilization and adjust as needed</li> </ul>"},{"location":"db/client/#connection-reuse","title":"Connection Reuse","text":"<ul> <li>The Repository pattern reuses the client connection efficiently</li> <li>Avoid creating multiple clients for the same database</li> <li>Share clients across Repository instances when appropriate</li> </ul>"},{"location":"db/client/#health-checking","title":"Health Checking","text":"<ul> <li>Implement periodic health checks for long-running connections</li> <li>Use reasonable timeout values to avoid blocking operations</li> <li>Consider using connection pool health checking features</li> </ul>"},{"location":"db/client/#see-also","title":"See Also","text":"<ul> <li>Repository Documentation</li> <li>PostgreSQL Provider</li> <li>ClickHouse Provider</li> <li>Database Package Overview</li> </ul>"},{"location":"db/dbgrid/","title":"db.Grid","text":"<p>Data grid component for building dynamic SQL queries with filtering, sorting, searching, and pagination capabilities. The Grid component is integrated with the Repository through the GridOps interface.</p>"},{"location":"db/dbgrid/#overview","title":"Overview","text":"<p>The Grid component provides a structure and methods for building dynamic database queries based on a structured configuration.  It's particularly useful for:</p> <ul> <li>Building data tables with server-side processing</li> <li>Implementing API endpoints for data retrieval with dynamic criteria</li> <li>Constructing complex queries with multiple filtering, sorting, and search conditions</li> </ul> <p>The Grid component uses a struct's field tags to define which fields can be: - Filtered - Sorted - Searched</p> <p>In addition, it detects alias names such as json field names, and transparently maps them to the appropriate database field.</p> <p>It then validates and builds queries using the goqu SQL builder.</p>"},{"location":"db/dbgrid/#usage","title":"Usage","text":""},{"location":"db/dbgrid/#basic-usage","title":"Basic Usage","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"github.com/oddbit-project/blueprint/db\"\n    \"log\"\n)\n\n// Define a struct with grid tags\ntype UserRecord struct {\n    ID        int    `db:\"id\" json:\"id\" grid:\"sort,filter\"`\n    Username  string `db:\"username\" json:\"username\" grid:\"sort,search,filter\"`\n    Email     string `db:\"email\" json:\"email\" grid:\"sort,search,filter\"`\n    Active    bool   `db:\"active\" json:\"active\" grid:\"filter\"`\n}\n\nfunc main() {\n    // Create a grid from the struct\n    grid, err := db.NewGrid(\"users\", &amp;UserRecord{})\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Create a query\n    query, err := db.NewGridQuery(db.SearchAny, 10, 0)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Set search text, filters, and sort conditions\n    query.SearchText = \"john\"\n    query.FilterFields = map[string]any{\n        \"active\": true,\n    }\n    query.SortFields = map[string]string{\n        \"username\": db.SortAscending,\n    }\n\n    // Validate the query\n    if err := grid.ValidQuery(query); err != nil {\n        log.Fatal(err)\n    }\n\n    // Build the query\n    statement, err := grid.Build(nil, query)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Get the SQL\n    sql, args, err := statement.ToSQL()\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Println(\"SQL:\", sql)\n    fmt.Println(\"Args:\", args)\n}\n</code></pre>"},{"location":"db/dbgrid/#custom-filter-functions","title":"Custom Filter Functions","text":"<p>You can add custom filter functions to transform filter values before they're used in queries:</p> <pre><code>// Add a filter function for a boolean field\ngrid.AddFilterFunc(\"active\", func(value any) (any, error) {\n    switch v := value.(type) {\n    case string:\n        switch v {\n        case \"1\", \"true\", \"yes\", \"y\", \"on\":\n            return true, nil\n        case \"0\", \"false\", \"no\", \"n\", \"off\":\n            return false, nil\n        default:\n            return nil, db.GridError{\n                Scope:   \"filter\",\n                Field:   \"active\",\n                Message: \"invalid boolean value\",\n            }\n        }\n    case bool:\n        return v, nil\n    case int:\n        return v != 0, nil\n    default:\n        return nil, db.GridError{\n            Scope:   \"filter\",\n            Field:   \"active\",\n            Message: \"type not supported\",\n        }\n    }\n})\n</code></pre>"},{"location":"db/dbgrid/#using-with-a-database","title":"Using with a Database","text":"<p>Here's how to use a Grid with a database connection:</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"github.com/oddbit-project/blueprint/db\"\n    \"github.com/oddbit-project/blueprint/provider/pgsql\"\n    \"log\"\n)\n\nfunc main() {\n    // Create the grid as shown in previous examples\n    grid, _ := db.NewGrid(\"users\", &amp;UserRecord{})\n    query, _ := db.NewGridQuery(db.SearchNone, 10, 0)\n\n    // Set up query parameters\n    query.SortFields = map[string]string{\n        \"username\": db.SortAscending,\n    }\n\n    // Build the query\n    statement, _ := grid.Build(nil, query)\n\n    // Connect to the database\n    pgConfig := pgsql.NewClientConfig()\n    pgConfig.DSN = \"postgres://username:password@localhost:5432/database?sslmode=allow\"\n\n    client, err := pgsql.NewClient(pgConfig)\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer client.Disconnect()\n\n    // Execute the query\n    sqlStr, args, _ := statement.ToSQL()\n    rows, err := client.Db().QueryxContext(context.Background(), sqlStr, args...)\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer rows.Close()\n\n    // Process the results\n    var users []UserRecord\n    for rows.Next() {\n        var user UserRecord\n        if err := rows.StructScan(&amp;user); err != nil {\n            log.Fatal(err)\n        }\n        users = append(users, user)\n    }\n\n    if err := rows.Err(); err != nil {\n        log.Fatal(err)\n    }\n\n    // Use the users slice\n}\n</code></pre>"},{"location":"db/dbgrid/#component-reference","title":"Component Reference","text":""},{"location":"db/dbgrid/#constants","title":"Constants","text":"<pre><code>// Sort direction constants\nSortAscending  = \"asc\"\nSortDescending = \"desc\"\n\n// Search type constants\nSearchNone  = 0  // No search\nSearchStart = 1  // Search for terms at the start (%term)\nSearchEnd   = 2  // Search for terms at the end (term%)\nSearchAny   = 3  // Search for terms anywhere (%term%)\n</code></pre>"},{"location":"db/dbgrid/#types","title":"Types","text":""},{"location":"db/dbgrid/#gridfilterfunc","title":"GridFilterFunc","text":"<pre><code>type GridFilterFunc func(lookupValue any) (any, error)\n</code></pre> <p>A function type for custom filtering operations that transform input values to database-compatible values.</p>"},{"location":"db/dbgrid/#grid","title":"Grid","text":"<pre><code>type Grid struct {\n    tableName  string\n    spec       *FieldSpec\n    filterFunc map[string]GridFilterFunc\n}\n</code></pre> <p>The main Grid component that handles query building and validation.</p>"},{"location":"db/dbgrid/#gridquery","title":"GridQuery","text":"<pre><code>type GridQuery struct {\n    SearchType   uint              `db:\"searchType\"`\n    SearchText   string            `json:\"searchText,omitempty\"`\n    FilterFields map[string]any    `json:\"filterFields,omitEmpty\"`\n    SortFields   map[string]string `json:\"sortFields,omitempty\"`\n    Offset       uint              `json:\"offset,omitempty\"`\n    Limit        uint              `json:\"limit,omitempty\"`\n}\n</code></pre> <p>Represents a query with search, filter, sort, and pagination options.</p>"},{"location":"db/dbgrid/#griderror","title":"GridError","text":"<pre><code>type GridError struct {\n    Scope   string `json:\"scope\"`\n    Field   string `json:\"field\"`\n    Message string `json:\"message\"`\n}\n</code></pre> <p>Error type that includes the scope and field where an error occurred.</p>"},{"location":"db/dbgrid/#functions","title":"Functions","text":""},{"location":"db/dbgrid/#newgridquery","title":"NewGridQuery","text":"<pre><code>func NewGridQuery(searchType uint, limit uint, offset uint) (GridQuery, error)\n</code></pre> <p>Creates a new GridQuery with the specified search type, limit, and offset.</p>"},{"location":"db/dbgrid/#newgrid","title":"NewGrid","text":"<pre><code>func NewGrid(tableName string, record any) (*Grid, error)\n</code></pre> <p>Creates a new Grid from a struct definition.</p>"},{"location":"db/dbgrid/#newgridwithspec","title":"NewGridWithSpec","text":"<pre><code>func NewGridWithSpec(tableName string, spec *FieldSpec) *Grid\n</code></pre> <p>Creates a new Grid from an existing FieldSpec.</p>"},{"location":"db/dbgrid/#grid-methods","title":"Grid Methods","text":""},{"location":"db/dbgrid/#addfilterfunc","title":"AddFilterFunc","text":"<pre><code>func (grid *Grid) AddFilterFunc(dbField string, f GridFilterFunc) *Grid\n</code></pre> <p>Adds a custom filter function for a specific field.</p>"},{"location":"db/dbgrid/#validquery","title":"ValidQuery","text":"<pre><code>func (grid *Grid) ValidQuery(query GridQuery) error\n</code></pre> <p>Validates a GridQuery against the grid's field specifications.</p>"},{"location":"db/dbgrid/#build","title":"Build","text":"<pre><code>func (grid *Grid) Build(qry *goqu.SelectDataset, args GridQuery) (*goqu.SelectDataset, error)\n</code></pre> <p>Builds a goqu SelectDataset from the grid query.</p>"},{"location":"db/dbgrid/#field-tags","title":"Field Tags","text":"<p>The Grid component uses the <code>grid</code> tag to determine the capabilities of each field:</p> <pre><code>type UserRecord struct {\n    ID        int    `db:\"id\" json:\"id\" grid:\"sort,filter\"`\n    Username  string `db:\"username\" json:\"username\" grid:\"sort,search,filter\"`\n    Email     string `db:\"email\" json:\"email\" grid:\"sort,search,filter\"`\n    Active    bool   `db:\"active\" json:\"active\" grid:\"filter\"`\n}\n</code></pre> <p>Available tag options: - <code>sort</code>: The field can be used for sorting - <code>search</code>: The field is included in text searches - <code>filter</code>: The field can be used in filters</p>"},{"location":"db/dbgrid/#query-building-process","title":"Query Building Process","text":"<ol> <li>Create a <code>Grid</code> from a struct</li> <li>Create a <code>GridQuery</code> with search type, limit, and offset</li> <li>Set the search text, filter fields, and sort fields in the GridQuery</li> <li>Validate the query using <code>grid.ValidQuery(query)</code></li> <li>Build the SQL query using <code>grid.Build(nil, query)</code></li> <li>Convert to SQL using <code>statement.ToSQL()</code></li> <li>Execute the query against a database</li> </ol>"},{"location":"db/dbgrid/#error-handling","title":"Error Handling","text":"<p>The Grid component returns well-defined errors with scope, field, and message information:</p> <pre><code>GridError{\n    Scope:   \"filter\",\n    Field:   \"active\",\n    Message: \"field is not filterable\",\n}\n</code></pre> <p>Common error scopes: - <code>filter</code>: Errors related to filter fields - <code>sort</code>: Errors related to sort fields - <code>search</code>: Errors related to search operations</p>"},{"location":"db/dbgrid/#examples","title":"Examples","text":""},{"location":"db/dbgrid/#filtering-records","title":"Filtering Records","text":"<pre><code>// Create a grid and query\ngrid, _ := db.NewGrid(\"users\", &amp;UserRecord{})\nquery, _ := db.NewGridQuery(db.SearchNone, 10, 0)\n\n// Set multiple filters\nquery.FilterFields = map[string]any{\n    \"active\": true,\n    \"id\": 100,\n}\n\n// Validate and build the query\ngrid.ValidQuery(query)\nstatement, _ := grid.Build(nil, query)\n\n// Get SQL\nsql, _, _ := statement.ToSQL()\n// SQL: SELECT * FROM \"users\" WHERE ((\"active\" IS TRUE) AND (\"id\" = 100)) LIMIT 10\n</code></pre>"},{"location":"db/dbgrid/#text-searching","title":"Text Searching","text":"<pre><code>// Create a grid and query\ngrid, _ := db.NewGrid(\"users\", &amp;UserRecord{})\nquery, _ := db.NewGridQuery(db.SearchAny, 10, 0)\n\n// Set search text\nquery.SearchText = \"john.doe\"\n\n// Validate and build the query\ngrid.ValidQuery(query)\nstatement, _ := grid.Build(nil, query)\n\n// Get SQL \nsql, _, _ := statement.ToSQL()\n// SQL: SELECT * FROM \"users\" WHERE ((\"username\" LIKE '%john.doe%') OR (\"email\" LIKE '%john.doe%')) LIMIT 10\n</code></pre>"},{"location":"db/dbgrid/#sorting-results","title":"Sorting Results","text":"<pre><code>// Create a grid and query\ngrid, _ := db.NewGrid(\"users\", &amp;UserRecord{})\nquery, _ := db.NewGridQuery(db.SearchNone, 10, 0)\n\n// Set multiple sort fields\nquery.SortFields = map[string]string{\n    \"username\": db.SortAscending,\n    \"id\": db.SortDescending,\n}\n\n// Validate and build the query\ngrid.ValidQuery(query)\nstatement, _ := grid.Build(nil, query)\n\n// Get SQL\nsql, _, _ := statement.ToSQL()\n// SQL: SELECT * FROM \"users\" ORDER BY \"username\" ASC, \"id\" DESC LIMIT 10\n</code></pre>"},{"location":"db/dbgrid/#pagination","title":"Pagination","text":"<pre><code>// Create a grid and query with offset and limit\ngrid, _ := db.NewGrid(\"users\", &amp;UserRecord{})\nquery, _ := db.NewGridQuery(db.SearchNone, 10, 20)  // Limit 10, offset 20\n\n// Validate and build the query\ngrid.ValidQuery(query)\nstatement, _ := grid.Build(nil, query)\n\n// Get SQL\nsql, _, _ := statement.ToSQL()\n// SQL: SELECT * FROM \"users\" LIMIT 10 OFFSET 20\n</code></pre>"},{"location":"db/dbgrid/#custom-selects","title":"Custom Selects","text":"<pre><code>// Create a grid and query\ngrid, _ := db.NewGrid(\"users\", &amp;UserRecord{})\nquery, _ := db.NewGridQuery(db.SearchNone, 0, 0)\n\n// Set a filter\nquery.FilterFields = map[string]any{\n    \"active\": true,\n}\n\n// Create a custom select\ncustomSelect := goqu.Select(goqu.COUNT(\"*\")).From(\"users\")\n\n// Build with the custom select\nstatement, _ := grid.Build(customSelect, query)\n\n// Get SQL\nsql, _, _ := statement.ToSQL()\n// SQL: SELECT COUNT(*) FROM \"users\" WHERE (\"active\" IS TRUE)\n</code></pre>"},{"location":"db/dbgrid/#repository-integration","title":"Repository Integration","text":"<p>The Grid component is integrated with the Repository through the GridOps interface:</p> <pre><code>type GridOps interface {\n    Grid(record any) (*Grid, error)\n    QueryGrid(record any, args GridQuery, dest any) error\n}\n</code></pre> <p>This integration provides a more convenient way to use Grid functionality:</p> <pre><code>// Create a repository\nrepo := db.NewRepository(context.Background(), client, \"users\")\n\n// Simple way to query with Grid functionality\nquery, _ := db.NewGridQuery(db.SearchAny, 10, 0)\nquery.SearchText = \"smith\"\nquery.FilterFields = map[string]any{\"active\": true}\nquery.SortFields = map[string]string{\"username\": db.SortAscending}\n\n// Execute the query directly\nvar users []*UserRecord\nerr := repo.QueryGrid(&amp;UserRecord{}, query, &amp;users)\n</code></pre> <p>Benefits of using the Repository's GridOps methods:</p> <ol> <li>Field Spec Caching - The Repository caches the FieldSpec created from your record type, improving performance for repeated grid operations</li> <li>Simplified API - The QueryGrid method combines Grid creation, query building, and execution in a single call</li> <li>Consistent Context - Uses the repository's context for query execution</li> <li>Integration with Transactions - Works seamlessly with the repository's transaction management</li> </ol> <p>For more detailed information on using Grid with Repository, see the Repository Documentation.</p>"},{"location":"db/dbgrid/#see-also","title":"See Also","text":"<ul> <li>Database Package Overview</li> <li>Structs and Tags</li> <li>Repository Documentation</li> <li>Field Specifications</li> <li>Query Builder Documentation</li> <li>Database Functions</li> <li>PostgreSQL Provider</li> <li>ClickHouse Provider</li> </ul>"},{"location":"db/fields/","title":"db.FieldSpec","text":"<p>Field specification component for mapping struct fields to database columns with extended functionality, used in the Grid component.</p>"},{"location":"db/fields/#overview","title":"Overview","text":"<p>The FieldSpec component provides a way to extract and map information from struct field tags to facilitate database operations. It's particularly useful for:</p> <ul> <li>Mapping struct fields to database columns</li> <li>Creating aliases for fields</li> <li>Defining which fields can be sorted, filtered, or searched</li> <li>Supporting Grid functionality for dynamic query building</li> </ul>"},{"location":"db/fields/#usage","title":"Usage","text":""},{"location":"db/fields/#basic-usage","title":"Basic Usage","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"github.com/oddbit-project/blueprint/db\"\n    \"log\"\n)\n\n// Define a struct with grid tags\ntype UserRecord struct {\n    ID        int    `db:\"id\" json:\"id\" grid:\"sort,filter\"`\n    Username  string `db:\"username\" json:\"username\" grid:\"sort,search,filter\"`\n    Email     string `db:\"email\" json:\"email\" grid:\"sort,search,filter\"`\n    Active    bool   `db:\"active\" json:\"active\" grid:\"filter\"`\n}\n\nfunc main() {\n    // Create a FieldSpec from the struct\n    spec, err := db.NewFieldSpec(&amp;UserRecord{})\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Use the spec to look up field information\n    dbField, exists := spec.LookupAlias(\"username\")\n    if exists {\n        fmt.Println(\"DB field for 'username':\", dbField)\n    }\n\n    // Get all sortable fields\n    sortFields := spec.SortFields()\n    fmt.Println(\"Sortable fields:\", sortFields)\n\n    // Get all searchable fields\n    searchFields := spec.SearchFields()\n    fmt.Println(\"Searchable fields:\", searchFields)\n\n    // Get all filterable fields\n    filterFields := spec.FilterFields()\n    fmt.Println(\"Filterable fields:\", filterFields)\n}\n</code></pre>"},{"location":"db/fields/#manual-field-specification","title":"Manual Field Specification","text":"<p>You can also create an empty FieldSpec and add fields manually:</p> <pre><code>// Create an empty spec\nspec := db.NewEmptyFieldSpec()\n\n// Add fields with their properties\nspec.AddField(\"id\", \"ID\", false, true, true)           // id -&gt; ID (sortable, filterable)\nspec.AddField(\"username\", \"Username\", true, true, true) // username -&gt; Username (searchable, sortable, filterable)\nspec.AddField(\"email\", \"Email\", true, false, true)      // email -&gt; Email (searchable, filterable)\nspec.AddField(\"status\", \"Status\", false, false, true)   // status -&gt; Status (filterable only)\n\n// Use the spec as needed\n</code></pre>"},{"location":"db/fields/#component-reference","title":"Component Reference","text":""},{"location":"db/fields/#constants-and-error-types","title":"Constants and Error Types","text":"<pre><code>// Error constants\nErrDuplicatedAlias  = utils.Error(\"alias already exists\")\nErrDuplicatedField  = utils.Error(\"field already exists\")\nErrInvalidStructPtr = utils.Error(\"field spec requires a pointer to a struct\")\nErrNilPointer       = utils.Error(\"ptr to struct to be parsed by field spec is nil\")\nErrInvalidStruct    = utils.Error(\"field spec requires a pointer to a struct; invalid type\")\n\n// Tag constants\ntagGrid   = \"grid\"\noptSort   = \"sort\"\noptSearch = \"search\"\noptFilter = \"filter\"\n</code></pre>"},{"location":"db/fields/#types","title":"Types","text":""},{"location":"db/fields/#fieldspec","title":"FieldSpec","text":"<pre><code>type FieldSpec struct {\n    fieldAlias   map[string]string // maps db fields to alias\n    aliasField   map[string]string // maps alias to db fields\n    sortFields   []string          // sortable db fields\n    filterFields []string          // filterable db fields\n    searchFields []string          // searchable db fields\n}\n</code></pre> <p>The main FieldSpec component that handles field mapping and property management.</p>"},{"location":"db/fields/#functions","title":"Functions","text":""},{"location":"db/fields/#newfieldspec","title":"NewFieldSpec","text":"<pre><code>func NewFieldSpec(from any) (*FieldSpec, error)\n</code></pre> <p>Creates a new FieldSpec from a struct, scanning its field tags to populate the maps and lists.</p>"},{"location":"db/fields/#newemptyfieldspec","title":"NewEmptyFieldSpec","text":"<pre><code>func NewEmptyFieldSpec() *FieldSpec\n</code></pre> <p>Creates a new empty FieldSpec with initialized maps and lists.</p>"},{"location":"db/fields/#fieldspec-methods","title":"FieldSpec Methods","text":""},{"location":"db/fields/#addfield","title":"AddField","text":"<pre><code>func (f *FieldSpec) AddField(dbField, alias string, searchable bool, sortable bool, filterable bool) error\n</code></pre> <p>Adds a field to the specification with its properties.</p>"},{"location":"db/fields/#lookupalias","title":"LookupAlias","text":"<pre><code>func (f *FieldSpec) LookupAlias(alias string) (string, bool)\n</code></pre> <p>Looks up an alias and returns the corresponding database field name.</p>"},{"location":"db/fields/#fieldaliasmap","title":"FieldAliasMap","text":"<pre><code>func (f *FieldSpec) FieldAliasMap() map[string]string\n</code></pre> <p>Returns a copy of the map that maps database fields to aliases.</p>"},{"location":"db/fields/#filterfields","title":"FilterFields","text":"<pre><code>func (f *FieldSpec) FilterFields() []string\n</code></pre> <p>Returns the list of filterable database fields.</p>"},{"location":"db/fields/#sortfields","title":"SortFields","text":"<pre><code>func (f *FieldSpec) SortFields() []string\n</code></pre> <p>Returns the list of sortable database fields.</p>"},{"location":"db/fields/#searchfields","title":"SearchFields","text":"<pre><code>func (f *FieldSpec) SearchFields() []string\n</code></pre> <p>Returns the list of searchable database fields.</p>"},{"location":"db/fields/#struct-tags","title":"Struct Tags","text":"<p>The FieldSpec component processes several struct tags:</p>"},{"location":"db/fields/#database-field-tags","title":"Database Field Tags","text":"<ul> <li><code>db</code>: Standard database field tag (primary)</li> <li><code>ch</code>: Alternative database field tag (for ClickHouse)</li> </ul>"},{"location":"db/fields/#alias-tags","title":"Alias Tags","text":"<ul> <li><code>json</code>: Used as alias if available</li> <li><code>alias</code>: Explicitly defined alias</li> </ul>"},{"location":"db/fields/#grid-tags","title":"Grid Tags","text":"<p>The <code>grid</code> tag can contain comma-separated options: - <code>sort</code>: Field can be used for sorting - <code>search</code>: Field is included in text searches - <code>filter</code>: Field can be used in filters</p> <p>Example: <pre><code>type User struct {\n    ID      int    `db:\"id\" json:\"id\" grid:\"sort,filter\"`\n    Name    string `db:\"name\" json:\"name\" grid:\"sort,search,filter\"`\n    Email   string `db:\"email\" json:\"email\" grid:\"search,filter\"`\n    IsAdmin bool   `db:\"is_admin\" json:\"isAdmin\" grid:\"filter\"`\n}\n</code></pre></p>"},{"location":"db/fields/#field-processing-rules","title":"Field Processing Rules","text":"<ol> <li>Database field name comes from the <code>db</code> or <code>ch</code> tag, falling back to the struct field name</li> <li>Alias comes from the <code>alias</code> or <code>json</code> tag, falling back to the struct field name</li> <li>Options (searchable, sortable, filterable) come from the <code>grid</code> tag</li> <li>Fields marked with <code>db:\"-\"</code> are ignored</li> <li>Unexported fields are ignored</li> <li>Embedded structs are processed recursively, including their fields in the spec</li> <li>Embedded pointer-to-struct fields are skipped</li> </ol>"},{"location":"db/fields/#field-mapping-process","title":"Field Mapping Process","text":"<ol> <li>Create a new FieldSpec with <code>NewFieldSpec(&amp;MyStruct{})</code></li> <li>FieldSpec scans all fields in the struct and processes their tags</li> <li>For each field:</li> <li>Extract the database field name from db tags</li> <li>Extract the alias from json/alias tags</li> <li>Extract grid options from grid tags</li> <li>Add the field to the appropriate maps and lists</li> <li>If a field is an embedded struct, recursively process its fields</li> <li>Validation ensures no duplicate fields or aliases</li> </ol>"},{"location":"db/fields/#examples","title":"Examples","text":""},{"location":"db/fields/#processing-struct-with-embedded-fields","title":"Processing Struct with Embedded Fields","text":"<pre><code>type BaseRecord struct {\n    ID        int       `db:\"id\" json:\"id\" grid:\"sort,filter\"`\n    CreatedAt time.Time `db:\"created_at\" json:\"createdAt\" grid:\"sort\"`\n    UpdatedAt time.Time `db:\"updated_at\" json:\"updatedAt\" grid:\"sort\"`\n}\n\ntype UserRecord struct {\n    BaseRecord         // Embedded struct - fields will be included\n    Username  string   `db:\"username\" json:\"username\" grid:\"sort,search,filter\"`\n    Email     string   `db:\"email\" json:\"email\" grid:\"sort,search,filter\"`\n}\n\n// Create a FieldSpec from the struct\nspec, _ := db.NewFieldSpec(&amp;UserRecord{})\n\n// All fields from both structs are included\nfmt.Println(spec.SortFields()) \n// Output: [id created_at updated_at username email]\n\nfmt.Println(spec.SearchFields())\n// Output: [username email]\n</code></pre>"},{"location":"db/fields/#custom-field-mapping","title":"Custom Field Mapping","text":"<pre><code>// Create an empty spec\nspec := db.NewEmptyFieldSpec()\n\n// Add fields with aliases different from DB names\nspec.AddField(\"u_id\", \"userId\", false, true, true)\nspec.AddField(\"u_name\", \"userName\", true, true, true)\nspec.AddField(\"u_email\", \"userEmail\", true, false, true)\n\n// Look up using aliases\ndbField, _ := spec.LookupAlias(\"userName\")\nfmt.Println(dbField) // Output: u_name\n\n// Get the full mapping\nmapping := spec.FieldAliasMap()\nfmt.Println(mapping) // Output: map[u_id:userId u_name:userName u_email:userEmail]\n</code></pre>"},{"location":"db/fields/#see-also","title":"See Also","text":"<ul> <li>Database Package Overview</li> <li>Structs and Tags</li> <li>Repository Documentation</li> <li>Data Grid Documentation</li> <li>Query Builder Documentation</li> <li>Database Functions</li> <li>Client Interface</li> </ul>"},{"location":"db/functions/","title":"Database Functions","text":"<p>The database functions module provides low-level database operations and utilities for advanced use cases. These functions offer direct SQL execution capabilities with intelligent result scanning and type detection.</p>"},{"location":"db/functions/#overview","title":"Overview","text":"<p>The functions module includes:</p> <ul> <li>Raw SQL execution functions</li> <li>Intelligent result scanning utilities</li> <li>Type detection and conversion helpers</li> <li>Context-aware database operations</li> <li>Error handling utilities</li> </ul> <p>These functions are used internally by the Repository but are also available for direct use when you need more control over SQL operations.</p>"},{"location":"db/functions/#raw-execution-functions","title":"Raw Execution Functions","text":""},{"location":"db/functions/#rawexec","title":"RawExec","text":"<pre><code>func RawExec(ctx context.Context, conn sqlx.ExecerContext, sql string, args ...any) error\n</code></pre> <p>Executes a raw SQL statement that doesn't return rows (INSERT, UPDATE, DELETE, DDL).</p> <p>Example: <pre><code>package main\n\nimport (\n    \"context\"\n    \"github.com/oddbit-project/blueprint/db\"\n    \"github.com/oddbit-project/blueprint/provider/pgsql\"\n    \"log\"\n)\n\nfunc main() {\n    // Setup client\n    config := pgsql.NewClientConfig()\n    config.DSN = \"postgres://user:pass@localhost/dbname?sslmode=disable\"\n\n    client, err := pgsql.NewClient(config)\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer client.Disconnect()\n\n    ctx := context.Background()\n\n    // Create table\n    createSQL := `\n        CREATE TABLE IF NOT EXISTS users (\n            id SERIAL PRIMARY KEY,\n            name VARCHAR(100) NOT NULL,\n            email VARCHAR(100) UNIQUE NOT NULL,\n            created_at TIMESTAMP DEFAULT NOW()\n        )`\n\n    if err := db.RawExec(ctx, client.GetClient(), createSQL); err != nil {\n        log.Fatal(\"Failed to create table:\", err)\n    }\n\n    // Insert data\n    insertSQL := \"INSERT INTO users (name, email) VALUES ($1, $2)\"\n    if err := db.RawExec(ctx, client.GetClient(), insertSQL, \"John Doe\", \"john@example.com\"); err != nil {\n        log.Fatal(\"Failed to insert user:\", err)\n    }\n}\n</code></pre></p>"},{"location":"db/functions/#rawinsert","title":"RawInsert","text":"<pre><code>func RawInsert(ctx context.Context, conn sqlx.ExecerContext, qry string, values []any) error\n</code></pre> <p>Executes a raw INSERT statement with a slice of values.</p> <p>Example: <pre><code>func batchInsertUsers(ctx context.Context, client db.Client, users []User) error {\n    sql := \"INSERT INTO users (name, email) VALUES \"\n    var values []any\n    var placeholders []string\n\n    for i, user := range users {\n        placeholders = append(placeholders, fmt.Sprintf(\"($%d, $%d)\", i*2+1, i*2+2))\n        values = append(values, user.Name, user.Email)\n    }\n\n    sql += strings.Join(placeholders, \", \")\n    return db.RawInsert(ctx, client.GetClient(), sql, values)\n}\n</code></pre></p>"},{"location":"db/functions/#query-and-fetch-functions","title":"Query and Fetch Functions","text":""},{"location":"db/functions/#fetchone","title":"FetchOne","text":"<pre><code>func FetchOne(ctx context.Context, conn sqlx.QueryerContext, qry *goqu.SelectDataset, target any) error\n</code></pre> <p>Fetches a single record using a goqu SelectDataset. The target must be a struct pointer.</p> <p>Example: <pre><code>package main\n\nimport (\n    \"context\"\n    \"github.com/doug-martin/goqu/v9\"\n    \"github.com/oddbit-project/blueprint/db\"\n    \"log\"\n)\n\ntype User struct {\n    ID    int    `db:\"id\"`\n    Name  string `db:\"name\"`\n    Email string `db:\"email\"`\n}\n\nfunc getUserByID(ctx context.Context, client db.Client, userID int) (*User, error) {\n    dialect := goqu.Dialect(\"postgres\")\n    query := dialect.From(\"users\").Where(goqu.C(\"id\").Eq(userID))\n\n    user := &amp;User{}\n    err := db.FetchOne(ctx, client.GetClient(), query, user)\n    if err != nil {\n        return nil, err\n    }\n\n    return user, nil\n}\n</code></pre></p>"},{"location":"db/functions/#fetch","title":"Fetch","text":"<pre><code>func Fetch(ctx context.Context, conn SqlxReaderCtx, qry *goqu.SelectDataset, target any) error\n</code></pre> <p>Fetches multiple records using a goqu SelectDataset. The target must be a slice pointer.</p> <p>Example: <pre><code>func getActiveUsers(ctx context.Context, client db.Client) ([]*User, error) {\n    dialect := goqu.Dialect(\"postgres\")\n    query := dialect.From(\"users\").Where(goqu.C(\"active\").IsTrue())\n\n    var users []*User\n    err := db.Fetch(ctx, client.GetClient(), query, &amp;users)\n    if err != nil {\n        return nil, err\n    }\n\n    return users, nil\n}\n</code></pre></p>"},{"location":"db/functions/#fetchrecord","title":"FetchRecord","text":"<pre><code>func FetchRecord(ctx context.Context, conn sqlx.QueryerContext, qry *goqu.SelectDataset, fieldValues map[string]any, target any) error\n</code></pre> <p>Fetches a single record with WHERE clauses built from a field values map.</p> <p>Example: <pre><code>func getUserByEmail(ctx context.Context, client db.Client, email string) (*User, error) {\n    dialect := goqu.Dialect(\"postgres\")\n    query := dialect.From(\"users\")\n\n    fieldValues := map[string]any{\n        \"email\": email,\n        \"active\": true,\n    }\n\n    user := &amp;User{}\n    err := db.FetchRecord(ctx, client.GetClient(), query, fieldValues, user)\n    if err != nil {\n        return nil, err\n    }\n\n    return user, nil\n}\n</code></pre></p>"},{"location":"db/functions/#fetchbykey","title":"FetchByKey","text":"<pre><code>func FetchByKey(ctx context.Context, conn sqlx.QueryerContext, qry *goqu.SelectDataset, keyField string, value any, target any) error\n</code></pre> <p>Fetches a single record by a specific key field.</p> <p>Example: <pre><code>func getUserByID(ctx context.Context, client db.Client, id int) (*User, error) {\n    dialect := goqu.Dialect(\"postgres\")\n    query := dialect.From(\"users\")\n\n    user := &amp;User{}\n    err := db.FetchByKey(ctx, client.GetClient(), query, \"id\", id, user)\n    if err != nil {\n        return nil, err\n    }\n\n    return user, nil\n}\n</code></pre></p>"},{"location":"db/functions/#fetchwhere","title":"FetchWhere","text":"<pre><code>func FetchWhere(ctx context.Context, conn SqlxReaderCtx, qry *goqu.SelectDataset, fieldValues map[string]any, target any) error\n</code></pre> <p>Fetches multiple records with WHERE clauses from field values map.</p> <p>Example: <pre><code>func getUsersByStatus(ctx context.Context, client db.Client, active bool, role string) ([]*User, error) {\n    dialect := goqu.Dialect(\"postgres\")\n    query := dialect.From(\"users\")\n\n    fieldValues := map[string]any{\n        \"active\": active,\n        \"role\":   role,\n    }\n\n    var users []*User\n    err := db.FetchWhere(ctx, client.GetClient(), query, fieldValues, &amp;users)\n    if err != nil {\n        return nil, err\n    }\n\n    return users, nil\n}\n</code></pre></p>"},{"location":"db/functions/#utility-functions","title":"Utility Functions","text":""},{"location":"db/functions/#exists","title":"Exists","text":"<pre><code>func Exists(ctx context.Context, conn sqlx.QueryerContext, qry *goqu.SelectDataset, fieldName string, fieldValue any, skip ...any) (bool, error)\n</code></pre> <p>Checks if records exist matching the given criteria. The optional skip parameter allows excluding specific records.</p> <p>Example: <pre><code>func emailExists(ctx context.Context, client db.Client, email string, excludeID ...int) (bool, error) {\n    dialect := goqu.Dialect(\"postgres\")\n    query := dialect.From(\"users\")\n\n    var skip []any\n    if len(excludeID) &gt; 0 {\n        skip = []any{\"id\", excludeID[0]}\n    }\n\n    return db.Exists(ctx, client.GetClient(), query, \"email\", email, skip...)\n}\n\nfunc main() {\n    // Check if email exists\n    exists, err := emailExists(ctx, client, \"john@example.com\")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    if exists {\n        log.Println(\"Email already exists\")\n    }\n\n    // Check if email exists, excluding specific user ID\n    exists, err = emailExists(ctx, client, \"john@example.com\", 123)\n    if err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre></p>"},{"location":"db/functions/#count","title":"Count","text":"<pre><code>func Count(ctx context.Context, conn sqlx.QueryerContext, qry *goqu.SelectDataset) (int64, error)\n</code></pre> <p>Executes a COUNT query and returns the result.</p> <p>Example: <pre><code>func countActiveUsers(ctx context.Context, client db.Client) (int64, error) {\n    dialect := goqu.Dialect(\"postgres\")\n    query := dialect.From(\"users\").\n        Select(goqu.L(\"COUNT(*)\")).\n        Where(goqu.C(\"active\").IsTrue())\n\n    return db.Count(ctx, client.GetClient(), query)\n}\n</code></pre></p>"},{"location":"db/functions/#delete-functions","title":"Delete Functions","text":""},{"location":"db/functions/#delete","title":"Delete","text":"<pre><code>func Delete(ctx context.Context, conn sqlx.ExecerContext, qry *goqu.DeleteDataset) error\n</code></pre> <p>Executes a DELETE query using a goqu DeleteDataset.</p> <p>Example: <pre><code>func deleteInactiveUsers(ctx context.Context, client db.Client, daysInactive int) error {\n    dialect := goqu.Dialect(\"postgres\")\n    cutoff := time.Now().AddDate(0, 0, -daysInactive)\n\n    query := dialect.Delete(\"users\").\n        Where(goqu.C(\"last_login\").Lt(cutoff)).\n        Where(goqu.C(\"active\").IsFalse())\n\n    return db.Delete(ctx, client.GetClient(), query)\n}\n</code></pre></p>"},{"location":"db/functions/#deletewhere","title":"DeleteWhere","text":"<pre><code>func DeleteWhere(ctx context.Context, conn sqlx.ExecerContext, qry *goqu.DeleteDataset, fieldNameValue map[string]any) error\n</code></pre> <p>Deletes records matching field values.</p> <p>Example: <pre><code>func deleteUsersByRole(ctx context.Context, client db.Client, role string) error {\n    dialect := goqu.Dialect(\"postgres\")\n    query := dialect.Delete(\"users\")\n\n    fieldValues := map[string]any{\n        \"role\":   role,\n        \"active\": false,\n    }\n\n    return db.DeleteWhere(ctx, client.GetClient(), query, fieldValues)\n}\n</code></pre></p>"},{"location":"db/functions/#deletebykey","title":"DeleteByKey","text":"<pre><code>func DeleteByKey(ctx context.Context, conn sqlx.ExecerContext, qry *goqu.DeleteDataset, keyField string, value any) error\n</code></pre> <p>Deletes a record by key field.</p> <p>Example: <pre><code>func deleteUserByID(ctx context.Context, client db.Client, userID int) error {\n    dialect := goqu.Dialect(\"postgres\")\n    query := dialect.Delete(\"users\")\n\n    return db.DeleteByKey(ctx, client.GetClient(), query, \"id\", userID)\n}\n</code></pre></p>"},{"location":"db/functions/#returning-clause-support","title":"RETURNING Clause Support","text":""},{"location":"db/functions/#rawinsertreturning","title":"RawInsertReturning","text":"<pre><code>func RawInsertReturning(ctx context.Context, conn sqlx.QueryerContext, qry string, values []any, target ...any) error\n</code></pre> <p>Executes an INSERT with RETURNING clause for positional scanning.</p> <p>Example: <pre><code>func insertUserReturning(ctx context.Context, client db.Client, name, email string) (int, error) {\n    sql := \"INSERT INTO users (name, email) VALUES ($1, $2) RETURNING id\"\n    values := []any{name, email}\n\n    var id int\n    err := db.RawInsertReturning(ctx, client.GetClient(), sql, values, &amp;id)\n    if err != nil {\n        return 0, err\n    }\n\n    return id, nil\n}\n</code></pre></p>"},{"location":"db/functions/#rawinsertreturningflexible","title":"RawInsertReturningFlexible","text":"<pre><code>func RawInsertReturningFlexible(ctx context.Context, conn sqlx.QueryerContext, sql string, args []any, target any) error\n</code></pre> <p>Executes INSERT with RETURNING clause using intelligent type detection for scanning.</p> <p>Example: <pre><code>func insertUserReturningStruct(ctx context.Context, client db.Client, user *User) error {\n    sql := `INSERT INTO users (name, email) VALUES ($1, $2) \n            RETURNING id, name, email, created_at`\n    args := []any{user.Name, user.Email}\n\n    // Scan directly into struct - fields are mapped by name/tag\n    return db.RawInsertReturningFlexible(ctx, client.GetClient(), sql, args, user)\n}\n\nfunc insertUserReturningFields(ctx context.Context, client db.Client, name, email string) (int, string, time.Time, error) {\n    sql := `INSERT INTO users (name, email) VALUES ($1, $2) \n            RETURNING id, name, created_at`\n    args := []any{name, email}\n\n    var id int\n    var returnedName string\n    var createdAt time.Time\n\n    // Scan into multiple variables positionally\n    targets := []any{&amp;id, &amp;returnedName, &amp;createdAt}\n    err := db.RawInsertReturningFlexible(ctx, client.GetClient(), sql, args, targets)\n\n    return id, returnedName, createdAt, err\n}\n</code></pre></p>"},{"location":"db/functions/#update-functions","title":"Update Functions","text":""},{"location":"db/functions/#update","title":"Update","text":"<pre><code>func Update(ctx context.Context, conn sqlx.ExecerContext, qry *goqu.UpdateDataset) error\n</code></pre> <p>Executes an UPDATE query using goqu UpdateDataset.</p> <p>Example: <pre><code>func updateUserEmail(ctx context.Context, client db.Client, userID int, newEmail string) error {\n    dialect := goqu.Dialect(\"postgres\")\n    query := dialect.Update(\"users\").\n        Set(goqu.Record{\"email\": newEmail, \"updated_at\": time.Now()}).\n        Where(goqu.C(\"id\").Eq(userID))\n\n    return db.Update(ctx, client.GetClient(), query)\n}\n</code></pre></p>"},{"location":"db/functions/#rawupdatereturningflexible","title":"RawUpdateReturningFlexible","text":"<pre><code>func RawUpdateReturningFlexible(ctx context.Context, conn sqlx.QueryerContext, sql string, args []any, target any) error\n</code></pre> <p>Executes UPDATE with RETURNING clause using intelligent scanning.</p> <p>Example: <pre><code>func updateUserReturning(ctx context.Context, client db.Client, userID int, name string) (*User, error) {\n    sql := `UPDATE users SET name = $1, updated_at = NOW() \n            WHERE id = $2 \n            RETURNING id, name, email, updated_at`\n    args := []any{name, userID}\n\n    user := &amp;User{}\n    err := db.RawUpdateReturningFlexible(ctx, client.GetClient(), sql, args, user)\n    if err != nil {\n        return nil, err\n    }\n\n    return user, nil\n}\n</code></pre></p>"},{"location":"db/functions/#type-detection-and-scanning","title":"Type Detection and Scanning","text":"<p>The scanning functions use intelligent type detection to handle different target types:</p>"},{"location":"db/functions/#struct-scanning","title":"Struct Scanning","text":"<p>When the target is a struct pointer, fields are mapped by name or struct tags:</p> <pre><code>type User struct {\n    ID    int    `db:\"id\"`\n    Name  string `db:\"name\"`\n    Email string `db:\"email\"`\n}\n\nuser := &amp;User{}\n// Automatically maps database columns to struct fields\nerr := db.RawInsertReturningFlexible(ctx, conn, sql, args, user)\n</code></pre>"},{"location":"db/functions/#positional-scanning","title":"Positional Scanning","text":"<p>When the target is a slice of interfaces, values are scanned positionally:</p> <pre><code>targets := []any{&amp;id, &amp;name, &amp;email}\nerr := db.RawInsertReturningFlexible(ctx, conn, sql, args, targets)\n</code></pre>"},{"location":"db/functions/#single-value-scanning","title":"Single Value Scanning","text":"<p>When the target is a single variable pointer:</p> <pre><code>var id int\nerr := db.RawInsertReturningFlexible(ctx, conn, sql, args, &amp;id)\n</code></pre>"},{"location":"db/functions/#error-handling","title":"Error Handling","text":""},{"location":"db/functions/#emptyresult","title":"EmptyResult","text":"<pre><code>func EmptyResult(err error) bool\n</code></pre> <p>Checks if an error indicates no rows were found.</p> <p>Example: <pre><code>func getUserSafely(ctx context.Context, client db.Client, userID int) (*User, error) {\n    user := &amp;User{}\n    err := db.FetchByKey(ctx, client.GetClient(), query, \"id\", userID, user)\n\n    if err != nil {\n        if db.EmptyResult(err) {\n            return nil, nil // User not found, not an error\n        }\n        return nil, err // Real error\n    }\n\n    return user, nil\n}\n</code></pre></p>"},{"location":"db/functions/#helper-functions","title":"Helper Functions","text":""},{"location":"db/functions/#toanyslice","title":"ToAnySlice","text":"<pre><code>func ToAnySlice[T any](in []T) []any\n</code></pre> <p>Converts a typed slice to a slice of any, useful for batch operations with Repository.Insert().</p> <p>Example: <pre><code>// Convert typed slice to []any for batch insert\nusers := []*User{\n    {Name: \"Alice\", Email: \"alice@example.com\"},\n    {Name: \"Bob\", Email: \"bob@example.com\"},\n    {Name: \"Charlie\", Email: \"charlie@example.com\"},\n}\n\n// Convert and insert\nrecords := db.ToAnySlice(users)\nerr := repo.Insert(records...)\n\n// Or in one line\nerr := repo.Insert(db.ToAnySlice(users)...)\n</code></pre></p> <p>Use Cases: - Batch insert operations with Repository - Converting typed slices for variadic functions - Working with strongly-typed data that needs []any interface</p>"},{"location":"db/functions/#advanced-usage-patterns","title":"Advanced Usage Patterns","text":""},{"location":"db/functions/#transaction-support","title":"Transaction Support","text":"<p>All functions work with both regular connections and transactions:</p> <pre><code>func transferFunds(ctx context.Context, client db.Client, fromID, toID int, amount decimal.Decimal) error {\n    tx, err := client.GetClient().BeginTxx(ctx, nil)\n    if err != nil {\n        return err\n    }\n    defer tx.Rollback()\n\n    // Debit from account\n    debitSQL := \"UPDATE accounts SET balance = balance - $1 WHERE id = $2\"\n    if err := db.RawExec(ctx, tx, debitSQL, amount, fromID); err != nil {\n        return err\n    }\n\n    // Credit to account\n    creditSQL := \"UPDATE accounts SET balance = balance + $1 WHERE id = $2\"\n    if err := db.RawExec(ctx, tx, creditSQL, amount, toID); err != nil {\n        return err\n    }\n\n    return tx.Commit()\n}\n</code></pre>"},{"location":"db/functions/#batch-operations","title":"Batch Operations","text":"<pre><code>func batchUpdateUsers(ctx context.Context, client db.Client, updates []UserUpdate) error {\n    tx, err := client.GetClient().BeginTxx(ctx, nil)\n    if err != nil {\n        return err\n    }\n    defer tx.Rollback()\n\n    updateSQL := \"UPDATE users SET name = $1, email = $2 WHERE id = $3\"\n\n    for _, update := range updates {\n        if err := db.RawExec(ctx, tx, updateSQL, update.Name, update.Email, update.ID); err != nil {\n            return fmt.Errorf(\"failed to update user %d: %w\", update.ID, err)\n        }\n    }\n\n    return tx.Commit()\n}\n</code></pre>"},{"location":"db/functions/#performance-considerations","title":"Performance Considerations","text":""},{"location":"db/functions/#connection-reuse","title":"Connection Reuse","text":"<ul> <li>Functions accept connection interfaces, allowing reuse across operations</li> <li>Use transactions for multiple related operations</li> <li>Avoid creating new connections for each operation</li> </ul>"},{"location":"db/functions/#context-usage","title":"Context Usage","text":"<ul> <li>Always pass contexts for proper cancellation and timeout handling</li> <li>Use context.WithTimeout() for operations with time limits</li> <li>Respect context cancellation in loops and batch operations</li> </ul>"},{"location":"db/functions/#error-handling_1","title":"Error Handling","text":"<ul> <li>Check for specific error types (EmptyResult, constraint violations)</li> <li>Use appropriate error handling for your use case</li> <li>Log errors with sufficient context for debugging</li> </ul>"},{"location":"db/functions/#best-practices","title":"Best Practices","text":"<ol> <li>Use Contexts: Always pass contexts for cancellation and timeout support</li> <li>Handle Empty Results: Use EmptyResult() to distinguish between no data and errors</li> <li>Use Transactions: Group related operations in transactions for consistency</li> <li>Type Safety: Use struct scanning when possible for better type safety</li> <li>Error Context: Provide meaningful error context in your functions</li> <li>Resource Cleanup: Ensure rows are closed and connections are managed properly</li> </ol>"},{"location":"db/functions/#see-also","title":"See Also","text":"<ul> <li>Repository Documentation</li> <li>Query Builder Documentation</li> <li>Client Documentation</li> <li>Database Package Overview</li> </ul>"},{"location":"db/migrations/","title":"Database Migrations","text":"<p>The migrations package provides a simple database schema migration system with progress tracking and error handling.  It supports both file-based and embedded migrations with SHA2-based change detection.</p> <p>Note: the migration manager is forward-only; to revert the operations of a given migration, a new migration must be created. Rollback of schema changes is a destructive operation, and by itself a mutation on the current database state; as such, the concept of \"rolling back schema changes\" is deeply flawed and may result in data loss.</p>"},{"location":"db/migrations/#overview","title":"Overview","text":"<p>The migration system includes:</p> <ul> <li>Interface-based migration sources (disk, embedded, memory)</li> <li>Module support</li> <li>Migration execution with progress callbacks</li> <li>SHA2-based change detection and validation</li> <li>Rollback protection through tracking</li> <li>Flexible migration record management</li> <li>Provider-agnostic implementation</li> </ul>"},{"location":"db/migrations/#limitations","title":"Limitations","text":"<ul> <li>The ClickHouse implementation supports only one statement per file, due to ClickHouse limitations;</li> </ul>"},{"location":"db/migrations/#core-interfaces","title":"Core Interfaces","text":""},{"location":"db/migrations/#manager-interface","title":"Manager Interface","text":"<pre><code>type Manager interface {\n    List(ctx context.Context) ([]MigrationRecord, error)\n    MigrationExists(ctx context.Context, name string, sha2 string) (bool, error)\n    RunMigration(ctx context.Context, m *MigrationRecord) error\n    RegisterMigration(ctx context.Context, m *MigrationRecord) error\n    Run(ctx context.Context, src Source, consoleFn ProgressFn) error\n}\n</code></pre> <p>The Manager interface handles migration execution and tracking:</p> <ul> <li>List(): Returns all executed migrations</li> <li>MigrationExists(): Checks if a migration has been executed</li> <li>RunMigration(): Executes a single migration</li> <li>RegisterMigration(): Records a migration as executed</li> <li>Run(): Executes all pending migrations from a source</li> </ul>"},{"location":"db/migrations/#source-interface","title":"Source Interface","text":"<pre><code>type Source interface {\n    List() ([]string, error)\n    Read(name string) (*MigrationRecord, error)\n}\n</code></pre> <p>The Source interface abstracts migration storage:</p> <ul> <li>List(): Returns available migration names</li> <li>Read(): Reads a specific migration</li> </ul>"},{"location":"db/migrations/#migrationrecord","title":"MigrationRecord","text":"<pre><code>type MigrationRecord struct {\n    Created  time.Time `db:\"created\" ch:\"created\"`\n    Module   string    `db:\"module\" ch:\"module\"`\n    Name     string    `db:\"name\" ch:\"name\"`\n    SHA2     string    `db:\"sha2\" ch:\"sha2\"`\n    Contents string    `db:\"contents\" ch:\"contents\"`\n}\n</code></pre> <p>Represents a migration with metadata:</p> <ul> <li>Created: When the migration was executed</li> <li>Module: The module name (defaults to base)</li> <li>Name: Migration identifier</li> <li>SHA2: Content hash for change detection</li> <li>Contents: The actual migration SQL</li> </ul>"},{"location":"db/migrations/#source-implementations","title":"Source Implementations","text":""},{"location":"db/migrations/#disk-source","title":"Disk Source","text":"<p>Reads migrations from filesystem directories:</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"github.com/oddbit-project/blueprint/db/migrations\"\n    \"log\"\n)\n\nfunc runDiskMigrations(manager migrations.Manager) error {\n    // Create disk source pointing to migrations directory\n    source := migrations.NewDiskSource(\"./migrations\")\n\n    // Run all pending migrations\n    return manager.Run(context.Background(), source, migrations.DefaultProgressFn)\n}\n</code></pre> <p>Directory Structure: <pre><code>migrations/\n\u251c\u2500\u2500 001_create_users.sql\n\u251c\u2500\u2500 002_add_email_index.sql\n\u251c\u2500\u2500 003_create_orders.sql\n\u2514\u2500\u2500 004_add_foreign_keys.sql\n</code></pre></p>"},{"location":"db/migrations/#embedded-source","title":"Embedded Source","text":"<p>Uses Go's embed package for compiled-in migrations:</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"embed\"\n    \"github.com/oddbit-project/blueprint/db/migrations\"\n    \"log\"\n)\n\n//go:embed migrations/*.sql\nvar migrationFiles embed.FS\n\nfunc runEmbeddedMigrations(manager migrations.Manager) error {\n    // Create embedded source from embedded filesystem\n    source := migrations.NewEmbedSource(migrationFiles, \"migrations\")\n\n    // Run all pending migrations\n    return manager.Run(context.Background(), source, migrations.DefaultProgressFn)\n}\n</code></pre>"},{"location":"db/migrations/#memory-source","title":"Memory Source","text":"<p>In-memory migrations for testing or dynamic generation:</p> <pre><code>func runMemoryMigrations(manager migrations.Manager) error {\n    source := migrations.NewMemorySource()\n\n    // Add migrations programmatically\n    source.AddMigration(\"001_create_users\", `\n        CREATE TABLE users (\n            id SERIAL PRIMARY KEY,\n            name VARCHAR(100) NOT NULL,\n            email VARCHAR(100) UNIQUE NOT NULL,\n            created_at TIMESTAMP DEFAULT NOW()\n        );\n    `)\n\n    source.AddMigration(\"002_add_index\", `\n        CREATE INDEX idx_users_email ON users(email);\n    `)\n\n    return manager.Run(context.Background(), source, migrations.DefaultProgressFn)\n}\n</code></pre>"},{"location":"db/migrations/#provider-integration","title":"Provider Integration","text":""},{"location":"db/migrations/#postgresql-migrations","title":"PostgreSQL Migrations","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"github.com/oddbit-project/blueprint/provider/pgsql\"\n    \"github.com/oddbit-project/blueprint/db/migrations\"\n    \"log\"\n)\n\nfunc runPostgreSQLMigrations() error {\n    // Setup PostgreSQL client\n    config := pgsql.NewClientConfig()\n    config.DSN = \"postgres://user:pass@localhost/dbname?sslmode=disable\"\n\n    client, err := pgsql.NewClient(config)\n    if err != nil {\n        return err\n    }\n    defer client.Disconnect()\n\n    // Create migration manager\n    manager, err := pgsql.NewMigrationManager(context.Background(), client)\n    if err != nil {\n        return err\n    }\n\n    // Setup migration source\n    source, err := migrations.NewDiskSource(\"./migrations\")\n    if err != nil {\n        return err\n    }\n\n    // Run migrations with progress reporting\n    return manager.Run(context.Background(), source, func(msgType int, migrationName string, err error) {\n        switch msgType {\n        case migrations.MsgRunMigration:\n            log.Printf(\"Running migration: %s\", migrationName)\n        case migrations.MsgFinishedMigration:\n            log.Printf(\"Completed migration: %s\", migrationName)\n        case migrations.MsgSkipMigration:\n            log.Printf(\"Skipping migration (already run): %s\", migrationName)\n        case migrations.MsgError:\n            log.Printf(\"Migration error in %s: %v\", migrationName, err)\n        }\n    })\n}\n</code></pre>"},{"location":"db/migrations/#clickhouse-migrations","title":"ClickHouse Migrations","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"github.com/oddbit-project/blueprint/provider/clickhouse\"\n    \"github.com/oddbit-project/blueprint/db/migrations\" \n    \"log\"\n)\n\nfunc runClickHouseMigrations() error {\n    // Setup ClickHouse client\n    config := clickhouse.NewClientConfig()\n    config.DSN = \"clickhouse://localhost:9000/default\"\n\n    client, err := clickhouse.NewClient(config)\n    if err != nil {\n        return err\n    }\n    defer client.Disconnect()\n\n    // Create migration manager\n    manager, err := clickhouse.NewMigrationManager(context.Background(), client)\n    if err != nil {\n        return err\n    }\n\n    // Setup migration source\n    source, err := migrations.NewDiskSource(\"./migrations\")\n    if err != nil {\n        return err\n    }\n\n    // Run migrations\n    return manager.Run(context.Background(), source, migrations.DefaultProgressFn)\n}\n</code></pre>"},{"location":"db/migrations/#migration-workflow","title":"Migration Workflow","text":""},{"location":"db/migrations/#basic-migration-execution","title":"Basic Migration Execution","text":"<pre><code>func executeMigrations(manager migrations.Manager, source migrations.Source) error {\n    ctx := context.Background()\n\n    // Get list of available migrations\n    available, err := source.List()\n    if err != nil {\n        return fmt.Errorf(\"failed to list migrations: %w\", err)\n    }\n\n    log.Printf(\"Found %d migrations\", len(available))\n\n    // Get list of executed migrations\n    executed, err := manager.List(ctx)\n    if err != nil {\n        return fmt.Errorf(\"failed to list executed migrations: %w\", err)\n    }\n\n    log.Printf(\"Found %d executed migrations\", len(executed))\n\n    // Run pending migrations\n    return manager.Run(ctx, source, migrations.DefaultProgressFn)\n}\n</code></pre>"},{"location":"db/migrations/#custom-progress-tracking","title":"Custom Progress Tracking","text":"<pre><code>func customProgressTracking(manager migrations.Manager, source migrations.Source) error {\n    progressFn := func(msgType int, migrationName string, err error) {\n        switch msgType {\n        case migrations.MsgRunMigration:\n            fmt.Printf(\"Running: %s\\n\", migrationName)\n        case migrations.MsgFinishedMigration:\n            fmt.Printf(\"Completed: %s\\n\", migrationName)\n        case migrations.MsgSkipMigration:\n            fmt.Printf(\" Skipped: %s (already executed)\\n\", migrationName)\n        case migrations.MsgError:\n            fmt.Printf(\"Error in %s: %v\\n\", migrationName, err)\n        }\n    }\n\n    return manager.Run(context.Background(), source, progressFn)\n}\n</code></pre>"},{"location":"db/migrations/#validation-and-safety-checks","title":"Validation and Safety Checks","text":"<pre><code>func validateMigrations(manager migrations.Manager, source migrations.Source) error {\n    ctx := context.Background()\n\n    // Get available migrations\n    available, err := source.List()\n    if err != nil {\n        return err\n    }\n\n    // Validate each migration\n    for _, name := range available {\n        migration, err := source.Read(name)\n        if err != nil {\n            return fmt.Errorf(\"failed to read migration %s: %w\", name, err)\n        }\n\n        // Check if migration exists with different content\n        exists, err := manager.MigrationExists(ctx, migration.Name, migration.SHA2)\n        if err != nil {\n            return fmt.Errorf(\"failed to check migration %s: %w\", name, err)\n        }\n\n        if exists {\n            log.Printf(\"Migration %s already executed\", name)\n        } else {\n            // Check if migration name exists with different hash\n            executed, err := manager.List(ctx)\n            if err != nil {\n                return err\n            }\n\n            for _, exec := range executed {\n                if exec.Name == migration.Name &amp;&amp; exec.SHA2 != migration.SHA2 {\n                    return fmt.Errorf(\"migration %s exists but content has changed\", name)\n                }\n            }\n\n            log.Printf(\"Migration %s is pending\", name)\n        }\n    }\n\n    return nil\n}\n</code></pre>"},{"location":"db/migrations/#conditional-migrations","title":"Conditional Migrations","text":"<pre><code>type ConditionalSource struct {\n    source    migrations.Source\n    condition func(string) bool\n}\n\nfunc (cs *ConditionalSource) List() ([]string, error) {\n    all, err := cs.source.List()\n    if err != nil {\n        return nil, err\n    }\n\n    var filtered []string\n    for _, name := range all {\n        if cs.condition(name) {\n            filtered = append(filtered, name)\n        }\n    }\n\n    return filtered, nil\n}\n\nfunc (cs *ConditionalSource) Read(name string) (*migrations.MigrationRecord, error) {\n    if !cs.condition(name) {\n        return nil, fmt.Errorf(\"migration %s not allowed\", name)\n    }\n\n    return cs.source.Read(name)\n}\n\nfunc runConditionalMigrations(manager migrations.Manager, source migrations.Source) error {\n    // Only run migrations matching pattern\n    conditionalSource := &amp;ConditionalSource{\n        source: source,\n        condition: func(name string) bool {\n            return strings.HasPrefix(name, \"prod_\")\n        },\n    }\n\n    return manager.Run(context.Background(), conditionalSource, migrations.DefaultProgressFn)\n}\n</code></pre>"},{"location":"db/migrations/#error-handling","title":"Error Handling","text":""},{"location":"db/migrations/#migration-errors","title":"Migration Errors","text":"<pre><code>func handleMigrationErrors(manager migrations.Manager, source migrations.Source) error {\n    ctx := context.Background()\n\n    progressFn := func(msgType int, migrationName string, err error) {\n        switch msgType {\n        case migrations.MsgError:\n            // Log detailed error information\n            log.Printf(\"Migration %s failed: %v\", migrationName, err)\n\n            // Check specific error types\n            switch {\n            case errors.Is(err, migrations.ErrMigrationExists):\n                log.Printf(\"Migration %s already exists\", migrationName)\n            case errors.Is(err, migrations.ErrMigrationNameHashMismatch):\n                log.Printf(\"Migration %s content has changed\", migrationName)\n            case errors.Is(err, migrations.ErrRegisterMigration):\n                log.Printf(\"Migration %s executed but registration failed\", migrationName)\n            default:\n                log.Printf(\"Unexpected error in migration %s\", migrationName)\n            }\n        }\n    }\n\n    err := manager.Run(ctx, source, progressFn)\n    if err != nil {\n        return fmt.Errorf(\"migration execution failed: %w\", err)\n    }\n\n    return nil\n}\n</code></pre>"},{"location":"db/migrations/#recovery-and-cleanup","title":"Recovery and Cleanup","text":"<pre><code>func recoverFromFailedMigration(manager migrations.Manager, migrationName string) error {\n    ctx := context.Background()\n\n    // Check if migration was partially executed\n    migrations, err := manager.List(ctx)\n    if err != nil {\n        return err\n    }\n\n    for _, m := range migrations {\n        if m.Name == migrationName {\n            log.Printf(\"Migration %s found in database, checking consistency\", migrationName)\n\n            // Verify migration content matches\n            source := migrations.NewDiskSource(\"./migrations\")\n            current, err := source.Read(migrationName)\n            if err != nil {\n                return err\n            }\n\n            if m.SHA2 != current.SHA2 {\n                return fmt.Errorf(\"migration %s content mismatch: database=%s, file=%s\", \n                    migrationName, m.SHA2[:8], current.SHA2[:8])\n            }\n\n            log.Printf(\"Migration %s is consistent\", migrationName)\n            return nil\n        }\n    }\n\n    log.Printf(\"Migration %s not found in database, may need manual cleanup\", migrationName)\n    return nil\n}\n</code></pre>"},{"location":"db/migrations/#best-practices","title":"Best Practices","text":""},{"location":"db/migrations/#migration-design","title":"Migration Design","text":"<ol> <li>One Change Per Migration: Keep migrations focused on single changes</li> <li>Data Safety: Include data migration strategies for schema changes</li> <li>Testing: Test migrations against representative data</li> </ol>"},{"location":"db/migrations/#file-organization","title":"File Organization","text":"<ol> <li>Naming Convention: Use sequential numbering (001_, 002_, etc.)</li> <li>Descriptive Names: Include clear descriptions in filenames</li> <li>Directory Structure: Organize by environment or module if needed</li> <li>Version Control: Track migrations in version control</li> </ol>"},{"location":"db/migrations/#execution-strategy","title":"Execution Strategy","text":"<ol> <li>Backup First: Always backup before running migrations</li> <li>Test Environment: Run migrations in staging before production</li> <li>Monitoring: Monitor migration execution and performance</li> <li>Rollback Plan: Have rollback procedures ready</li> </ol>"},{"location":"db/migrations/#error-handling_1","title":"Error Handling","text":"<ol> <li>Fail Fast: Stop on first error to prevent inconsistent state</li> <li>Logging: Log all migration activities for debugging</li> <li>Validation: Validate migration state before and after execution</li> <li>Recovery: Have procedures for recovering from failed migrations</li> </ol>"},{"location":"db/migrations/#performance-considerations","title":"Performance Considerations","text":""},{"location":"db/migrations/#large-migrations","title":"Large Migrations","text":"<pre><code>func runLargeMigration(manager migrations.Manager) error {\n    // For large data migrations, consider batching\n    source := migrations.NewMemorySource()\n    source.AddMigration(\"large_migration\", `\n        -- Process in batches to avoid long locks\n        UPDATE users SET status = 'active' \n        WHERE id BETWEEN 1 AND 10000;\n\n        -- Add index concurrently (PostgreSQL)\n        CREATE INDEX CONCURRENTLY idx_users_status ON users(status);\n    `)\n\n    return manager.Run(context.Background(), source, func(msgType int, name string, err error) {\n        if msgType == migrations.MsgRunMigration {\n            log.Printf(\"Starting large migration %s - this may take a while\", name)\n        }\n    })\n}\n</code></pre>"},{"location":"db/migrations/#migration-optimization","title":"Migration Optimization","text":"<ol> <li>Batch Processing: Process large datasets in batches</li> <li>Index Management: Create indexes concurrently when possible</li> <li>Lock Minimization: Avoid long-running locks on production tables</li> <li>Resource Monitoring: Monitor CPU, memory, and disk usage</li> </ol>"},{"location":"db/migrations/#see-also","title":"See Also","text":"<ul> <li>PostgreSQL Provider</li> <li>ClickHouse Provider</li> <li>Database Package Overview</li> <li>Client Documentation</li> </ul>"},{"location":"db/query-builder/","title":"Query Builder","text":"<p>The Query Builder (qb) package provides a powerful SQL generation system with dialect abstraction, type-safe query construction,  and advanced features like RETURNING clauses. It serves as the foundation for Repository operations and can be used directly for complex query construction.</p> <p>Note: The Query Builder only supports INSERT and UPDATE queries currently; other features will be included in the future</p>"},{"location":"db/query-builder/#overview","title":"Overview","text":"<p>The Query Builder system includes:</p> <ul> <li>SQL dialect abstraction for database portability (currently only INSERT and UPDATE)</li> <li>Type-safe query construction with struct integration</li> <li>Advanced UPDATE operations with flexible options</li> <li>RETURNING clause support for INSERT and UPDATE</li> <li>Integration with field metadata for automatic mapping</li> <li>Batch operation support</li> </ul>"},{"location":"db/query-builder/#core-components","title":"Core Components","text":""},{"location":"db/query-builder/#sqldialect-interface","title":"SqlDialect Interface","text":"<pre><code>type SqlDialect interface {\n    Name() string\n    Quote(identifier string) string\n    Placeholder(position int) string\n}\n</code></pre> <p>The SqlDialect interface abstracts database-specific SQL generation:</p> <ul> <li>Name(): Returns the dialect name (e.g., \"pgx\", \"clickhouse\")</li> <li>Quote(): Quotes identifiers for the target database</li> <li>Placeholder(): Generates parameter placeholders ($1, ?, etc.)</li> </ul>"},{"location":"db/query-builder/#sqlbuilder","title":"SqlBuilder","text":"<pre><code>type SqlBuilder struct {\n    dialect SqlDialect\n}\n\nfunc NewSqlBuilder(dialect SqlDialect) *SqlBuilder\n</code></pre> <p>The main query builder that coordinates SQL generation using the specified dialect.</p> <p>Example: <pre><code>package main\n\nimport (\n    \"github.com/oddbit-project/blueprint/db/qb\"\n    \"log\"\n)\n\nfunc main() {\n    // Create builder with PostgreSQL dialect\n    dialect := qb.NewPostgreSqlDialect()\n    builder := qb.NewSqlBuilder(dialect)\n\n    // Builder is ready for query generation\n    log.Printf(\"Using dialect: %s\", builder.Dialect().Name())\n}\n</code></pre></p>"},{"location":"db/query-builder/#updatebuilder","title":"UpdateBuilder","text":"<p>The UpdateBuilder provides advanced UPDATE query construction with flexible options and RETURNING support.</p>"},{"location":"db/query-builder/#basic-update-operations","title":"Basic Update Operations","text":"<pre><code>type User struct {\n    ID        int       `db:\"id\" goqu:\"skipupdate\"`\n    Name      string    `db:\"name\"`\n    Email     string    `db:\"email\"`\n    UpdatedAt time.Time `db:\"updated_at\"`\n}\n\nfunc updateUser(builder *qb.SqlBuilder, user *User, userID int) error {\n    updateBuilder := builder.Update(\"users\", user).\n        WithOptions(qb.DefaultUpdateOptions()).\n        Where(qb.Eq(\"id\", userID))\n\n    sql, args, err := updateBuilder.Build()\n    if err != nil {\n        return err\n    }\n\n    log.Printf(\"SQL: %s\", sql)\n    log.Printf(\"Args: %v\", args)\n\n    // Execute with your database connection\n    return nil\n}\n</code></pre>"},{"location":"db/query-builder/#update-with-field-selection","title":"Update with Field Selection","text":"<pre><code>func updateUserEmail(builder *qb.SqlBuilder, userID int, email string) error {\n    user := &amp;User{\n        Email:     email,\n        UpdatedAt: time.Now(),\n    }\n\n    options := &amp;qb.UpdateOptions{\n        IncludeFields: []string{\"email\", \"updated_at\"},\n    }\n\n    updateBuilder := builder.Update(\"users\", user).\n        WithOptions(options).\n        Where(qb.Eq(\"id\", userID))\n\n    sql, args, err := updateBuilder.Build()\n    if err != nil {\n        return err\n    }\n\n    // SQL: UPDATE users SET email = $1, updated_at = $2 WHERE id = $3\n    return executeSQL(sql, args)\n}\n</code></pre>"},{"location":"db/query-builder/#update-with-field-values-map","title":"Update with Field Values Map","text":"<pre><code>func updateUserFields(builder *qb.SqlBuilder, userID int, updates map[string]any) error {\n    user := &amp;User{}\n\n    updateBuilder := builder.Update(\"users\", user).\n        WithOptions(qb.DefaultUpdateOptions()).\n        FieldsValues(updates).\n        Where(qb.Eq(\"id\", userID))\n\n    sql, args, err := updateBuilder.Build()\n    if err != nil {\n        return err\n    }\n\n    return executeSQL(sql, args)\n}\n\nfunc main() {\n    updates := map[string]any{\n        \"name\":       \"John Updated\",\n        \"email\":      \"john.updated@example.com\",\n        \"updated_at\": time.Now(),\n    }\n\n    err := updateUserFields(builder, 123, updates)\n    if err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>"},{"location":"db/query-builder/#updateoptions","title":"UpdateOptions","text":"<p>The UpdateOptions struct provides fine-grained control over UPDATE query generation:</p> <pre><code>type UpdateOptions struct {\n    IncludeFields     []string\n    ExcludeFields     []string\n    IncludeZeroValues bool\n    UpdateAutoFields  bool\n    ReturningFields   []string\n}\n</code></pre>"},{"location":"db/query-builder/#field-inclusionexclusion","title":"Field Inclusion/Exclusion","text":"<pre><code>func updateUserSelective(builder *qb.SqlBuilder, user *User, userID int) error {\n    options := &amp;qb.UpdateOptions{\n        // Only update these fields\n        IncludeFields: []string{\"name\", \"email\"},\n        // Never update these fields\n        ExcludeFields: []string{\"created_at\", \"id\"},\n        // Include zero values (empty strings, 0, false)\n        IncludeZeroValues: true,\n    }\n\n    updateBuilder := builder.Update(\"users\", user).\n        WithOptions(options).\n        Where(qb.Eq(\"id\", userID))\n\n    sql, args, err := updateBuilder.Build()\n    return executeSQL(sql, args)\n}\n</code></pre>"},{"location":"db/query-builder/#auto-field-handling","title":"Auto Field Handling","text":"<pre><code>type User struct {\n    ID        int       `db:\"id\" goqu:\"skipupdate\"`        // Never updated\n    Name      string    `db:\"name\"`\n    Email     string    `db:\"email\"`\n    CreatedAt time.Time `db:\"created_at\" goqu:\"skipupdate\"` // Never updated\n    UpdatedAt time.Time `db:\"updated_at\" auto:\"true\"`       // Auto field\n}\n\nfunc updateWithAutoFields(builder *qb.SqlBuilder, user *User, userID int) error {\n    options := &amp;qb.UpdateOptions{\n        // Update auto fields (updated_at will be set to current time)\n        UpdateAutoFields: true,\n    }\n\n    updateBuilder := builder.Update(\"users\", user).\n        WithOptions(options).\n        Where(qb.Eq(\"id\", userID))\n\n    sql, args, err := updateBuilder.Build()\n    return executeSQL(sql, args)\n}\n</code></pre>"},{"location":"db/query-builder/#returning-clause-support","title":"RETURNING Clause Support","text":""},{"location":"db/query-builder/#update-with-returning","title":"Update with RETURNING","text":"<pre><code>func updateUserReturning(builder *qb.SqlBuilder, user *User, userID int) (*User, error) {\n    options := &amp;qb.UpdateOptions{\n        ReturningFields: []string{\"id\", \"name\", \"email\", \"updated_at\"},\n    }\n\n    updateBuilder := builder.Update(\"users\", user).\n        WithOptions(options).\n        Where(qb.Eq(\"id\", userID))\n\n    sql, args, err := updateBuilder.Build()\n    if err != nil {\n        return nil, err\n    }\n\n    // Execute and scan result back into struct\n    result := &amp;User{}\n    err = executeReturning(sql, args, result)\n    if err != nil {\n        return nil, err\n    }\n\n    return result, nil\n}\n</code></pre>"},{"location":"db/query-builder/#insert-with-returning","title":"Insert with RETURNING","text":"<pre><code>func insertUserReturning(builder *qb.SqlBuilder, user *User) (*User, error) {\n    returnFields := []string{\"id\", \"name\", \"email\", \"created_at\"}\n\n    sql, args, err := builder.InsertReturning(\"users\", user, returnFields)\n    if err != nil {\n        return nil, err\n    }\n\n    result := &amp;User{}\n    err = executeReturning(sql, args, result)\n    if err != nil {\n        return nil, err\n    }\n\n    return result, nil\n}\n</code></pre>"},{"location":"db/query-builder/#where-clause-construction","title":"WHERE Clause Construction","text":"<p>The query builder provides a fluent interface for building WHERE clauses:</p>"},{"location":"db/query-builder/#basic-where-conditions","title":"Basic WHERE Conditions","text":"<pre><code>func buildWhereConditions(builder *qb.SqlBuilder) error {\n    updateBuilder := builder.Update(\"users\", &amp;User{}).\n        Where(qb.Eq(\"active\", true)).\n        Where(qb.Gt(\"age\", 18)).\n        Where(qb.Like(\"name\", \"John%\"))\n\n    sql, args, err := updateBuilder.Build()\n    // SQL: UPDATE users SET ... WHERE active = $1 AND age &gt; $2 AND name LIKE $3\n\n    return executeSQL(sql, args)\n}\n</code></pre>"},{"location":"db/query-builder/#complex-where-conditions","title":"Complex WHERE Conditions","text":"<pre><code>func buildComplexWhere(builder *qb.SqlBuilder) error {\n    updateBuilder := builder.Update(\"users\", &amp;User{}).\n        WhereAnd(\n            qb.Eq(\"department\", \"engineering\"),\n            qb.Or(\n                qb.Eq(\"role\", \"senior\"),\n                qb.Gt(\"experience_years\", 5),\n            ),\n        )\n\n    sql, args, err := updateBuilder.Build()\n    // SQL: UPDATE users SET ... WHERE (department = $1 AND (role = $2 OR experience_years &gt; $3))\n\n    return executeSQL(sql, args)\n}\n</code></pre>"},{"location":"db/query-builder/#where-clause-helpers","title":"WHERE Clause Helpers","text":"<pre><code>// Common WHERE clause constructors\nfunc whereExamples() {\n    // Equality\n    condition1 := qb.Eq(\"status\", \"active\")\n\n    // Comparison\n    condition2 := qb.Gt(\"age\", 21)\n    condition3 := qb.Lt(\"score\", 100)\n    condition4 := qb.Gte(\"rating\", 4.0)\n    condition5 := qb.Lte(\"price\", 99.99)\n\n    // Pattern matching\n    condition6 := qb.Like(\"name\", \"John%\")\n    condition7 := qb.ILike(\"email\", \"%@EXAMPLE.COM\") // Case-insensitive\n\n    // NULL checks\n    condition8 := qb.IsNull(\"deleted_at\")\n    condition9 := qb.IsNotNull(\"confirmed_at\")\n\n    // IN clauses\n    condition10 := qb.In(\"status\", []any{\"active\", \"pending\"})\n    condition11 := qb.NotIn(\"role\", []any{\"admin\", \"super_admin\"})\n}\n</code></pre>"},{"location":"db/query-builder/#batch-operations","title":"Batch Operations","text":""},{"location":"db/query-builder/#batch-insert","title":"Batch Insert","text":"<pre><code>func batchInsertUsers(builder *qb.SqlBuilder, users []any) error {\n    sql, args, err := builder.BuildSQLBatchInsert(\"users\", users)\n    if err != nil {\n        return err\n    }\n\n    // Execute batch insert\n    return executeBatch(sql, args)\n}\n\nfunc main() {\n    users := []any{\n        &amp;User{Name: \"John\", Email: \"john@example.com\"},\n        &amp;User{Name: \"Jane\", Email: \"jane@example.com\"},\n        &amp;User{Name: \"Bob\", Email: \"bob@example.com\"},\n    }\n\n    err := batchInsertUsers(builder, users)\n    if err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre>"},{"location":"db/query-builder/#batch-update","title":"Batch Update","text":"<pre><code>func batchUpdateUsers(builder *qb.SqlBuilder, users []any) error {\n    keyFields := []string{\"id\"}\n    options := qb.DefaultUpdateOptions()\n\n    statements, argsList, err := builder.BuildSQLBatchUpdate(\"users\", users, keyFields, options)\n    if err != nil {\n        return err\n    }\n\n    // Execute each update in a transaction\n    return executeBatchInTransaction(statements, argsList)\n}\n</code></pre>"},{"location":"db/query-builder/#integration-with-repository","title":"Integration with Repository","text":"<p>The Query Builder integrates seamlessly with the Repository pattern:</p>"},{"location":"db/query-builder/#repository-updatex-method","title":"Repository UpdateX Method","text":"<pre><code>func updateUserWithBuilder(repo db.Repository, user *User, userID int) error {\n    updateBuilder := repo.SqlUpdateX(user).\n        Where(qb.Eq(\"id\", userID))\n\n    // Execute through Repository\n    return repo.Do(updateBuilder)\n}\n</code></pre>"},{"location":"db/query-builder/#custom-query-building","title":"Custom Query Building","text":"<pre><code>func customUserQuery(repo db.Repository) error {\n    builder := repo.SqlBuilder()\n\n    // Build complex update\n    updateBuilder := builder.Update(\"users\", &amp;User{}).\n        FieldsValues(map[string]any{\n            \"last_login\": time.Now(),\n            \"login_count\": qb.Raw(\"login_count + 1\"),\n        }).\n        Where(qb.Eq(\"id\", 123))\n\n    return repo.Do(updateBuilder)\n}\n</code></pre>"},{"location":"db/query-builder/#advanced-features","title":"Advanced Features","text":""},{"location":"db/query-builder/#raw-sql-expressions","title":"Raw SQL Expressions","text":"<pre><code>func useRawExpressions(builder *qb.SqlBuilder) error {\n    updateBuilder := builder.Update(\"users\", &amp;User{}).\n        FieldsValues(map[string]any{\n            \"score\": qb.Raw(\"GREATEST(score, $1)\", 100),\n            \"updated_at\": qb.Raw(\"NOW()\"),\n            \"rank\": qb.Raw(\"rank + 1\"),\n        }).\n        Where(qb.Eq(\"active\", true))\n\n    sql, args, err := updateBuilder.Build()\n    return executeSQL(sql, args)\n}\n</code></pre>"},{"location":"db/query-builder/#subqueries","title":"Subqueries","text":"<pre><code>func updateWithSubquery(builder *qb.SqlBuilder) error {\n    // Subquery to get average score\n    avgSubquery := builder.SqlBuilder().\n        Select(\"AVG(score)\").\n        From(\"users\").\n        Where(qb.Eq(\"department\", \"engineering\"))\n\n    updateBuilder := builder.Update(\"users\", &amp;User{}).\n        FieldsValues(map[string]any{\n            \"performance_rating\": qb.Subquery(avgSubquery),\n        }).\n        Where(qb.Eq(\"id\", 123))\n\n    sql, args, err := updateBuilder.Build()\n    return executeSQL(sql, args)\n}\n</code></pre>"},{"location":"db/query-builder/#error-handling","title":"Error Handling","text":""},{"location":"db/query-builder/#validation-errors","title":"Validation Errors","text":"<pre><code>func handleValidationErrors(builder *qb.SqlBuilder) {\n    updateBuilder := builder.Update(\"users\", &amp;User{})\n\n    sql, args, err := updateBuilder.Build()\n    if err != nil {\n        switch {\n        case errors.Is(err, qb.ErrNoFieldsToUpdate):\n            log.Println(\"No fields specified for update\")\n        case errors.Is(err, qb.ErrInvalidWhereClause):\n            log.Println(\"Invalid WHERE clause\")\n        default:\n            log.Printf(\"Build error: %v\", err)\n        }\n        return\n    }\n\n    executeSQL(sql, args)\n}\n</code></pre>"},{"location":"db/query-builder/#field-validation","title":"Field Validation","text":"<pre><code>func validateFields(builder *qb.SqlBuilder, user *User) error {\n    // Validate required fields before building query\n    if user.Name == \"\" {\n        return errors.New(\"name is required\")\n    }\n\n    if user.Email == \"\" {\n        return errors.New(\"email is required\")\n    }\n\n    updateBuilder := builder.Update(\"users\", user).\n        Where(qb.Eq(\"id\", user.ID))\n\n    sql, args, err := updateBuilder.Build()\n    if err != nil {\n        return fmt.Errorf(\"failed to build update query: %w\", err)\n    }\n\n    return executeSQL(sql, args)\n}\n</code></pre>"},{"location":"db/query-builder/#performance-considerations","title":"Performance Considerations","text":""},{"location":"db/query-builder/#query-preparation","title":"Query Preparation","text":"<pre><code>func optimizeQueryBuilding(builder *qb.SqlBuilder) {\n    // Build query once, reuse multiple times\n    updateBuilder := builder.Update(\"users\", &amp;User{}).\n        WithOptions(&amp;qb.UpdateOptions{\n            IncludeFields: []string{\"name\", \"email\", \"updated_at\"},\n        }).\n        Where(qb.Eq(\"id\", qb.Placeholder(1)))\n\n    baseSQL, _, err := updateBuilder.Build()\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Reuse prepared statement structure\n    for _, user := range users {\n        args := []any{user.Name, user.Email, time.Now(), user.ID}\n        executeSQL(baseSQL, args)\n    }\n}\n</code></pre>"},{"location":"db/query-builder/#batch-processing","title":"Batch Processing","text":"<pre><code>func efficientBatchUpdate(builder *qb.SqlBuilder, users []*User) error {\n    const batchSize = 100\n\n    for i := 0; i &lt; len(users); i += batchSize {\n        end := i + batchSize\n        if end &gt; len(users) {\n            end = len(users)\n        }\n\n        batch := make([]any, end-i)\n        for j, user := range users[i:end] {\n            batch[j] = user\n        }\n\n        if err := batchUpdateUsers(builder, batch); err != nil {\n            return fmt.Errorf(\"batch %d failed: %w\", i/batchSize, err)\n        }\n    }\n\n    return nil\n}\n</code></pre>"},{"location":"db/query-builder/#best-practices","title":"Best Practices","text":""},{"location":"db/query-builder/#query-construction","title":"Query Construction","text":"<ol> <li>Use Options: Leverage UpdateOptions for flexible field control</li> <li>Validate Input: Check required fields before building queries</li> <li>Handle Zero Values: Use IncludeZeroValues appropriately</li> <li>Use RETURNING: Fetch updated data efficiently with RETURNING clauses</li> </ol>"},{"location":"db/query-builder/#performance","title":"Performance","text":"<ol> <li>Batch Operations: Use batch methods for multiple records</li> <li>Prepare Queries: Reuse query structures when possible</li> <li>Limit Fields: Only update necessary fields</li> <li>Use Transactions: Group related operations</li> </ol>"},{"location":"db/query-builder/#error-handling_1","title":"Error Handling","text":"<ol> <li>Check Build Errors: Always handle query building errors</li> <li>Validate Data: Verify data before query construction</li> <li>Use Contexts: Include context in all database operations</li> <li>Log Queries: Log generated SQL for debugging</li> </ol>"},{"location":"db/query-builder/#security","title":"Security","text":"<ol> <li>Use Parameters: Never concatenate user input into SQL</li> <li>Validate WHERE Clauses: Ensure proper WHERE conditions</li> <li>Escape Identifiers: Use proper identifier quoting</li> <li>Limit Operations: Include appropriate WHERE clauses</li> </ol>"},{"location":"db/query-builder/#integration-examples","title":"Integration Examples","text":""},{"location":"db/query-builder/#with-http-handlers","title":"With HTTP Handlers","text":"<pre><code>func updateUserHandler(w http.ResponseWriter, r *http.Request) {\n    userID, _ := strconv.Atoi(mux.Vars(r)[\"id\"])\n\n    var updateReq struct {\n        Name  string `json:\"name\"`\n        Email string `json:\"email\"`\n    }\n\n    if err := json.NewDecoder(r.Body).Decode(&amp;updateReq); err != nil {\n        http.Error(w, err.Error(), http.StatusBadRequest)\n        return\n    }\n\n    updates := map[string]any{\n        \"name\":       updateReq.Name,\n        \"email\":      updateReq.Email,\n        \"updated_at\": time.Now(),\n    }\n\n    options := &amp;qb.UpdateOptions{\n        ReturningFields: []string{\"id\", \"name\", \"email\", \"updated_at\"},\n    }\n\n    updateBuilder := builder.Update(\"users\", &amp;User{}).\n        WithOptions(options).\n        FieldsValues(updates).\n        Where(qb.Eq(\"id\", userID))\n\n    sql, args, err := updateBuilder.Build()\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n\n    user := &amp;User{}\n    if err := executeReturning(sql, args, user); err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    json.NewEncoder(w).Encode(user)\n}\n</code></pre>"},{"location":"db/query-builder/#see-also","title":"See Also","text":"<ul> <li>Repository Documentation</li> <li>Database Functions</li> <li>Field Metadata</li> <li>Database Package Overview</li> </ul>"},{"location":"db/repository/","title":"db.Repository","text":"<p>Repository pattern implementation with blueprint and goqu. The Repository provides a comprehensive interface-driven abstraction for database operations, composed of multiple specialized interfaces for different operation types.</p>"},{"location":"db/repository/#overview","title":"Overview","text":"<p>The Repository interface is composed of multiple smaller interfaces, following the Interface Segregation Principle:</p> <pre><code>type Repository interface {\n    Identifier\n    Builder\n    Reader\n    Executor\n    Writer\n    Deleter\n    Updater\n    Counter\n    GridOps\n    SqlBuilder\n    NewTransaction(opts *sql.TxOptions) (Transaction, error)\n}\n</code></pre>"},{"location":"db/repository/#usage","title":"Usage","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"github.com/oddbit-project/blueprint/db\"\n    \"github.com/oddbit-project/blueprint/provider/pgsql\"\n    \"log\"\n    \"time\"\n)\n\ntype UserRecord struct {\n    Id        int       `db:\"id_user\" goqu:\"skipinsert\"` // field is autogenerated\n    CreatedAt time.Time `db:\"created_at\"`\n    UpdatedAt time.Time `db:\"updated_at\"`\n    Name      string    `db:\"name\"`\n    Email     string    `db:\"email\"`\n}\n\nfunc main() {\n    pgConfig := pgsql.NewClientConfig() // use defaults\n    pgConfig.DSN = \"postgres://username:password@localhost:5432/database?sslmode=allow\"\n\n    client, err := pgsql.NewClient(pgConfig)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // create a repository for the table users\n    // Note: context is internally stored and then propagated to the appropriate sqlx methods; this is\n    // not the advised way of using contexts, but the rationale is to allow clean thread or application shutdown\n    // via context, without the overhead of adding an extra parameter to every function\n    repo := db.NewRepository(context.Background(), client, \"users\")\n\n    user1 := &amp;UserRecord{\n        CreatedAt: time.Now(),\n        UpdatedAt: time.Now(),\n        Name:      \"John Connor\",\n        Email:     \"jconnor@skynet.com\",\n    }\n\n    // Add user\n    if err = repo.Insert(user1); err != nil {\n        log.Fatal(err)\n    }\n\n    // Read all users\n    users := make([]*UserRecord, 0)\n    if err = repo.Fetch(repo.SqlSelect(), &amp;users); err != nil {\n        log.Fatal(err)\n    }\n\n    // search for sarah by email\n    sarah := &amp;UserRecord{}\n    if err = repo.FetchRecord(map[string]any{\"email\": \"sconnor@skynet.com\"}, sarah); err != nil {\n        if db.EmptyResult(err) {\n            fmt.Println(\"Sarah Connor not found\")\n        } else {\n            log.Fatal(err)\n        }\n\n    }\n\n    // Count all users\n    count, err := repo.Count()\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Printf(\"Total users: %d\\n\", count)\n\n    // Count users with specific criteria\n    activeCount, err := repo.CountWhere(map[string]any{\"active\": true})\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Printf(\"Active users: %d\\n\", activeCount)\n}\n</code></pre>"},{"location":"db/repository/#interface-documentation","title":"Interface Documentation","text":""},{"location":"db/repository/#reader-interface","title":"Reader Interface","text":"<p>The Reader interface provides methods for fetching data from the database:</p> <pre><code>type Reader interface {\n    FetchOne(qry *goqu.SelectDataset, target any) error\n    FetchRecord(fieldValues map[string]any, target any) error\n    Fetch(qry *goqu.SelectDataset, target any) error\n    FetchWhere(fieldValues map[string]any, target any) error\n    FetchByKey(keyField string, value any, target any) error\n    Exists(fieldName string, fieldValue any, skip ...any) (bool, error)\n}\n</code></pre>"},{"location":"db/repository/#fetchone","title":"FetchOne","text":"<pre><code>func (r *repository) FetchOne(qry *goqu.SelectDataset, target any) error\n</code></pre> <p>Fetches a single record using a goqu SelectDataset. The target must be a struct pointer. Automatically adds LIMIT 1 to the query.</p> <p>Example: <pre><code>user := &amp;UserRecord{}\nerr := repo.FetchOne(repo.SqlSelect().Where(goqu.C(\"id\").Eq(123)), user)\nif err != nil {\n    if db.EmptyResult(err) {\n        log.Println(\"User not found\")\n    } else {\n        log.Fatal(err)\n    }\n}\n</code></pre></p>"},{"location":"db/repository/#fetchrecord","title":"FetchRecord","text":"<pre><code>func (r *repository) FetchRecord(fieldValues map[string]any, target any) error\n</code></pre> <p>Fetches a single record with WHERE clauses built from field values. All conditions are combined with AND.</p> <p>Example: <pre><code>user := &amp;UserRecord{}\nerr := repo.FetchRecord(map[string]any{\n    \"email\": \"john@example.com\",\n    \"active\": true,\n}, user)\n</code></pre></p>"},{"location":"db/repository/#fetch","title":"Fetch","text":"<pre><code>func (r *repository) Fetch(qry *goqu.SelectDataset, target any) error\n</code></pre> <p>Fetches multiple records. The target must be a slice pointer.</p> <p>Example: <pre><code>var users []*UserRecord\nerr := repo.Fetch(\n    repo.SqlSelect().\n        Where(goqu.C(\"active\").IsTrue()).\n        OrderBy(goqu.C(\"created_at\").Desc()),\n    &amp;users,\n)\n</code></pre></p>"},{"location":"db/repository/#fetchwhere","title":"FetchWhere","text":"<pre><code>func (r *repository) FetchWhere(fieldValues map[string]any, target any) error\n</code></pre> <p>Fetches multiple records with WHERE clauses from field values map.</p> <p>Example: <pre><code>var users []*UserRecord\nerr := repo.FetchWhere(map[string]any{\n    \"department\": \"engineering\",\n    \"active\": true,\n}, &amp;users)\n</code></pre></p>"},{"location":"db/repository/#fetchbykey","title":"FetchByKey","text":"<pre><code>func (r *repository) FetchByKey(keyField string, value any, target any) error\n</code></pre> <p>Fetches a single record by a specific key field value.</p> <p>Example: <pre><code>user := &amp;UserRecord{}\nerr := repo.FetchByKey(\"id\", 123, user)\n</code></pre></p>"},{"location":"db/repository/#exists","title":"Exists","text":"<pre><code>func (r *repository) Exists(fieldName string, fieldValue any, skip ...any) (bool, error)\n</code></pre> <p>Checks if records exist matching the given criteria. The optional skip parameter allows excluding specific records (useful for unique constraint validation).</p> <p>Example: <pre><code>// Check if email exists\nexists, err := repo.Exists(\"email\", \"john@example.com\")\n\n// Check if email exists, excluding user with ID 123\nexists, err = repo.Exists(\"email\", \"john@example.com\", \"id\", 123)\n</code></pre></p>"},{"location":"db/repository/#counter-interface","title":"Counter Interface","text":"<p>The Counter interface provides methods for counting records:</p> <pre><code>type Counter interface {\n    Count() (int64, error)\n    CountWhere(fieldValues map[string]any) (int64, error)\n}\n</code></pre>"},{"location":"db/repository/#count","title":"Count","text":"<pre><code>func (r *repository) Count() (int64, error)\n</code></pre> <p>Returns the total number of rows in the table.</p> <p>Example: <pre><code>total, err := repo.Count()\nif err != nil {\n    log.Fatal(err)\n}\nlog.Printf(\"Total records: %d\", total)\n</code></pre></p>"},{"location":"db/repository/#countwhere","title":"CountWhere","text":"<pre><code>func (r *repository) CountWhere(fieldValues map[string]any) (int64, error)\n</code></pre> <p>Returns the number of rows matching the field values map. All conditions are combined with AND.</p> <p>Example: <pre><code>activeCount, err := repo.CountWhere(map[string]any{\n    \"status\": \"active\",\n    \"verified\": true,\n})\n</code></pre></p>"},{"location":"db/repository/#executor-interface","title":"Executor Interface","text":"<p>The Executor interface provides methods for executing queries and raw SQL:</p> <pre><code>type Executor interface {\n    Exec(qry *goqu.SelectDataset) error\n    RawExec(sql string, args ...any) error\n    Select(sql string, target any, args ...any) error\n}\n</code></pre>"},{"location":"db/repository/#exec","title":"Exec","text":"<pre><code>func (r *repository) Exec(qry *goqu.SelectDataset) error\n</code></pre> <p>Executes a query without returning results (useful for complex operations).</p> <p>Example: <pre><code>err := repo.Exec(\n    repo.SqlSelect().\n        From(goqu.L(\"generate_series(1, 10)\")),\n)\n</code></pre></p>"},{"location":"db/repository/#rawexec","title":"RawExec","text":"<pre><code>func (r *repository) RawExec(sql string, args ...any) error\n</code></pre> <p>Executes raw SQL that doesn't return rows (DDL, complex updates, stored procedures).</p> <p>Example: <pre><code>err := repo.RawExec(`\n    CREATE INDEX CONCURRENTLY idx_users_email_active \n    ON users(email) WHERE active = true\n`)\n\n// With parameters\nerr = repo.RawExec(\n    \"CALL process_user_batch($1, $2)\", \n    startDate, endDate,\n)\n</code></pre></p>"},{"location":"db/repository/#select","title":"Select","text":"<pre><code>func (r *repository) Select(sql string, target any, args ...any) error\n</code></pre> <p>Executes raw SQL SELECT queries and scans results into target.</p> <p>Example: <pre><code>var stats []struct {\n    Department string `db:\"department\"`\n    Count      int    `db:\"count\"`\n}\n\nerr := repo.Select(`\n    SELECT department, COUNT(*) as count \n    FROM users \n    WHERE active = $1 \n    GROUP BY department\n`, &amp;stats, true)\n</code></pre></p>"},{"location":"db/repository/#writer-interface","title":"Writer Interface","text":"<p>The Writer interface provides methods for inserting records:</p> <pre><code>type Writer interface {\n    Insert(records ...any) error\n    InsertReturning(record any, returnFields []string, target ...any) error\n}\n</code></pre>"},{"location":"db/repository/#insert","title":"Insert","text":"<pre><code>func (r *repository) Insert(records ...any) error\n</code></pre> <p>Inserts one or more records. Supports efficient batch insert operations that generate optimized SQL for multiple records.</p> <p>Single Record Example: <pre><code>user := &amp;UserRecord{\n    Name:  \"John Doe\",\n    Email: \"john@example.com\",\n}\nerr := repo.Insert(user)\n</code></pre></p> <p>Batch Insert Examples:</p> <p>Method 1: Direct []any slice <pre><code>users := []any{\n    &amp;UserRecord{Name: \"Alice\", Email: \"alice@example.com\"},\n    &amp;UserRecord{Name: \"Bob\", Email: \"bob@example.com\"},\n    &amp;UserRecord{Name: \"Charlie\", Email: \"charlie@example.com\"},\n}\nerr := repo.Insert(users...)\n</code></pre></p> <p>Method 2: Using ToAnySlice helper <pre><code>// With typed slice\ntypedUsers := []*UserRecord{\n    {Name: \"Alice\", Email: \"alice@example.com\"},\n    {Name: \"Bob\", Email: \"bob@example.com\"},\n}\n\n// Convert and insert\nerr := repo.Insert(db.ToAnySlice(typedUsers)...)\n</code></pre></p> <p>Method 3: Large datasets with chunking <pre><code>func batchInsertLarge(repo db.Repository, users []*UserRecord) error {\n    const chunkSize = 1000\n\n    for i := 0; i &lt; len(users); i += chunkSize {\n        end := i + chunkSize\n        if end &gt; len(users) {\n            end = len(users)\n        }\n\n        chunk := users[i:end]\n        records := make([]any, len(chunk))\n        for j, user := range chunk {\n            records[j] = user\n        }\n\n        if err := repo.Insert(records...); err != nil {\n            return fmt.Errorf(\"chunk %d-%d failed: %w\", i, end-1, err)\n        }\n    }\n    return nil\n}\n</code></pre></p> <p>Method 4: Batch insert with transaction <pre><code>func batchInsertWithTransaction(repo db.Repository, users []*UserRecord) error {\n    tx, err := repo.NewTransaction(nil)\n    if err != nil {\n        return err\n    }\n    defer tx.Rollback()\n\n    records := db.ToAnySlice(users)\n    if err := tx.Insert(records...); err != nil {\n        return err\n    }\n\n    return tx.Commit()\n}\n</code></pre></p> <p>Performance Notes: - Batch inserts generate a single optimized SQL statement - Use chunking for very large datasets (&gt;1000 records) - Consider transactions for atomicity - Monitor memory usage with large batches</p>"},{"location":"db/repository/#insertreturning","title":"InsertReturning","text":"<pre><code>func (r *repository) InsertReturning(record any, returnFields []string, target ...any) error\n</code></pre> <p>Inserts a record and returns specified fields. Supports three scanning modes:</p> <ol> <li>Struct scanning - Maps returned fields to struct by name/tag</li> <li>Positional scanning - Maps to multiple variables by position</li> <li>Single value - Returns a single field value</li> </ol> <p>Examples: <pre><code>// Struct scanning - returns all fields into struct\nuser := &amp;UserRecord{Name: \"John\", Email: \"john@example.com\"}\nresult := &amp;UserRecord{}\nerr := repo.InsertReturning(user, []string{\"id\", \"name\", \"email\", \"created_at\"}, result)\n\n// Positional scanning - returns to individual variables\nvar id int64\nvar createdAt time.Time\nerr := repo.InsertReturning(user, []string{\"id\", \"created_at\"}, &amp;id, &amp;createdAt)\n\n// Single value - returns just the ID\nvar newID int64\nerr := repo.InsertReturning(user, []string{\"id\"}, &amp;newID)\n</code></pre></p>"},{"location":"db/repository/#updater-interface","title":"Updater Interface","text":"<p>The Updater interface provides comprehensive update operations:</p> <pre><code>type Updater interface {\n    Update(qry *goqu.UpdateDataset) error\n    UpdateReturning(record any, whereFieldsValues map[string]any, returnFields []string, target ...any) error\n    UpdateRecord(record any, whereFieldsValues map[string]any) error\n    UpdateFields(record any, fieldsValues map[string]any, whereFieldsValues map[string]any) error\n    UpdateFieldsReturning(record any, fieldsValues map[string]any, whereFieldsValues map[string]any, returnFields []string, target ...any) error\n    UpdateByKey(record any, keyField string, value any) error\n}\n</code></pre>"},{"location":"db/repository/#update-deprecated","title":"Update (Deprecated)","text":"<pre><code>func (r *repository) Update(qry *goqu.UpdateDataset) error\n</code></pre> <p>Executes an update using goqu UpdateDataset. This method is deprecated due to serialization issues with some data types. Use UpdateRecord instead.</p>"},{"location":"db/repository/#updaterecord","title":"UpdateRecord","text":"<pre><code>func (r *repository) UpdateRecord(record any, whereFieldsValues map[string]any) error\n</code></pre> <p>Updates a record using the modern query builder. WHERE conditions are combined with AND.</p> <p>Example: <pre><code>user := &amp;UserRecord{\n    Name:      \"John Updated\",\n    Email:     \"john.updated@example.com\",\n    UpdatedAt: time.Now(),\n}\n\nerr := repo.UpdateRecord(user, map[string]any{\"id\": 123})\n</code></pre></p>"},{"location":"db/repository/#updatefields","title":"UpdateFields","text":"<pre><code>func (r *repository) UpdateFields(record any, fieldsValues map[string]any, whereFieldsValues map[string]any) error\n</code></pre> <p>Updates specific fields only, useful for partial updates.</p> <p>Example: <pre><code>// Update only specific fields\nerr := repo.UpdateFields(\n    &amp;UserRecord{}, // empty struct for type info\n    map[string]any{\n        \"last_login\": time.Now(),\n        \"login_count\": goqu.L(\"login_count + 1\"),\n    },\n    map[string]any{\"id\": 123},\n)\n</code></pre></p>"},{"location":"db/repository/#updatereturning","title":"UpdateReturning","text":"<pre><code>func (r *repository) UpdateReturning(record any, whereFieldsValues map[string]any, returnFields []string, target ...any) error\n</code></pre> <p>Updates a record and returns specified fields. Supports the same three scanning modes as InsertReturning.</p> <p>Example: <pre><code>user := &amp;UserRecord{Name: \"John Updated\"}\nresult := &amp;UserRecord{}\n\nerr := repo.UpdateReturning(\n    user,\n    map[string]any{\"id\": 123},\n    []string{\"id\", \"name\", \"updated_at\"},\n    result,\n)\n</code></pre></p>"},{"location":"db/repository/#updatefieldsreturning","title":"UpdateFieldsReturning","text":"<pre><code>func (r *repository) UpdateFieldsReturning(record any, fieldsValues map[string]any, whereFieldsValues map[string]any, returnFields []string, target ...any) error\n</code></pre> <p>Updates specific fields and returns values. Combines UpdateFields with RETURNING support.</p> <p>Example: <pre><code>var updatedAt time.Time\nerr := repo.UpdateFieldsReturning(\n    &amp;UserRecord{},\n    map[string]any{\"status\": \"verified\"},\n    map[string]any{\"id\": 123},\n    []string{\"updated_at\"},\n    &amp;updatedAt,\n)\n</code></pre></p>"},{"location":"db/repository/#updatebykey","title":"UpdateByKey","text":"<pre><code>func (r *repository) UpdateByKey(record any, keyField string, value any) error\n</code></pre> <p>Updates a record using a single key field condition.</p> <p>Example: <pre><code>user := &amp;UserRecord{\n    Name:      \"Updated Name\",\n    UpdatedAt: time.Now(),\n}\n\nerr := repo.UpdateByKey(user, \"id\", 123)\n</code></pre></p>"},{"location":"db/repository/#deleter-interface","title":"Deleter Interface","text":"<p>The Deleter interface provides methods for deleting records:</p> <pre><code>type Deleter interface {\n    Delete(qry *goqu.DeleteDataset) error\n    DeleteWhere(fieldNameValue map[string]any) error\n    DeleteByKey(keyField string, value any) error\n}\n</code></pre>"},{"location":"db/repository/#delete","title":"Delete","text":"<pre><code>func (r *repository) Delete(qry *goqu.DeleteDataset) error\n</code></pre> <p>Executes a delete query using goqu DeleteDataset.</p> <p>Example: <pre><code>err := repo.Delete(\n    repo.SqlDelete().Where(\n        goqu.C(\"created_at\").Lt(time.Now().AddDate(-1, 0, 0)),\n    ),\n)\n</code></pre></p>"},{"location":"db/repository/#deletewhere","title":"DeleteWhere","text":"<pre><code>func (r *repository) DeleteWhere(fieldNameValue map[string]any) error\n</code></pre> <p>Deletes records matching field values. All conditions are combined with AND.</p> <p>Example: <pre><code>err := repo.DeleteWhere(map[string]any{\n    \"status\": \"inactive\",\n    \"verified\": false,\n})\n</code></pre></p>"},{"location":"db/repository/#deletebykey","title":"DeleteByKey","text":"<pre><code>func (r *repository) DeleteByKey(keyField string, value any) error\n</code></pre> <p>Deletes a record by a single key field.</p> <p>Example: <pre><code>err := repo.DeleteByKey(\"id\", 123)\n</code></pre></p>"},{"location":"db/repository/#gridops-interface","title":"GridOps Interface","text":"<p>The Repository also implements a GridOps interface that provides methods for working with data grids:</p> <pre><code>type GridOps interface {\n    Grid(record any) (*Grid, error)\n    QueryGrid(record any, args GridQuery, dest any) error\n}\n</code></pre> <ul> <li><code>Grid(record any) (*Grid, error)</code> - Creates a Grid object based on the provided record type, using field tags to determine which fields can be sorted, filtered, or searched</li> <li><code>QueryGrid(record any, args GridQuery, dest any) error</code> - Creates a Grid object and executes a query using the provided GridQuery parameters</li> </ul>"},{"location":"db/repository/#example-usage","title":"Example Usage","text":"<pre><code>type UserRecord struct {\n    ID       int    `db:\"id\" json:\"id\" grid:\"sort,filter\"`\n    Username string `db:\"username\" json:\"username\" grid:\"sort,search,filter\"`\n    Email    string `db:\"email\" json:\"email\" grid:\"sort,search,filter\"`\n    Active   bool   `db:\"active\" json:\"active\" grid:\"filter\"`\n}\n\nfunc main() {\n    // ... setup connection and repository as shown earlier ...\n    repo := db.NewRepository(context.Background(), client, \"users\")\n\n    // Create a GridQuery for searching and filtering\n    query, err := db.NewGridQuery(db.SearchAny, 10, 0)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Set search parameters\n    query.SearchText = \"john\"\n    query.FilterFields = map[string]any{\n        \"active\": true,\n    }\n    query.SortFields = map[string]string{\n        \"username\": db.SortAscending,\n    }\n\n    // Execute the query\n    var users []*UserRecord\n    if err := repo.QueryGrid(&amp;UserRecord{}, query, &amp;users); err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Printf(\"Found %d active users matching 'john'\\n\", len(users))\n\n    // Alternatively, create and configure a Grid manually\n    grid, err := repo.Grid(&amp;UserRecord{})\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Add custom filter function\n    grid.AddFilterFunc(\"active\", func(value any) (any, error) {\n        switch v := value.(type) {\n        case string:\n            switch v {\n            case \"yes\", \"true\", \"1\":\n                return true, nil\n            case \"no\", \"false\", \"0\":\n                return false, nil\n            default:\n                return nil, fmt.Errorf(\"invalid boolean value: %v\", v)\n            }\n        case bool:\n            return v, nil\n        default:\n            return nil, fmt.Errorf(\"unsupported type: %T\", value)\n        }\n    })\n\n    // Validate and build the query\n    if err := grid.ValidQuery(query); err != nil {\n        log.Fatal(err)\n    }\n\n    statement, err := grid.Build(repo.SqlSelect(), query)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Execute the query\n    var filteredUsers []*UserRecord\n    if err := repo.Fetch(statement, &amp;filteredUsers); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> <p>For more detailed information about grid functionality, see the Data Grid documentation.</p>"},{"location":"db/repository/#builder-interface","title":"Builder Interface","text":"<p>The Builder interface provides methods for creating SQL query builders:</p> <pre><code>type Builder interface {\n    Sql() goqu.DialectWrapper\n    SqlSelect() *goqu.SelectDataset\n    SqlInsert() *goqu.InsertDataset\n    SqlUpdate() *goqu.UpdateDataset\n    SqlDelete() *goqu.DeleteDataset\n}\n</code></pre>"},{"location":"db/repository/#sql","title":"Sql","text":"<pre><code>func (r *repository) Sql() goqu.DialectWrapper\n</code></pre> <p>Returns the goqu dialect wrapper for building custom queries.</p> <p>Example: <pre><code>dialect := repo.Sql()\ncustomQuery := dialect.From(\"users\").\n    InnerJoin(goqu.T(\"departments\"), goqu.On(goqu.C(\"users.dept_id\").Eq(goqu.C(\"departments.id\")))).\n    Select(\"users.*\", \"departments.name\")\n</code></pre></p>"},{"location":"db/repository/#sqlselect","title":"SqlSelect","text":"<pre><code>func (r *repository) SqlSelect() *goqu.SelectDataset\n</code></pre> <p>Returns a SELECT query builder for the repository's table.</p> <p>Example: <pre><code>query := repo.SqlSelect().\n    Where(goqu.C(\"active\").IsTrue()).\n    OrderBy(goqu.C(\"created_at\").Desc()).\n    Limit(10)\n\nvar users []*UserRecord\nerr := repo.Fetch(query, &amp;users)\n</code></pre></p>"},{"location":"db/repository/#sqlinsert","title":"SqlInsert","text":"<pre><code>func (r *repository) SqlInsert() *goqu.InsertDataset\n</code></pre> <p>Returns an INSERT query builder. Note: goqu prepared statements are not compatible with PostgreSQL extended types; use Insert() method or SqlBuilder() instead.</p> <p>Example: <pre><code>// Not recommended for PostgreSQL extended types\ninsertQuery := repo.SqlInsert().Rows(\n    goqu.Record{\"name\": \"John\", \"email\": \"john@example.com\"},\n)\n</code></pre></p>"},{"location":"db/repository/#sqlupdate","title":"SqlUpdate","text":"<pre><code>func (r *repository) SqlUpdate() *goqu.UpdateDataset\n</code></pre> <p>Returns an UPDATE query builder. Note: goqu prepared statements are not compatible with PostgreSQL extended types; use UpdateRecord() or SqlBuilder() instead.</p>"},{"location":"db/repository/#sqldelete","title":"SqlDelete","text":"<pre><code>func (r *repository) SqlDelete() *goqu.DeleteDataset\n</code></pre> <p>Returns a DELETE query builder for the repository's table.</p> <p>Example: <pre><code>deleteQuery := repo.SqlDelete().\n    Where(goqu.C(\"status\").Eq(\"deleted\")).\n    Where(goqu.C(\"deleted_at\").Lt(time.Now().AddDate(0, -1, 0)))\n\nerr := repo.Delete(deleteQuery)\n</code></pre></p>"},{"location":"db/repository/#sqlbuilder-interface","title":"SqlBuilder Interface","text":"<p>The SqlBuilder interface provides access to the modern query builder:</p> <pre><code>type SqlBuilder interface {\n    SqlDialect() qb.SqlDialect\n    SqlBuilder() *qb.SqlBuilder\n    SqlUpdateX(record any) *qb.UpdateBuilder\n    Do(qry any, target ...any) error\n}\n</code></pre>"},{"location":"db/repository/#sqldialect","title":"SqlDialect","text":"<pre><code>func (r *repository) SqlDialect() qb.SqlDialect\n</code></pre> <p>Returns the SQL dialect being used by the repository.</p> <p>Example: <pre><code>dialect := repo.SqlDialect()\nlog.Printf(\"Using dialect: %s\", dialect.Name())\n</code></pre></p>"},{"location":"db/repository/#sqlbuilder","title":"SqlBuilder","text":"<pre><code>func (r *repository) SqlBuilder() *qb.SqlBuilder\n</code></pre> <p>Returns the query builder instance for advanced SQL construction.</p> <p>Example: <pre><code>builder := repo.SqlBuilder()\n// Use builder for complex operations\n</code></pre></p>"},{"location":"db/repository/#sqlupdatex","title":"SqlUpdateX","text":"<pre><code>func (r *repository) SqlUpdateX(record any) *qb.UpdateBuilder\n</code></pre> <p>Creates an UpdateBuilder for the given record with advanced options.</p> <p>Example: <pre><code>user := &amp;UserRecord{Name: \"Updated Name\"}\nupdateBuilder := repo.SqlUpdateX(user).\n    WithOptions(&amp;qb.UpdateOptions{\n        IncludeFields: []string{\"name\", \"updated_at\"},\n        UpdateAutoFields: true,\n    }).\n    Where(qb.Eq(\"id\", 123))\n\nerr := repo.Do(updateBuilder)\n</code></pre></p>"},{"location":"db/repository/#do","title":"Do","text":"<pre><code>func (r *repository) Do(qry any, target ...any) error\n</code></pre> <p>Executes various query types (SELECT, UPDATE, INSERT, DELETE) with optional target for results.</p> <p>Example: <pre><code>// Execute UpdateBuilder\nupdateBuilder := repo.SqlUpdateX(user).Where(qb.Eq(\"id\", 123))\nerr := repo.Do(updateBuilder)\n\n// Execute with RETURNING\nupdateBuilder = repo.SqlUpdateX(user).\n    WithOptions(&amp;qb.UpdateOptions{\n        ReturningFields: []string{\"id\", \"updated_at\"},\n    }).\n    Where(qb.Eq(\"id\", 123))\n\nresult := &amp;UserRecord{}\nerr := repo.Do(updateBuilder, result)\n</code></pre></p>"},{"location":"db/repository/#transaction-support","title":"Transaction Support","text":"<p>The Repository supports database transactions through the Transaction interface:</p> <pre><code>type Transaction interface {\n    Builder\n    Reader\n    Executor\n    Writer\n    Deleter\n    Updater\n    Counter\n    SqlBuilder\n    Db() *sqlx.Tx\n    Name() string\n    Commit() error\n    Rollback() error\n}\n</code></pre>"},{"location":"db/repository/#creating-transactions","title":"Creating Transactions","text":"<pre><code>func (r *repository) NewTransaction(opts *sql.TxOptions) (Transaction, error)\n</code></pre> <p>Creates a new transaction with optional transaction options.</p> <p>Example: <pre><code>// Basic transaction\ntx, err := repo.NewTransaction(nil)\nif err != nil {\n    return err\n}\ndefer tx.Rollback() // Always defer rollback\n\n// Transaction with options\nopts := &amp;sql.TxOptions{\n    Isolation: sql.LevelSerializable,\n    ReadOnly:  false,\n}\ntx, err := repo.NewTransaction(opts)\n</code></pre></p>"},{"location":"db/repository/#using-transactions","title":"Using Transactions","text":"<p>Transactions implement all the same interfaces as Repository, allowing seamless operation:</p> <pre><code>func transferFunds(repo db.Repository, fromID, toID int, amount decimal.Decimal) error {\n    tx, err := repo.NewTransaction(nil)\n    if err != nil {\n        return err\n    }\n    defer tx.Rollback()\n\n    // Debit source account\n    err = tx.UpdateFields(\n        &amp;AccountRecord{},\n        map[string]any{\"balance\": goqu.L(\"balance - ?\", amount)},\n        map[string]any{\"id\": fromID},\n    )\n    if err != nil {\n        return fmt.Errorf(\"failed to debit account: %w\", err)\n    }\n\n    // Credit destination account\n    err = tx.UpdateFields(\n        &amp;AccountRecord{},\n        map[string]any{\"balance\": goqu.L(\"balance + ?\", amount)},\n        map[string]any{\"id\": toID},\n    )\n    if err != nil {\n        return fmt.Errorf(\"failed to credit account: %w\", err)\n    }\n\n    // Insert transaction record\n    txRecord := &amp;TransactionRecord{\n        FromAccountID: fromID,\n        ToAccountID:   toID,\n        Amount:        amount,\n        CreatedAt:     time.Now(),\n    }\n    if err := tx.Insert(txRecord); err != nil {\n        return fmt.Errorf(\"failed to record transaction: %w\", err)\n    }\n\n    // Commit the transaction\n    return tx.Commit()\n}\n</code></pre>"},{"location":"db/repository/#transaction-best-practices","title":"Transaction Best Practices","text":"<ol> <li>Always defer Rollback(): Even if you plan to commit, deferred rollback is a safety net</li> <li>Keep transactions short: Long-running transactions can cause lock contention</li> <li>Handle errors properly: Any error should trigger a rollback</li> <li>Use appropriate isolation levels: Choose based on your consistency requirements</li> </ol> <p>Example of complex transaction: <pre><code>func processOrder(repo db.Repository, orderID int) error {\n    tx, err := repo.NewTransaction(&amp;sql.TxOptions{\n        Isolation: sql.LevelReadCommitted,\n    })\n    if err != nil {\n        return err\n    }\n    defer tx.Rollback()\n\n    // Lock order for update\n    var order OrderRecord\n    err = tx.FetchRecord(\n        map[string]any{\"id\": orderID, \"status\": \"pending\"},\n        &amp;order,\n    )\n    if err != nil {\n        if db.EmptyResult(err) {\n            return errors.New(\"order not found or already processed\")\n        }\n        return err\n    }\n\n    // Process order items\n    var items []*OrderItemRecord\n    err = tx.FetchWhere(map[string]any{\"order_id\": orderID}, &amp;items)\n    if err != nil {\n        return err\n    }\n\n    for _, item := range items {\n        // Update inventory\n        err = tx.UpdateFields(\n            &amp;ProductRecord{},\n            map[string]any{\"stock\": goqu.L(\"stock - ?\", item.Quantity)},\n            map[string]any{\"id\": item.ProductID},\n        )\n        if err != nil {\n            return fmt.Errorf(\"failed to update inventory: %w\", err)\n        }\n    }\n\n    // Update order status\n    order.Status = \"completed\"\n    order.CompletedAt = time.Now()\n    err = tx.UpdateRecord(&amp;order, map[string]any{\"id\": orderID})\n    if err != nil {\n        return err\n    }\n\n    return tx.Commit()\n}\n</code></pre></p>"},{"location":"db/repository/#advanced-usage-patterns","title":"Advanced Usage Patterns","text":""},{"location":"db/repository/#custom-query-execution","title":"Custom Query Execution","text":"<pre><code>func customAggregation(repo db.Repository) error {\n    // Complex aggregation query\n    query := repo.SqlSelect().\n        Select(\n            goqu.C(\"department\"),\n            goqu.COUNT(\"*\").As(\"count\"),\n            goqu.AVG(\"salary\").As(\"avg_salary\"),\n            goqu.MAX(\"salary\").As(\"max_salary\"),\n        ).\n        GroupBy(\"department\").\n        Having(goqu.COUNT(\"*\").Gt(5)).\n        OrderBy(goqu.C(\"avg_salary\").Desc())\n\n    var results []struct {\n        Department string  `db:\"department\"`\n        Count      int     `db:\"count\"`\n        AvgSalary  float64 `db:\"avg_salary\"`\n        MaxSalary  float64 `db:\"max_salary\"`\n    }\n\n    return repo.Fetch(query, &amp;results)\n}\n</code></pre>"},{"location":"db/repository/#batch-insert-operations","title":"Batch Insert Operations","text":"<pre><code>func batchInsertWithProgress(repo db.Repository, users []*UserRecord) error {\n    const batchSize = 500\n    total := len(users)\n\n    for i := 0; i &lt; total; i += batchSize {\n        end := i + batchSize\n        if end &gt; total {\n            end = total\n        }\n\n        batch := users[i:end]\n        records := db.ToAnySlice(batch)\n\n        err := repo.Insert(records...)\n        if err != nil {\n            return fmt.Errorf(\"batch %d-%d failed: %w\", i, end-1, err)\n        }\n\n        progress := float64(end) / float64(total) * 100\n        log.Printf(\"Inserted %d-%d: %.1f%% complete\", i, end-1, progress)\n    }\n\n    return nil\n}\n\nfunc batchInsertWithErrorRecovery(repo db.Repository, users []*UserRecord) error {\n    var successful []string\n    var failed []struct {\n        User  *UserRecord\n        Error error\n    }\n\n    // Try batch insert first\n    records := db.ToAnySlice(users)\n    err := repo.Insert(records...)\n    if err == nil {\n        log.Printf(\"Successfully batch inserted %d users\", len(users))\n        return nil\n    }\n\n    log.Printf(\"Batch insert failed, trying individual inserts: %v\", err)\n\n    // Fall back to individual inserts\n    for _, user := range users {\n        err := repo.Insert(user)\n        if err != nil {\n            failed = append(failed, struct {\n                User  *UserRecord\n                Error error\n            }{user, err})\n        } else {\n            successful = append(successful, user.Name)\n        }\n    }\n\n    log.Printf(\"Individual inserts: %d successful, %d failed\", len(successful), len(failed))\n\n    if len(failed) &gt; 0 {\n        return fmt.Errorf(\"failed to insert %d records\", len(failed))\n    }\n\n    return nil\n}\n</code></pre>"},{"location":"db/repository/#batch-update-operations","title":"Batch Update Operations","text":"<pre><code>func batchUpdateWithProgress(repo db.Repository, updates []UserUpdate) error {\n    total := len(updates)\n    completed := 0\n\n    for i := 0; i &lt; total; i += 100 {\n        end := i + 100\n        if end &gt; total {\n            end = total\n        }\n\n        tx, err := repo.NewTransaction(nil)\n        if err != nil {\n            return err\n        }\n\n        for _, update := range updates[i:end] {\n            err := tx.UpdateByKey(&amp;update, \"id\", update.ID)\n            if err != nil {\n                tx.Rollback()\n                return fmt.Errorf(\"failed at record %d: %w\", update.ID, err)\n            }\n        }\n\n        if err := tx.Commit(); err != nil {\n            return err\n        }\n\n        completed = end\n        log.Printf(\"Progress: %d/%d (%.1f%%)\", completed, total, float64(completed)/float64(total)*100)\n    }\n\n    return nil\n}\n</code></pre>"},{"location":"db/repository/#repository-factory-pattern","title":"Repository Factory Pattern","text":"<pre><code>type RepositoryFactory struct {\n    client db.Client\n    ctx    context.Context\n}\n\nfunc NewRepositoryFactory(client db.Client) *RepositoryFactory {\n    return &amp;RepositoryFactory{\n        client: client,\n        ctx:    context.Background(),\n    }\n}\n\nfunc (f *RepositoryFactory) Users() db.Repository {\n    return db.NewRepository(f.ctx, f.client, \"users\")\n}\n\nfunc (f *RepositoryFactory) Orders() db.Repository {\n    return db.NewRepository(f.ctx, f.client, \"orders\")\n}\n\nfunc (f *RepositoryFactory) Products() db.Repository {\n    return db.NewRepository(f.ctx, f.client, \"products\")\n}\n\n// Usage\nfactory := NewRepositoryFactory(client)\nuserRepo := factory.Users()\norderRepo := factory.Orders()\n</code></pre>"},{"location":"db/repository/#performance-considerations","title":"Performance Considerations","text":""},{"location":"db/repository/#connection-pooling","title":"Connection Pooling","text":"<ul> <li>Repositories share the client's connection pool</li> <li>Configure pool size based on concurrent operations</li> <li>Monitor pool usage to avoid exhaustion</li> </ul>"},{"location":"db/repository/#query-optimization","title":"Query Optimization","text":"<ul> <li>Use appropriate indexes for WHERE clauses</li> <li>Batch operations when possible</li> <li>Use RETURNING clauses to avoid extra queries</li> <li>Consider pagination for large result sets</li> </ul>"},{"location":"db/repository/#caching","title":"Caching","text":"<ul> <li>Repository caches field specifications per struct type</li> <li>Grid specifications are cached after first use</li> <li>Consider application-level caching for frequently accessed data</li> </ul>"},{"location":"db/repository/#error-handling","title":"Error Handling","text":"<p>The Repository provides consistent error handling:</p> <pre><code>// Check for empty results\nuser := &amp;UserRecord{}\nerr := repo.FetchByKey(\"id\", 123, user)\nif err != nil {\n    if db.EmptyResult(err) {\n        // Handle not found case\n        return nil, ErrUserNotFound\n    }\n    // Handle actual error\n    return nil, fmt.Errorf(\"database error: %w\", err)\n}\n\n// Handle constraint violations\nerr = repo.Insert(user)\nif err != nil {\n    if isUniqueViolation(err) {\n        return ErrDuplicateEmail\n    }\n    return fmt.Errorf(\"insert failed: %w\", err)\n}\n</code></pre>"},{"location":"db/repository/#best-practices","title":"Best Practices","text":"<ol> <li>Use appropriate interfaces: Don't pass full Repository when only Reader is needed</li> <li>Leverage transactions: Group related operations in transactions</li> <li>Handle errors properly: Always check for EmptyResult on single record fetches</li> <li>Use struct tags: Properly tag structs for field mapping and grid functionality</li> <li>Batch operations: Use batch methods for bulk operations</li> <li>Monitor performance: Log slow queries and optimize as needed</li> </ol>"},{"location":"db/repository/#see-also","title":"See Also","text":"<ul> <li>Database Package Overview</li> <li>Structs and Tags</li> <li>Client Interface Documentation</li> <li>Query Builder Documentation</li> <li>Database Functions Documentation</li> <li>Field Specifications</li> <li>Data Grid System</li> <li>Migration System</li> </ul>"},{"location":"db/sql-update-api/","title":"UPDATE API Examples","text":"<p>This document shows examples of using the improved UPDATE API with pointer parameters instead of variadic options.</p> <p>All examples use the <code>github.com/oddbit-project/blueprint/db/sqlbuilder</code> package.</p>"},{"location":"db/sql-update-api/#basic-update-operations","title":"Basic UPDATE Operations","text":""},{"location":"db/sql-update-api/#simple-update-with-default-options","title":"Simple UPDATE with default options","text":"<pre><code>import \"github.com/oddbit-project/blueprint/db/sqlbuilder\"\n\nbuilder := sqlbuilder.NewSqlBuilder(sqlbuilder.DefaultSqlDialect())\n\nuser := User{\n    Name:     \"John Doe\",\n    Email:    \"john@example.com\",\n    Age:      30,\n    IsActive: true,\n}\n\nwhereConditions := []WhereCondition{\n    {Field: \"id\", Operator: \"=\", Value: 1},\n}\n\n// Use nil for default options\nsql, args, err := builder.BuildSQLUpdate(\"users\", user, whereConditions, nil)\n</code></pre>"},{"location":"db/sql-update-api/#update-with-custom-options","title":"UPDATE with custom options","text":"<pre><code>options := &amp;UpdateOptions{\n    IncludeFields: []string{\"Name\", \"Email\"},\n    IncludeZeroValues: true,\n}\n\nsql, args, err := builder.BuildSQLUpdate(\"users\", user, whereConditions, options)\n</code></pre>"},{"location":"db/sql-update-api/#update-by-id-with-default-options","title":"UPDATE by ID with default options","text":"<pre><code>// Use nil for default options\nsql, args, err := builder.BuildSQLUpdateByID(\"users\", user, 123, nil)\n</code></pre>"},{"location":"db/sql-update-api/#update-by-id-with-custom-options","title":"UPDATE by ID with custom options","text":"<pre><code>options := &amp;UpdateOptions{\n    ExcludeFields: []string{\"CreatedAt\", \"UpdatedAt\"},\n}\n\nsql, args, err := builder.BuildSQLUpdateByID(\"users\", user, 123, options)\n</code></pre>"},{"location":"db/sql-update-api/#batch-update-operations","title":"Batch UPDATE Operations","text":""},{"location":"db/sql-update-api/#batch-update-with-default-options","title":"Batch UPDATE with default options","text":"<pre><code>users := []any{\n    User{ID: 1, Name: \"User 1\", Email: \"user1@example.com\"},\n    User{ID: 2, Name: \"User 2\", Email: \"user2@example.com\"},\n    User{ID: 3, Name: \"User 3\", Email: \"user3@example.com\"},\n}\n\n// Use nil for default options\nstatements, argsList, err := builder.BuildSQLBatchUpdate(\"users\", users, []string{\"ID\"}, nil)\n</code></pre>"},{"location":"db/sql-update-api/#batch-update-with-custom-options","title":"Batch UPDATE with custom options","text":"<pre><code>options := &amp;UpdateOptions{\n    IncludeFields: []string{\"Name\", \"Email\"},\n    IncludeZeroValues: true,\n}\n\nstatements, argsList, err := builder.BuildSQLBatchUpdate(\"users\", users, []string{\"ID\"}, options)\n</code></pre>"},{"location":"db/sql-update-api/#advanced-examples","title":"Advanced Examples","text":""},{"location":"db/sql-update-api/#update-with-field-exclusion","title":"UPDATE with field exclusion","text":"<pre><code>options := &amp;UpdateOptions{\n    ExcludeFields: []string{\"CreatedAt\", \"UpdatedAt\", \"ID\"},\n}\n\nsql, args, err := builder.BuildSQLUpdate(\"users\", user, whereConditions, options)\n</code></pre>"},{"location":"db/sql-update-api/#update-with-zero-value-inclusion","title":"UPDATE with zero value inclusion","text":"<pre><code>options := &amp;UpdateOptions{\n    IncludeZeroValues: true,\n}\n\nsql, args, err := builder.BuildSQLUpdate(\"users\", user, whereConditions, options)\n</code></pre>"},{"location":"db/sql-update-api/#update-with-auto-field-updates","title":"UPDATE with auto field updates","text":"<pre><code>options := &amp;UpdateOptions{\n    UpdateAutoFields: true,\n    IncludeFields:    []string{\"Name\", \"Email\", \"UpdatedAt\"},\n}\n\nsql, args, err := builder.BuildSQLUpdate(\"users\", user, whereConditions, options)\n</code></pre>"},{"location":"db/sql-update-api/#benefits-of-pointer-parameters","title":"Benefits of Pointer Parameters","text":"<ol> <li>Clearer Intent: <code>nil</code> clearly indicates default options</li> <li>No Ambiguity: No confusion about multiple options</li> <li>Memory Efficient: Options are passed by reference</li> <li>Go Idiomatic: Follows Go conventions for optional parameters</li> <li>Type Safety: Compile-time checking of parameter types</li> </ol>"},{"location":"db/sql-update-api/#migration-from-variadic-parameters","title":"Migration from Variadic Parameters","text":""},{"location":"db/sql-update-api/#before-variadic","title":"Before (Variadic)","text":"<pre><code>// Multiple ways to call, confusing\nbuilder.BuildSQLUpdate(\"users\", user, whereConditions) // no options\nbuilder.BuildSQLUpdate(\"users\", user, whereConditions, options) // with options\nbuilder.BuildSQLUpdate(\"users\", user, whereConditions, DefaultUpdateOptions()) // explicit default\n</code></pre>"},{"location":"db/sql-update-api/#after-pointer","title":"After (Pointer)","text":"<pre><code>// Clear, consistent API\nbuilder.BuildSQLUpdate(\"users\", user, whereConditions, nil) // default options\nbuilder.BuildSQLUpdate(\"users\", user, whereConditions, &amp;options) // custom options\n</code></pre>"},{"location":"db/sql-update-api/#see-also","title":"See Also","text":"<ul> <li>Database Package Overview</li> <li>Query Builder Documentation</li> <li>Repository Documentation</li> <li>Database Functions</li> <li>Field Specifications</li> </ul>"},{"location":"db/structs-and-tags/","title":"Database Structs and Tags","text":"<p>The Blueprint database package is designed around struct-based operations. This document covers how to create and configure structs for database interaction using the comprehensive tag system.</p>"},{"location":"db/structs-and-tags/#overview","title":"Overview","text":"<p>The Blueprint db package uses Go structs to represent database tables and records. Struct fields are mapped to database columns through a sophisticated tag system that controls:</p> <ul> <li>Database field mapping</li> <li>Query behavior (insert/update operations)</li> <li>Grid functionality (sorting, filtering, searching)</li> <li>Data serialization and aliases</li> <li>Field metadata and validation</li> </ul>"},{"location":"db/structs-and-tags/#basic-struct-definition","title":"Basic Struct Definition","text":""},{"location":"db/structs-and-tags/#simple-example","title":"Simple Example","text":"<pre><code>type User struct {\n    ID        int       `db:\"id\"`\n    Name      string    `db:\"name\"`\n    Email     string    `db:\"email\"`\n    CreatedAt time.Time `db:\"created_at\"`\n}\n</code></pre>"},{"location":"db/structs-and-tags/#complete-example-with-all-tags","title":"Complete Example with All Tags","text":"<pre><code>type User struct {\n    ID          int       `db:\"id\" json:\"id\" goqu:\"skipinsert\" grid:\"sort,filter\" alias:\"userId\"`\n    Name        string    `db:\"name\" json:\"name\" grid:\"sort,search,filter\"`\n    Email       string    `db:\"email\" json:\"email\" grid:\"search,filter\"`\n    Phone       string    `db:\"phone\" json:\"phone,omitempty\" goqu:\"omitempty\"`\n    IsActive    bool      `db:\"is_active\" json:\"isActive\" grid:\"filter\" ch:\"is_active\"`\n    CreatedAt   time.Time `db:\"created_at\" json:\"createdAt\" goqu:\"skipupdate\" grid:\"sort\"`\n    UpdatedAt   time.Time `db:\"updated_at\" json:\"updatedAt\" auto:\"true\"`\n    DeletedAt   *time.Time `db:\"deleted_at\" json:\"deletedAt,omitempty\" goqu:\"omitnil\"`\n    ProfileData string    `db:\"profile_data\" json:\"-\" mapper:\"json\"`\n}\n</code></pre>"},{"location":"db/structs-and-tags/#database-field-tags","title":"Database Field Tags","text":""},{"location":"db/structs-and-tags/#db-tag-primary","title":"<code>db</code> Tag (Primary)","text":"<p>The primary tag for mapping struct fields to database columns.</p> <pre><code>type User struct {\n    ID    int    `db:\"id\"`           // Maps to 'id' column\n    Name  string `db:\"user_name\"`    // Maps to 'user_name' column\n    Email string `db:\"email\"`        // Maps to 'email' column\n}\n</code></pre> <p>Special Values: - <code>db:\"-\"</code> - Excludes field from database operations entirely</p> <pre><code>type User struct {\n    ID       int    `db:\"id\"`\n    Name     string `db:\"name\"`\n    Internal string `db:\"-\"`  // Not persisted to database\n}\n</code></pre>"},{"location":"db/structs-and-tags/#ch-tag-clickhouse-alternative","title":"<code>ch</code> Tag (ClickHouse Alternative)","text":"<p>Alternative database tag specifically for ClickHouse databases. When present, it takes precedence over the <code>db</code> tag for ClickHouse operations.</p> <pre><code>type Event struct {\n    ID        int       `db:\"id\" ch:\"event_id\"`\n    Timestamp time.Time `db:\"created_at\" ch:\"timestamp\"`\n    Data      string    `db:\"data\" ch:\"event_data\"`\n}\n</code></pre>"},{"location":"db/structs-and-tags/#query-behavior-tags","title":"Query Behavior Tags","text":""},{"location":"db/structs-and-tags/#goqu-tag","title":"<code>goqu</code> Tag","text":"<p>Controls query generation behavior for insert and update operations.</p> <pre><code>type User struct {\n    ID        int       `db:\"id\" goqu:\"skipinsert\"`     // Never included in INSERT\n    CreatedAt time.Time `db:\"created_at\" goqu:\"skipupdate\"` // Never included in UPDATE\n    Phone     string    `db:\"phone\" goqu:\"omitempty\"`   // Skip if empty string\n    Address   *string   `db:\"address\" goqu:\"omitnil\"`   // Skip if nil pointer\n}\n</code></pre> <p>Available Options: - <code>skipinsert</code> - Exclude from INSERT operations (auto-generated fields) - <code>skipupdate</code> - Exclude from UPDATE operations (immutable fields) - <code>omitempty</code> - Skip field if it has zero value (empty string, 0, false) - <code>omitnil</code> - Skip field if it's nil (for pointer types)</p>"},{"location":"db/structs-and-tags/#auto-tag","title":"<code>auto</code> Tag","text":"<p>Marks fields as automatically generated or managed by the database/application.</p> <pre><code>type User struct {\n    ID        int       `db:\"id\" auto:\"true\"`        // Auto-generated ID\n    CreatedAt time.Time `db:\"created_at\" auto:\"true\"` // Auto-set timestamp\n    UpdatedAt time.Time `db:\"updated_at\" auto:\"true\"` // Auto-updated timestamp\n}\n</code></pre> <p>Effect: Fields marked with <code>auto:\"true\"</code> are treated the same as <code>goqu:\"skipinsert,skipupdate\"</code>.</p>"},{"location":"db/structs-and-tags/#grid-system-tags","title":"Grid System Tags","text":""},{"location":"db/structs-and-tags/#grid-tag","title":"<code>grid</code> Tag","text":"<p>Configures fields for use with the Grid system (dynamic queries, filtering, sorting, searching).</p> <pre><code>type User struct {\n    ID       int    `db:\"id\" grid:\"sort,filter\"`           // Sortable and filterable\n    Name     string `db:\"name\" grid:\"sort,search,filter\"`  // All grid operations\n    Email    string `db:\"email\" grid:\"search,filter\"`      // Searchable and filterable\n    IsActive bool   `db:\"is_active\" grid:\"filter\"`         // Filterable only\n    Internal string `db:\"internal\"`                        // No grid operations\n}\n</code></pre> <p>Available Options: - <code>sort</code> - Field can be used for sorting results - <code>search</code> - Field is included in text search operations - <code>filter</code> - Field can be used for filtering/WHERE clauses - <code>auto</code> - Equivalent to <code>auto:\"true\"</code> (marks as auto-generated)</p> <p>Usage Example: <pre><code>query, _ := db.NewGridQuery(db.SearchAny, 10, 0)\nquery.SearchText = \"john\"                    // Searches 'name' and 'email' fields\nquery.FilterFields = map[string]any{         // Filters on 'id' and 'is_active'\n    \"id\": 123,\n    \"isActive\": true,\n}\nquery.SortFields = map[string]string{        // Sorts by 'name' and 'id'\n    \"name\": db.SortAscending,\n    \"id\": db.SortDescending,\n}\n</code></pre></p>"},{"location":"db/structs-and-tags/#alias-and-serialization-tags","title":"Alias and Serialization Tags","text":""},{"location":"db/structs-and-tags/#json-tag","title":"<code>json</code> Tag","text":"<p>Standard JSON serialization tag, also used for field aliasing in Grid operations.</p> <pre><code>type User struct {\n    ID       int    `db:\"id\" json:\"id\"`\n    Name     string `db:\"name\" json:\"userName\"`      // JSON uses \"userName\"\n    Email    string `db:\"email\" json:\"email\"`\n    Internal string `db:\"internal\" json:\"-\"`         // Excluded from JSON\n    Optional string `db:\"optional\" json:\"optional,omitempty\"`\n}\n</code></pre> <p>Grid Integration: The JSON field names are used as aliases in Grid queries: <pre><code>// Grid query can use JSON field names\nquery.FilterFields = map[string]any{\n    \"userName\": \"John Doe\",  // Maps to 'name' database field\n    \"id\": 123,               // Maps to 'id' database field\n}\n</code></pre></p>"},{"location":"db/structs-and-tags/#xml-tag","title":"<code>xml</code> Tag","text":"<p>XML serialization tag, also used for field aliasing.</p> <pre><code>type User struct {\n    ID   int    `db:\"id\" xml:\"userId\"`\n    Name string `db:\"name\" xml:\"userName\"`\n}\n</code></pre>"},{"location":"db/structs-and-tags/#alias-tag","title":"<code>alias</code> Tag","text":"<p>Explicit alias for field names in Grid operations and API responses.</p> <pre><code>type User struct {\n    ID   int    `db:\"id\" alias:\"userId\"`      // Grid uses \"userId\"\n    Name string `db:\"name\" alias:\"fullName\"`  // Grid uses \"fullName\"\n}\n</code></pre> <p>Precedence: <code>alias</code> &gt; <code>json</code> &gt; <code>xml</code> &gt; field name</p>"},{"location":"db/structs-and-tags/#advanced-tags","title":"Advanced Tags","text":""},{"location":"db/structs-and-tags/#mapper-tag","title":"<code>mapper</code> Tag","text":"<p>Specifies custom field transformation or mapping behavior.</p> <pre><code>type User struct {\n    Preferences map[string]any `db:\"preferences\" mapper:\"json\"`  // JSON encode/decode\n    Tags        []string       `db:\"tags\" mapper:\"csv\"`          // CSV encode/decode\n    Metadata    interface{}    `db:\"metadata\" mapper:\"custom\"`   // Custom mapper\n}\n</code></pre> <p>Common Mappers: - <code>json</code> - JSON serialization for complex types - <code>csv</code> - Comma-separated values for slices - <code>custom</code> - Application-defined transformation</p>"},{"location":"db/structs-and-tags/#complete-tag-reference","title":"Complete Tag Reference","text":""},{"location":"db/structs-and-tags/#tag-priority-order","title":"Tag Priority Order","text":"<p>When multiple tags define the same property, the priority is: 1. <code>alias</code> (explicit alias) 2. <code>json</code> (JSON field name) 3. <code>xml</code> (XML field name) 4. Struct field name (default)</p>"},{"location":"db/structs-and-tags/#field-processing-rules","title":"Field Processing Rules","text":"<ol> <li>Database Field Name:</li> <li><code>ch</code> tag (for ClickHouse)</li> <li><code>db</code> tag</li> <li> <p>Struct field name (fallback)</p> </li> <li> <p>Alias/Display Name:</p> </li> <li><code>alias</code> tag</li> <li><code>json</code> tag</li> <li><code>xml</code> tag</li> <li> <p>Struct field name (fallback)</p> </li> <li> <p>Query Behavior:</p> </li> <li><code>goqu</code> tag options</li> <li><code>auto</code> tag</li> <li> <p>Default behavior</p> </li> <li> <p>Grid Capabilities:</p> </li> <li><code>grid</code> tag options</li> <li>No capabilities (default)</li> </ol>"},{"location":"db/structs-and-tags/#struct-composition-and-embedding","title":"Struct Composition and Embedding","text":""},{"location":"db/structs-and-tags/#embedded-structs","title":"Embedded Structs","text":"<pre><code>type BaseModel struct {\n    ID        int       `db:\"id\" goqu:\"skipinsert\" grid:\"sort,filter\"`\n    CreatedAt time.Time `db:\"created_at\" goqu:\"skipupdate\" grid:\"sort\"`\n    UpdatedAt time.Time `db:\"updated_at\" auto:\"true\"`\n}\n\ntype User struct {\n    BaseModel                                    // Embedded struct\n    Name      string `db:\"name\" grid:\"sort,search,filter\"`\n    Email     string `db:\"email\" grid:\"search,filter\"`\n}\n\ntype Product struct {\n    BaseModel                                    // Same base fields\n    Title       string          `db:\"title\" grid:\"sort,search,filter\"`\n    Price       decimal.Decimal `db:\"price\" grid:\"sort,filter\"`\n    Description string          `db:\"description\" grid:\"search\"`\n}\n</code></pre> <p>Rules for Embedded Structs: - All exported fields from embedded structs are included - Tags from embedded struct fields are preserved - Anonymous embedding only (named embedding is ignored) - Conflicts result in error (same database field name)</p>"},{"location":"db/structs-and-tags/#pointer-embedding","title":"Pointer Embedding","text":"<pre><code>type User struct {\n    *BaseModel  // Pointer embedding - IGNORED by field scanner\n    Name string `db:\"name\"`\n}\n</code></pre> <p>Note: Pointer-to-struct embedding is skipped during field scanning.</p>"},{"location":"db/structs-and-tags/#best-practices","title":"Best Practices","text":""},{"location":"db/structs-and-tags/#naming-conventions","title":"Naming Conventions","text":"<pre><code>type User struct {\n    // Database: snake_case, Struct: PascalCase, JSON: camelCase\n    UserID      int    `db:\"user_id\" json:\"userId\"`\n    FirstName   string `db:\"first_name\" json:\"firstName\"`\n    LastName    string `db:\"last_name\" json:\"lastName\"`\n    EmailAddr   string `db:\"email_address\" json:\"emailAddress\"`\n}\n</code></pre>"},{"location":"db/structs-and-tags/#auto-generated-fields","title":"Auto-Generated Fields","text":"<pre><code>type BaseEntity struct {\n    ID        int       `db:\"id\" goqu:\"skipinsert\" grid:\"sort,filter\"`\n    CreatedAt time.Time `db:\"created_at\" goqu:\"skipupdate\" grid:\"sort\"`\n    UpdatedAt time.Time `db:\"updated_at\" auto:\"true\"`\n}\n</code></pre>"},{"location":"db/structs-and-tags/#grid-enabled-structs","title":"Grid-Enabled Structs","text":"<pre><code>type SearchableUser struct {\n    ID          int     `db:\"id\" json:\"id\" grid:\"sort,filter\"`\n    Name        string  `db:\"name\" json:\"name\" grid:\"sort,search,filter\"`\n    Email       string  `db:\"email\" json:\"email\" grid:\"search,filter\"`\n    Department  string  `db:\"department\" json:\"department\" grid:\"filter\"`\n    Salary      float64 `db:\"salary\" json:\"salary\" grid:\"sort,filter\"`\n    IsActive    bool    `db:\"is_active\" json:\"isActive\" grid:\"filter\"`\n    HireDate    time.Time `db:\"hire_date\" json:\"hireDate\" grid:\"sort,filter\"`\n}\n</code></pre>"},{"location":"db/structs-and-tags/#nullable-fields","title":"Nullable Fields","text":"<pre><code>type User struct {\n    ID          int        `db:\"id\"`\n    Name        string     `db:\"name\"`\n    Email       *string    `db:\"email\" goqu:\"omitnil\"`        // Nullable string\n    PhoneNumber *string    `db:\"phone_number\" goqu:\"omitnil\"` // Nullable string\n    LastLogin   *time.Time `db:\"last_login\" goqu:\"omitnil\"`   // Nullable timestamp\n}\n</code></pre>"},{"location":"db/structs-and-tags/#common-patterns","title":"Common Patterns","text":""},{"location":"db/structs-and-tags/#audit-fields","title":"Audit Fields","text":"<pre><code>type AuditFields struct {\n    CreatedAt time.Time  `db:\"created_at\" goqu:\"skipupdate\" grid:\"sort\"`\n    UpdatedAt time.Time  `db:\"updated_at\" auto:\"true\"`\n    CreatedBy int        `db:\"created_by\" goqu:\"skipupdate\"`\n    UpdatedBy *int       `db:\"updated_by\" goqu:\"omitnil\"`\n}\n\ntype User struct {\n    ID    int    `db:\"id\" goqu:\"skipinsert\" grid:\"sort,filter\"`\n    Name  string `db:\"name\" grid:\"sort,search,filter\"`\n    Email string `db:\"email\" grid:\"search,filter\"`\n    AuditFields\n}\n</code></pre>"},{"location":"db/structs-and-tags/#soft-delete","title":"Soft Delete","text":"<pre><code>type SoftDelete struct {\n    DeletedAt *time.Time `db:\"deleted_at\" goqu:\"omitnil\"`\n    DeletedBy *int       `db:\"deleted_by\" goqu:\"omitnil\"`\n}\n\ntype User struct {\n    ID    int    `db:\"id\" goqu:\"skipinsert\"`\n    Name  string `db:\"name\"`\n    Email string `db:\"email\"`\n    SoftDelete\n}\n</code></pre>"},{"location":"db/structs-and-tags/#multi-database-support","title":"Multi-Database Support","text":"<pre><code>type Event struct {\n    ID        int       `db:\"id\" ch:\"event_id\"`                    // Different field names\n    Timestamp time.Time `db:\"created_at\" ch:\"timestamp\"`           // per database\n    UserID    int       `db:\"user_id\" ch:\"user_id\"`\n    EventType string    `db:\"event_type\" ch:\"event_type\"`\n    Data      string    `db:\"data\" ch:\"event_data\" mapper:\"json\"`  // JSON in both\n}\n</code></pre>"},{"location":"db/structs-and-tags/#jsoncomplex-fields","title":"JSON/Complex Fields","text":"<pre><code>type User struct {\n    ID          int                    `db:\"id\"`\n    Name        string                 `db:\"name\"`\n    Preferences map[string]interface{} `db:\"preferences\" mapper:\"json\"`\n    Tags        []string               `db:\"tags\" mapper:\"json\"`\n    Metadata    interface{}            `db:\"metadata\" mapper:\"json\"`\n}\n</code></pre>"},{"location":"db/structs-and-tags/#validation-and-error-handling","title":"Validation and Error Handling","text":""},{"location":"db/structs-and-tags/#field-validation","title":"Field Validation","text":"<p>The field metadata system performs validation:</p> <pre><code>type User struct {\n    ID    int    `db:\"id\"`\n    Name  string `db:\"name\"`\n    Email string `db:\"id\"`  // ERROR: duplicate field name\n}\n</code></pre> <p>Common Errors: - Duplicate database field names - Duplicate alias names - Invalid tag syntax - Unsupported field types for certain operations</p>"},{"location":"db/structs-and-tags/#reserved-types","title":"Reserved Types","text":"<p>Some types are treated specially and cannot be decomposed:</p> <pre><code>type User struct {\n    ID        int       `db:\"id\"`\n    CreatedAt time.Time `db:\"created_at\"`  // Reserved type - treated as single field\n    Config    MyStruct  `db:\"config\"`      // Custom struct - decomposed if not reserved\n}\n</code></pre> <p>Reserved Types: - <code>time.Time</code> - <code>sql.NullString</code>, <code>sql.NullInt64</code>, etc. - <code>decimal.Decimal</code> (if using shopspring/decimal) - Database-specific types (e.g., PostgreSQL arrays, JSON types)</p>"},{"location":"db/structs-and-tags/#testing-struct-definitions","title":"Testing Struct Definitions","text":""},{"location":"db/structs-and-tags/#validation-example","title":"Validation Example","text":"<pre><code>func TestUserStructMetadata(t *testing.T) {\n    user := &amp;User{}\n\n    // Test field metadata extraction\n    metadata, err := field.GetStructMeta(reflect.TypeOf(user).Elem())\n    assert.NoError(t, err)\n\n    // Validate expected fields\n    expectedFields := []string{\"id\", \"name\", \"email\", \"created_at\"}\n    actualFields := make([]string, len(metadata))\n    for i, m := range metadata {\n        actualFields[i] = m.DbName\n    }\n\n    assert.ElementsMatch(t, expectedFields, actualFields)\n\n    // Test grid capabilities\n    grid, err := db.NewGrid(\"users\", user)\n    assert.NoError(t, err)\n\n    sortFields := grid.SortFields()\n    assert.Contains(t, sortFields, \"id\")\n    assert.Contains(t, sortFields, \"name\")\n}\n</code></pre>"},{"location":"db/structs-and-tags/#integration-testing","title":"Integration Testing","text":"<pre><code>func TestUserRepository(t *testing.T) {\n    // Setup test database\n    client := setupTestDB(t)\n    repo := db.NewRepository(context.Background(), client, \"users\")\n\n    user := &amp;User{\n        Name:  \"John Doe\",\n        Email: \"john@example.com\",\n    }\n\n    // Test insert\n    err := repo.Insert(user)\n    assert.NoError(t, err)\n\n    // Test fetch\n    var users []*User\n    err = repo.Fetch(repo.SqlSelect(), &amp;users)\n    assert.NoError(t, err)\n    assert.Len(t, users, 1)\n\n    // Test grid operations\n    query, _ := db.NewGridQuery(db.SearchAny, 10, 0)\n    query.SearchText = \"john\"\n\n    var searchResults []*User\n    err = repo.QueryGrid(user, query, &amp;searchResults)\n    assert.NoError(t, err)\n}\n</code></pre>"},{"location":"db/structs-and-tags/#performance-considerations","title":"Performance Considerations","text":""},{"location":"db/structs-and-tags/#field-metadata-caching","title":"Field Metadata Caching","text":"<p>The system automatically caches field metadata:</p> <pre><code>// First call - extracts and caches metadata\ngrid1, err := db.NewGrid(\"users\", &amp;User{})\n\n// Subsequent calls - uses cached metadata\ngrid2, err := db.NewGrid(\"users\", &amp;User{}) // Fast - uses cache\n</code></pre>"},{"location":"db/structs-and-tags/#large-structs","title":"Large Structs","text":"<p>For structs with many fields, consider:</p> <pre><code>type User struct {\n    // Core fields with grid support\n    ID       int    `db:\"id\" grid:\"sort,filter\"`\n    Name     string `db:\"name\" grid:\"sort,search,filter\"`\n    Email    string `db:\"email\" grid:\"search,filter\"`\n\n    // Extended fields without grid support (reduces metadata size)\n    Address1    string `db:\"address1\"`\n    Address2    string `db:\"address2\"`\n    City        string `db:\"city\"`\n    State       string `db:\"state\"`\n    PostalCode  string `db:\"postal_code\"`\n    Country     string `db:\"country\"`\n\n    // Audit fields\n    CreatedAt time.Time `db:\"created_at\" goqu:\"skipupdate\"`\n    UpdatedAt time.Time `db:\"updated_at\" auto:\"true\"`\n}\n</code></pre>"},{"location":"db/structs-and-tags/#troubleshooting","title":"Troubleshooting","text":""},{"location":"db/structs-and-tags/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Field Not Found in Grid Operations <pre><code>// Problem: Field not marked for grid operations\ntype User struct {\n    Name string `db:\"name\"` // Missing grid tag\n}\n\n// Solution: Add grid tag\ntype User struct {\n    Name string `db:\"name\" grid:\"search,filter\"`\n}\n</code></pre></p> </li> <li> <p>Insert/Update Including Auto Fields <pre><code>// Problem: Auto field included in operations\ntype User struct {\n    ID int `db:\"id\"` // Should be auto-generated\n}\n\n// Solution: Mark as auto or skip\ntype User struct {\n    ID int `db:\"id\" goqu:\"skipinsert\"` // or auto:\"true\"\n}\n</code></pre></p> </li> <li> <p>JSON Alias Conflicts <pre><code>// Problem: JSON and database names conflict\ntype User struct {\n    UserID int `db:\"user_id\" json:\"id\"` // JSON uses \"id\"\n    ID     int `db:\"id\" json:\"userId\"`  // Confusing aliases\n}\n\n// Solution: Use consistent naming\ntype User struct {\n    ID     int `db:\"id\" json:\"id\"`\n    UserID int `db:\"user_id\" json:\"userId\"`\n}\n</code></pre></p> </li> </ol>"},{"location":"db/structs-and-tags/#see-also","title":"See Also","text":"<ul> <li>Database Package Overview</li> <li>Repository Documentation</li> <li>Field Specifications</li> <li>Data Grid System</li> <li>Query Builder Documentation</li> </ul>"},{"location":"log/file_logging/","title":"File Logging","text":"<p>The Blueprint framework includes support for logging to files in addition to console output. This allows for persistent logs that can be reviewed and analyzed after the application has exited.</p>"},{"location":"log/file_logging/#basic-configuration","title":"Basic Configuration","text":"<p>To enable file logging in your application, configure the logger with the appropriate file output settings:</p> <pre><code>// Create a logger configuration\nlogConfig := log.NewDefaultConfig()\n\n// Enable file logging with a specific path\nlog.EnableFileOutput(logConfig, \"/path/to/logs/application.log\")\n\n// Configure the logger\nif err := log.Configure(logConfig); err != nil {\n    // Handle configuration error\n}\n</code></pre>"},{"location":"log/file_logging/#file-output-options","title":"File Output Options","text":"<p>The logger provides several configuration options for file output:</p> Option Description Default <code>FileOutput</code> Whether to enable file logging <code>false</code> <code>FilePath</code> Path to the log file <code>application.log</code> <code>FileFormat</code> Output format, either \"json\" or \"console\" <code>json</code> <code>FileAppend</code> Whether to append to an existing file <code>true</code> <code>FilePermissions</code> File permissions <code>0644</code>"},{"location":"log/file_logging/#helper-functions","title":"Helper Functions","text":"<p>The logger provides helper functions to simplify configuration:</p>"},{"location":"log/file_logging/#enablefileoutput","title":"EnableFileOutput","text":"<p>Enables file logging with the specified file path:</p> <pre><code>config := log.NewDefaultConfig()\nconfig = log.EnableFileOutput(config, \"/path/to/logs/app.log\")\n</code></pre>"},{"location":"log/file_logging/#setfileformat","title":"SetFileFormat","text":"<p>Sets the output format for file logging:</p> <pre><code>// For human-readable console-like format\nconfig = log.SetFileFormat(config, \"console\")\n\n// For structured JSON format (better for log processing)\nconfig = log.SetFileFormat(config, \"json\")\n</code></pre>"},{"location":"log/file_logging/#disablefileappend","title":"DisableFileAppend","text":"<p>By default, logs are appended to existing files. Use this function to overwrite existing files instead:</p> <pre><code>config = log.DisableFileAppend(config)\n</code></pre>"},{"location":"log/file_logging/#file-rotation","title":"File Rotation","text":"<p>The Blueprint logger doesn't include built-in log rotation. For production environments, consider using these approaches:</p> <ol> <li>Create a new log file with a timestamp for each application run</li> <li>Use an external log rotation solution like logrotate</li> <li>Integrate a third-party log rotation library</li> </ol>"},{"location":"log/file_logging/#cleanup","title":"Cleanup","text":"<p>The logger manages open file handles internally. However, for clean shutdowns, you can explicitly close log files:</p> <pre><code>// Before application exit\nlog.CloseLogFiles()\n</code></pre>"},{"location":"log/file_logging/#console-and-file-simultaneously","title":"Console and File Simultaneously","text":"<p>When file logging is enabled, log messages are sent to both the console and the file by default. This makes it easy to see logs in real-time while also preserving them for later analysis.</p>"},{"location":"log/file_logging/#example","title":"Example","text":"<p>Here's a complete example of setting up file logging:</p> <pre><code>package main\n\nimport (\n    \"github.com/oddbit-project/blueprint/log\"\n    \"os\"\n    \"path/filepath\"\n    \"time\"\n)\n\nfunc main() {\n    // Create logs directory\n    os.MkdirAll(\"logs\", 0755)\n\n    // Timestamp-based filename\n    timestamp := time.Now().Format(\"2006-01-02_15-04-05\")\n    logFilePath := filepath.Join(\"logs\", \"app_\" + timestamp + \".log\")\n\n    // Configure logger\n    config := log.NewDefaultConfig()\n    config = log.EnableFileOutput(config, logFilePath)\n    config = log.SetFileFormat(config, \"json\")  // Structured JSON format\n\n    if err := log.Configure(config); err != nil {\n        panic(err)\n    }\n\n    // Create a logger\n    logger := log.New(\"myapp\")\n\n    // Log some messages\n    logger.Info(\"Application started\")\n\n    // Log with structured fields\n    logger.Info(\"User authenticated\", log.KV{\n        \"user_id\": 12345,\n        \"role\":    \"admin\",\n    })\n\n    // Clean up\n    log.CloseLogFiles()\n}\n</code></pre>"},{"location":"log/file_logging/#best-practices","title":"Best Practices","text":"<ol> <li>Use structured logging: JSON format is better for log processing and analysis tools</li> <li>Include contextual information: Use key-value pairs to provide context</li> <li>Create log directories: Ensure log directories exist before configuring the logger</li> <li>Use timestamp-based filenames: For applications without long-running sessions</li> <li>Set appropriate log levels: Use Debug for development and Info for production</li> <li>Close log files: Call <code>CloseLogFiles()</code> during application shutdown</li> </ol>"},{"location":"log/logging/","title":"Logging System","text":"<p>Blueprint provides a structured logging system built on top of zerolog that offers consistent logging patterns across different components.</p>"},{"location":"log/logging/#features","title":"Features","text":"<ul> <li>Structured logging with standardized field names</li> <li>Context-aware logging for tracking requests across multiple services</li> <li>Distributed tracing with trace and request IDs</li> <li>Component-specific logging for HTTP and Kafka operations</li> <li>Log levels for different severity of messages</li> <li>Performance-oriented with minimal allocations</li> </ul>"},{"location":"log/logging/#basic-usage","title":"Basic Usage","text":"<pre><code>import \"github.com/oddbit-project/blueprint/log\"\n\n// Create a logger for a module\nlogger := log.New(\"mymodule\")\n\n// Log messages at different levels\nlogger.Info(\"Application started\", log.KV{\n    \"version\": \"1.0.0\",\n})\n\nlogger.Debug(\"Processing item\", log.KV{\n    \"item_id\": 123,\n})\n\n// Log errors with stack traces\nerr := someOperation()\nif err != nil {\n    logger.Error(err, \"Failed to process item\", log.KV{\n        \"item_id\": 123,\n    })\n}\n</code></pre>"},{"location":"log/logging/#context-aware-logging","title":"Context-Aware Logging","text":"<pre><code>import \"github.com/oddbit-project/blueprint/log\"\n\n// Create a request context with trace ID\nctx, logger := log.NewRequestContext(context.Background(), \"api\")\n\n// Add fields to the logger\nctx = log.WithField(ctx, \"user_id\", userId)\n\n// Log using the context\nlog.Info(ctx, \"Processing user request\")\n\n// Pass the context to other functions\nprocessRequest(ctx, request)\n\n// In other functions, retrieve the logger from context\nfunc processRequest(ctx context.Context, req Request) {\n    logger := log.FromContext(ctx)\n    logger.Info(\"Processing request details\")\n\n    // Or use helper functions\n    log.Info(ctx, \"Alternative way to log\")\n}\n</code></pre>"},{"location":"log/logging/#http-request-logging","title":"HTTP Request Logging","text":"<pre><code>import (\n    \"github.com/gin-gonic/gin\"\n    \"github.com/oddbit-project/blueprint/log\"\n    \"github.com/oddbit-project/provider/httpserver\"\n)\n\n// Use the HTTP logging middleware\nrouter.Use(httpserver.HTTPLogMiddleware(\"api\"))\n\n// Log within handlers\nfunc handler(c *gin.Context) {\n    // Get the request logger\n    logger := httpserver.GetRequestLogger(c)\n\n    // Or use helper functions\n    httpserver.RequestInfo(c, \"Processing API request\", log.KV{\n        \"request_data\": someData,\n    })\n\n    // Error handling\n    if err := someOperation(); err != nil {\n        httpserver.RequestError(c, err, \"Operation failed\")\n        return\n    }\n}\n</code></pre>"},{"location":"log/logging/#kafka-message-logging","title":"Kafka Message Logging","text":"<p>Kafka consumer example: <pre><code>import (\n    \"context\"\n    \"github.com/oddbit-project/blueprint/log\"\n    \"github.com/oddbit-project/blueprint/provider/kafka\"\n)\n\nctx := context.Background()\n\n// Producer logging\nproducer, _ := kafka.NewProducer(cfg, nil)\nerr := producer.WriteJson(ctx, data)\n\n// Consumer with logging\nconsumer, _ := kafka.NewConsumer(cfg, nil)\nconsumer.Subscribe(ctx, func(ctx context.Context, msg kafka.Message) error {\n    // use consumer logger\n    consumer.Logger.Info(\"processing message...\")\n\n    // log kafka message\n    kafka.LogMessageReceived(consumer.Logger, msg, consumer.GetConfig().Group)    \n\n    // Add your processing logic\n    // ...\n\n    return nil\n})\n</code></pre></p>"},{"location":"log/logging/#configuration","title":"Configuration","text":"<pre><code>import \"github.com/oddbit-project/blueprint/log\"\n\n// Create a configuration\ncfg := log.NewDefaultConfig()\ncfg.Level = \"debug\"           // log level: debug, info, warn, error\ncfg.Format = \"pretty\"        // output format: pretty or json\ncfg.IncludeTimestamp = true   // include timestamp in logs\ncfg.IncludeCaller = true      // include caller information\ncfg.IncludeHostname = true    // include hostname\n\n// Configure the global logger\nerr := log.Configure(cfg)\nif err != nil {\n    panic(err)\n}\n</code></pre>"},{"location":"log/logging/#best-practices","title":"Best Practices","text":"<ol> <li>Include relevant fields: Add meaningful fields to help with debugging and analysis</li> <li>Be consistent with log levels:</li> <li>DEBUG: Detailed information for debugging</li> <li>INFO: General operational information</li> <li>WARN: Situations that might cause issues</li> <li>ERROR: Errors that prevent normal operation</li> <li>FATAL: Critical errors that require shutdown</li> <li>Sanitize sensitive data: Don't log passwords, tokens, or other sensitive information</li> <li>Use structured logging: Avoid string concatenation or formatting in log messages</li> </ol>"},{"location":"provider/clickhouse/","title":"blueprint.provider.clickhouse","text":"<p>Blueprint ClickHouse client implementation</p>"},{"location":"provider/clickhouse/#overview","title":"Overview","text":"<p>The ClickHouse client provides a simple interface for connecting to and working with ClickHouse databases in Go applications. It supports:</p> <ul> <li>Multiple connection hosts with different connection strategies</li> <li>Secure connections with TLS</li> <li>Various compression algorithms</li> <li>Connection pooling configuration</li> <li>Repository pattern for database operations</li> </ul>"},{"location":"provider/clickhouse/#configuration","title":"Configuration","text":"<p>The client can be configured with the following options:</p> <pre><code>type ClientConfig struct {\n    Hosts            []string       // List of ClickHouse hosts to connect to\n    Database         string         // Database name\n    Username         string         // Username for authentication\n    Debug            bool           // Enable debug mode\n    Compression      string         // Compression algorithm: lz4, none, zstd, gzip, br, deflate\n    DialTimeout      int            // Connection timeout in seconds\n    MaxOpenConns     int            // Maximum number of open connections\n    MaxIdleConns     int            // Maximum number of idle connections\n    ConnMaxLifetime  int            // Maximum connection lifetime in seconds\n    ConnStrategy     string         // Connection strategy: sequential or roundRobin\n    BlockBufferSize  uint8          // Block buffer size\n    Settings         map[string]any // ClickHouse settings\n    // Secure password configuration\n    DefaultCredentialConfig\n    // TLS configuration\n    ClientConfig\n}\n</code></pre>"},{"location":"provider/clickhouse/#using-the-client","title":"Using the client","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"github.com/oddbit-project/blueprint/provider/clickhouse\"\n    \"log\"\n)\n\nfunc main() {\n    // Create a new client configuration\n    config := clickhouse.NewClientConfig()\n    config.Hosts = []string{\"localhost:9000\"}\n    config.Database = \"default\"\n    config.Username = \"default\"\n    config.Password = \"password\" // Set password via DefaultCredentialConfig\n\n    // Connect to ClickHouse\n    client, err := clickhouse.NewClient(config)\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer client.Close()\n\n    // Ping the server\n    ctx := context.Background()\n    if err = client.Ping(ctx); err != nil {\n        log.Fatal(err)\n    }\n\n    // Create a repository for a table\n    repo := client.NewRepository(ctx, \"my_table\")\n\n    // Use the repository for database operations\n    var records []MyRecord\n    err = repo.FetchWhere(map[string]any{\"active\": true}, &amp;records)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Printf(\"Found %d active records\\n\", len(records))\n}\n</code></pre>"},{"location":"provider/clickhouse/#repository-interface","title":"Repository Interface","text":"<p>The client provides a Repository interface that implements the following operations:</p> <ul> <li>Table identification (Name)</li> <li>SQL builders (Select, Insert, Update, Delete)</li> <li>Reading operations (FetchOne, Fetch, FetchRecord, FetchByKey, FetchWhere)</li> <li>Query execution (Exec, RawExec)</li> <li>Data modification (Insert, InsertAsync)</li> <li>Record deletion (Delete, DeleteWhere, DeleteByKey)</li> <li>Record counting (Count, CountWhere)</li> </ul>"},{"location":"provider/clickhouse/#repository-differences-between-postgresql-and-clickhouse","title":"Repository Differences between PostgreSQL and ClickHouse","text":"<p>The ClickHouse repository is mostly compatible with the PostgreSQL implementation, but there are some small differences: - INSERT...RETURNING is not supported; - UPDATE is not supported; - Transactions are not supported; - DELETE has limitations; - When fetching slices, cannot fetch slices of pointers (driver limitation), eg: use []type instead of []*type as a target</p>"},{"location":"provider/clickhouse/#compression-options","title":"Compression Options","text":"<p>The client supports the following compression algorithms:</p> <ul> <li><code>lz4</code> - Default, fast compression</li> <li><code>none</code> - No compression</li> <li><code>zstd</code> - High compression ratio</li> <li><code>gzip</code> - Traditional compression</li> <li><code>br</code> - Brotli compression</li> <li><code>deflate</code> - Deflate compression</li> </ul>"},{"location":"provider/clickhouse/#connection-strategies","title":"Connection Strategies","text":"<p>Two connection strategies are available:</p> <ul> <li><code>sequential</code> (default) - Try hosts in order</li> <li><code>roundRobin</code> - Distribute connections among hosts</li> </ul>"},{"location":"provider/hmacprovider/","title":"HMAC Provider","text":"<p>The HMAC Provider offers cryptographically secure message authentication and signature verification using HMAC-SHA256. It provides protection against replay attacks, timing attacks, and memory exhaustion DoS attacks.</p>"},{"location":"provider/hmacprovider/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Architecture</li> <li>Security Features</li> <li>Quick Start</li> <li>API Reference</li> <li>Key Providers</li> <li>Nonce Stores</li> <li>Configuration Options</li> <li>HTTP Authentication</li> <li>Best Practices</li> <li>Examples</li> <li>Performance</li> <li>Troubleshooting</li> </ul>"},{"location":"provider/hmacprovider/#overview","title":"Overview","text":"<p>The HMAC Provider implements HMAC-SHA256 signatures with two operation modes:</p> <ol> <li>Simple Mode: Basic HMAC signatures without replay protection</li> <li>Secure Mode: HMAC signatures with nonces and timestamps for replay protection</li> </ol>"},{"location":"provider/hmacprovider/#key-features","title":"Key Features","text":"<ul> <li>Replay Attack Prevention: Nonce-based protection with atomic check-and-set</li> <li>Timing Attack Resistance: Constant-time comparisons for security</li> <li>DoS Protection: Configurable input size limits (default: 32MB)</li> <li>Pluggable Storage: Memory, Redis, and generic KV backends</li> <li>Clock Drift Tolerance: Configurable timestamp validation windows</li> <li>Multi-tenant Support: Key provider interface for multiple secrets</li> </ul>"},{"location":"provider/hmacprovider/#architecture","title":"Architecture","text":"<p>The HMAC Provider consists of several components working together:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  HMAC Provider  \u2502\u2500\u2500\u2500\u2500\u25b6\u2502  Key Provider    \u2502     \u2502  Nonce Store    \u2502\n\u2502                 \u2502     \u2502  (Secret Mgmt)   \u2502     \u2502  (Replay Prot)  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502                                                  \u2502\n         \u2502              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510               \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6\u2502  Secure          \u2502\u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                        \u2502  Credential      \u2502\n                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"provider/hmacprovider/#core-components","title":"Core Components","text":"<ol> <li>HMACProvider: Main orchestrator for signature operations</li> <li>HMACKeyProvider: Interface for secret key management</li> <li>NonceStore: Interface for replay attack prevention</li> <li>Secure Credential: Encrypted secret storage with memory protection</li> </ol>"},{"location":"provider/hmacprovider/#security-features","title":"Security Features","text":""},{"location":"provider/hmacprovider/#implemented-protections","title":"Implemented Protections","text":"<ul> <li>Replay Protection: UUID-based nonces with TTL expiration</li> <li>Timing Attack Resistance: Constant-time HMAC verification</li> <li>Input Size Limits: Prevents memory exhaustion attacks</li> <li>Timestamp Validation: Configurable time windows for clock drift</li> <li>Atomic Operations: Thread-safe nonce consumption</li> <li>Secure Storage: Integration with encrypted credential system</li> <li>Fail-Safe Defaults: Secure configuration out of the box</li> </ul>"},{"location":"provider/hmacprovider/#security-properties","title":"Security Properties","text":"<ul> <li>Cryptographic Integrity: HMAC-SHA256 ensures message authenticity</li> <li>Non-repudiation: Nonces prevent request replay</li> <li>Forward Secrecy: Time-limited validity of signatures</li> <li>Defense in Depth: Multiple layers of validation</li> </ul>"},{"location":"provider/hmacprovider/#quick-start","title":"Quick Start","text":""},{"location":"provider/hmacprovider/#basic-usage","title":"Basic Usage","text":"<pre><code>package main\n\nimport (\n    \"strings\"\n    \"github.com/oddbit-project/blueprint/crypt/secure\"\n    \"github.com/oddbit-project/blueprint/provider/hmacprovider\"\n)\n\nfunc main() {\n    // Generate encryption key\n    key, err := secure.GenerateKey()\n    if err != nil {\n        panic(err)\n    }\n\n    // Create credential from password\n    secret, err := secure.NewCredential([]byte(\"my-secret\"), key, false)\n    if err != nil {\n        panic(err)\n    }\n\n    // create single key provider\n    keyProvider := hmacprovider.NewSingleKeyProvider(\"mykey\", secret)\n    // Create HMAC provider\n    provider := hmacprovider.NewHmacProvider(keyProvider)\n\n    // Sign data with replay protection\n    data := \"Hello, World!\"\n    hash, timestamp, nonce, err := provider.Sign256(\"mykey\", strings.NewReader(data))\n    if err != nil {\n        panic(err)\n    }\n\n    // Verify signature\n    keyId, valid, err := provider.Verify256(strings.NewReader(data), hash, timestamp, nonce)\n    if err != nil {\n        panic(err)\n    }\n\n    if valid {\n        println(\"Signature verified! Key ID:\", keyId)\n    }\n}\n</code></pre>"},{"location":"provider/hmacprovider/#http-authentication-integration","title":"HTTP Authentication Integration","text":"<pre><code>import (\n    \"github.com/oddbit-project/blueprint/crypt/secure\"  \n    \"github.com/oddbit-project/blueprint/provider/httpserver/auth\"\n    \"github.com/oddbit-project/blueprint/provider/hmacprovider\"\n)\n// Generate encryption key\nkey, err := secure.GenerateKey()\nif err != nil {\npanic(err)\n}\n\n// Create credential from password\nsecret, err := secure.NewCredential([]byte(\"my-secret\"), key, false)\nif err != nil {\npanic(err)\n}\n\n// create single key provider\nkeyProvider := hmacprovider.NewSingleKeyProvider(\"mykey\", secret)\n\n// Create HMAC provider\nprovider := hmacprovider.NewHmacProvider(keyProvider)\n\n// Create HMAC auth provider\nhmacAuth := auth.NewHMACAuthProvider(provider)\n\n// Apply to routes\nrouter.Use(auth.AuthMiddleware(hmacAuth))\n\n// Access authentication info in handlers\nfunc handler(c *gin.Context) {\n    keyId, ok := auth.GetHMACIdentity(c)\n    if ok {\n        // Use keyId for tenant identification\n    }\n\n    // Get full HMAC details\n    keyId, timestamp, nonce, ok := auth.GetHMACDetails(c)\n    if ok {\n        // Access all HMAC authentication data\n    }\n}\n</code></pre>"},{"location":"provider/hmacprovider/#api-reference","title":"API Reference","text":"<p>Note: keyId cannot contain dots ('.') as they are used for keyId+hash concatenation</p>"},{"location":"provider/hmacprovider/#constructor","title":"Constructor","text":""},{"location":"provider/hmacprovider/#newhmacproviderkeyprovider-hmackeyprovider-opts-hmacprovideroption-hmacprovider","title":"<code>NewHmacProvider(keyProvider HMACKeyProvider, opts ...HMACProviderOption) *HMACProvider</code>","text":"<p>Creates a new HMAC provider with the specified key provider and options.</p> <p>Parameters: - <code>keyProvider</code>: Implementation of HMACKeyProvider interface - <code>opts</code>: Optional configuration functions</p> <p>Returns: Configured HMAC provider instance</p>"},{"location":"provider/hmacprovider/#simple-hmac-methods","title":"Simple HMAC Methods","text":""},{"location":"provider/hmacprovider/#sha256signkeyid-string-data-ioreader-string-error","title":"<code>SHA256Sign(keyId string, data io.Reader) (string, error)</code>","text":"<p>Generates a simple HMAC-SHA256 signature without replay protection.</p> <p>Parameters: - <code>keyId</code>: Identifier for the key to use - <code>data</code>: Input data to sign</p> <p>Returns:  - <code>string</code>: Hex-encoded HMAC signature - <code>error</code>: Any error that occurred</p>"},{"location":"provider/hmacprovider/#sha256verifydata-ioreader-hash-string-keyid-string-valid-bool-error","title":"<code>SHA256Verify(data io.Reader, hash string) (keyId string, valid bool, error)</code>","text":"<p>Verifies a simple HMAC-SHA256 signature.</p> <p>Parameters: - <code>data</code>: Input data to verify - <code>hash</code>: Hex-encoded HMAC signature to verify</p> <p>Returns: - <code>keyId</code>: Identifier of the key that validated the signature - <code>valid</code>: True if signature is valid - <code>error</code>: Any error that occurred</p>"},{"location":"provider/hmacprovider/#secure-hmac-methods","title":"Secure HMAC Methods","text":""},{"location":"provider/hmacprovider/#sign256keyid-string-data-ioreader-hash-timestamp-nonce-string-err-error","title":"<code>Sign256(keyId string, data io.Reader) (hash, timestamp, nonce string, err error)</code>","text":"<p>Generates a secure HMAC-SHA256 signature with replay protection.</p> <p>Parameters: - <code>keyId</code>: Identifier for the key to use - <code>data</code>: Input data to sign</p> <p>Returns: - <code>hash</code>: Hex-encoded HMAC signature - <code>timestamp</code>: RFC3339 timestamp - <code>nonce</code>: UUID v4 nonce - <code>err</code>: Any error that occurred</p>"},{"location":"provider/hmacprovider/#verify256data-ioreader-hash-timestamp-nonce-string-keyid-string-valid-bool-error","title":"<code>Verify256(data io.Reader, hash, timestamp, nonce string) (keyId string, valid bool, error)</code>","text":"<p>Verifies a secure HMAC-SHA256 signature with replay protection.</p> <p>Parameters: - <code>data</code>: Input data to verify - <code>hash</code>: Hex-encoded HMAC signature - <code>timestamp</code>: RFC3339 timestamp from signing - <code>nonce</code>: UUID nonce from signing</p> <p>Returns: - <code>keyId</code>: Identifier of the key that validated the signature - <code>valid</code>: True if signature is valid and not replayed - <code>error</code>: Any error that occurred</p>"},{"location":"provider/hmacprovider/#key-providers","title":"Key Providers","text":"<p>The HMAC system supports multiple key management strategies through the <code>HMACKeyProvider</code> interface:</p>"},{"location":"provider/hmacprovider/#interface-definition","title":"Interface Definition","text":"<pre><code>type HMACKeyProvider interface {\n    GetKey(keyId string) (*secure.Credential, error)\n}\n</code></pre>"},{"location":"provider/hmacprovider/#single-key-provider","title":"Single Key Provider","text":"<p>Note: the keyId can be an empty string</p> <p>Simple provider for single-key applications:</p> <pre><code>// Create single key provider\nprovider := hmacprovider.NewSingleKeyProvider(\"myKeyId\", credential)\n\n// Always uses the same key regardless of keyId\nhmac := hmacprovider.NewHmacProvider(provider)\n</code></pre>"},{"location":"provider/hmacprovider/#multi-tenant-key-provider","title":"Multi-Tenant Key Provider","text":"<p>For applications with multiple tenants or key rotation:</p> <pre><code>type MultiTenantKeyProvider struct {\n    keys map[string]*secure.Credential\n    m sync.RWMutex\n}\n\nfunc (m *MultiTenantKeyProvider) GetKey(keyId string) (*secure.Credential, error) {\n    m.m.RLock()\n    defer m.m.RUnlock()\n\n    key, exists := m.keys[keyId]\n    if !exists {\n        return nil, errors.New(\"unknown key ID\")\n    }\n    return key, nil\n}\n\nfunc (m *MultiTenantKeyProvider) ListKeyIds() []string {\n    m.m.RLock()\n    defer m.m.RUnlock()\n\n    ids := make([]string, 0, len(m.keys))\n    for id := range m.keys {\n        ids = append(ids, id)\n    }\n    return ids\n}\n</code></pre>"},{"location":"provider/hmacprovider/#nonce-stores","title":"Nonce Stores","text":"<p>The HMAC provider supports multiple nonce store backends for replay protection:</p>"},{"location":"provider/hmacprovider/#memory-store-default","title":"Memory Store (Default)","text":"<p>In-memory storage with configurable TTL and eviction policies.</p> <pre><code>import \"github.com/oddbit-project/blueprint/provider/hmacprovider/store\"\n\n// Create with custom options\nmemoryStore := store.NewMemoryNonceStore(\n    store.WithTTL(1*time.Hour),\n    store.WithMaxSize(1000000),\n    store.WithCleanupInterval(15*time.Minute),\n    store.WithEvictPolicy(store.EvictHalfLife()),\n)\n\nprovider := hmacprovider.NewHmacProvider(keyProvider,\n    hmacprovider.WithNonceStore(memoryStore),\n)\n</code></pre> <p>Eviction Policies: - <code>EvictNone()</code>: No automatic eviction (default) - <code>EvictAll()</code>: Remove all nonces when at capacity - <code>EvictHalfLife()</code>: Remove nonces older than TTL/2</p> <p>Best For: Single-instance applications, development, low-traffic APIs</p>"},{"location":"provider/hmacprovider/#redis-store","title":"Redis Store","text":"<p>Redis-backed storage with atomic operations for distributed systems.</p> <pre><code>import (\n    \"github.com/oddbit-project/blueprint/provider/redis\"\n    \"github.com/oddbit-project/blueprint/provider/hmacprovider/store\"\n)\n\n// Configure Redis client\nconfig := redis.NewConfig()\nconfig.Address = \"localhost:6379\"\nconfig.Database = 1\n\nredisClient, err := redis.NewClient(config)\nif err != nil {\n    panic(err)\n}\n\n// Create Redis nonce store\nredisStore := store.NewRedisStore(\n    redisClient, \n    1*time.Hour,     // TTL\n    \"hmac:nonce:\",   // Key prefix\n)\n\nprovider := hmacprovider.NewHmacProvider(keyProvider,\n    hmacprovider.WithNonceStore(redisStore),\n)\n</code></pre> <p>Features: - Atomic SetNX operations - Configurable key prefix for namespacing - Automatic TTL management - Network timeout handling</p> <p>Best For: Multi-instance deployments, high-traffic APIs, production systems</p>"},{"location":"provider/hmacprovider/#generic-kv-store","title":"Generic KV Store","text":"<p>Adapter for any key-value backend implementing the KV interface.</p> <pre><code>import (\n    \"github.com/oddbit-project/blueprint/provider/kv\"\n    \"github.com/oddbit-project/blueprint/provider/hmacprovider/store\"\n)\n\n// Use any KV implementation\nvar kvBackend kv.KV = getYourKVBackend()\n\nkvStore := store.NewKvStore(kvBackend, 1*time.Hour)\n\nprovider := hmacprovider.NewHmacProvider(keyProvider,\n    hmacprovider.WithNonceStore(kvStore),\n)\n</code></pre> <p>Best For: Custom storage requirements, existing KV infrastructure</p>"},{"location":"provider/hmacprovider/#configuration-options","title":"Configuration Options","text":""},{"location":"provider/hmacprovider/#withnoncestorestore-noncestore","title":"<code>WithNonceStore(store NonceStore)</code>","text":"<p>Sets the nonce store backend for replay protection.</p> <pre><code>provider := hmacprovider.NewHmacProvider(keyProvider,\n    hmacprovider.WithNonceStore(customStore),\n)\n</code></pre>"},{"location":"provider/hmacprovider/#withkeyintervalinterval-timeduration","title":"<code>WithKeyInterval(interval time.Duration)</code>","text":"<p>Sets the allowed timestamp deviation window. Default: 5 minutes.</p> <pre><code>provider := hmacprovider.NewHmacProvider(keyProvider,\n    hmacprovider.WithKeyInterval(10*time.Minute), // \u00b110 minutes\n)\n</code></pre>"},{"location":"provider/hmacprovider/#withmaxinputsizemaxsize-int","title":"<code>WithMaxInputSize(maxSize int)</code>","text":"<p>Sets the maximum input size to prevent DoS attacks. Default: 32MB.</p> <pre><code>provider := hmacprovider.NewHmacProvider(keyProvider,\n    hmacprovider.WithMaxInputSize(1024*1024), // 1MB limit\n)\n</code></pre>"},{"location":"provider/hmacprovider/#http-authentication","title":"HTTP Authentication","text":""},{"location":"provider/hmacprovider/#required-headers","title":"Required Headers","text":"<p>When using HMAC authentication with HTTP, the following headers are required:</p> <ul> <li><code>X-HMAC-Hash</code>: The HMAC-SHA256 signature</li> <li><code>X-HMAC-Timestamp</code>: RFC3339 formatted timestamp</li> <li><code>X-HMAC-Nonce</code>: UUID v4 nonce</li> </ul>"},{"location":"provider/hmacprovider/#client-implementation","title":"Client Implementation","text":"<pre><code>func makeAuthenticatedRequest(provider *hmacprovider.HMACProvider, url string, body []byte) error {\n    // Generate signature\n    bodyReader := bytes.NewReader(body)\n    hash, timestamp, nonce, err := provider.Sign256(\"client-key\", bodyReader)\n    if err != nil {\n        return err\n    }\n\n    // Create request\n    req, err := http.NewRequest(\"POST\", url, bytes.NewReader(body))\n    if err != nil {\n        return err\n    }\n\n    // Add HMAC headers\n    req.Header.Set(\"X-HMAC-Hash\", hash)\n    req.Header.Set(\"X-HMAC-Timestamp\", timestamp)\n    req.Header.Set(\"X-HMAC-Nonce\", nonce)\n    req.Header.Set(\"Content-Type\", \"application/json\")\n\n    // Send request\n    client := &amp;http.Client{}\n    resp, err := client.Do(req)\n    if err != nil {\n        return err\n    }\n    defer resp.Body.Close()\n\n    return nil\n}\n</code></pre>"},{"location":"provider/hmacprovider/#server-integration","title":"Server Integration","text":"<pre><code>import (\n    \"github.com/gin-gonic/gin\"\n    \"github.com/oddbit-project/blueprint/provider/httpserver/auth\"\n    \"github.com/oddbit-project/blueprint/crypt/secure\"\n    \"github.com/oddbit-project/blueprint/provider/hmacprovider\"\n)\n\nfunc createHMACProvider() *hmacprovider.HMACProvider {\n    // Generate encryption key\n    key, err := secure.GenerateKey()\n    if err != nil {\n        panic(err)\n    }\n\n    // Create credential from password\n    secret, err := secure.NewCredential([]byte(\"my-secret\"), key, false)\n    if err != nil {\n        panic(err)\n    }\n\n    // create single key provider\n    keyProvider := hmacprovider.NewSingleKeyProvider(\"client-key\", secret)\n\n    // Create HMAC provider\n    return hmacprovider.NewHmacProvider(keyProvider)\n}\n\nfunc setupServer() {\n    router := gin.Default()\n\n    // Create HMAC provider\n    hmacProvider := createHMACProvider()\n\n    // Create auth middleware\n    hmacAuth := auth.NewHMACAuthProvider(hmacProvider)\n\n    // Protected routes\n    api := router.Group(\"/api\")\n    api.Use(auth.AuthMiddleware(hmacAuth))\n    {\n        api.POST(\"/data\", handleData)\n        api.PUT(\"/update\", handleUpdate)\n    }\n\n    router.Run(\":8080\")\n}\n\nfunc handleData(c *gin.Context) {\n    // Get authenticated key ID\n    keyId, exists := auth.GetHMACIdentity(c)\n    if !exists {\n        c.JSON(500, gin.H{\"error\": \"Authentication info missing\"})\n        return\n    }\n\n    // Get full HMAC details\n    keyId, timestamp, nonce, ok := auth.GetHMACDetails(c)\n    if !ok {\n        c.JSON(500, gin.H{\"error\": \"HMAC details missing\"})\n        return\n    }\n\n    c.JSON(200, gin.H{\n        \"message\": \"Authenticated request\",\n        \"tenant\": keyId,\n        \"timestamp\": timestamp,\n        \"nonce\": nonce,\n    })\n}\n</code></pre>"},{"location":"provider/hmacprovider/#best-practices","title":"Best Practices","text":""},{"location":"provider/hmacprovider/#security-recommendations","title":"Security Recommendations","text":"<ol> <li>Always Use Secure Mode: Use <code>Sign256</code>/<code>Verify256</code> for replay protection</li> <li>Strong Secrets: Generate cryptographically secure secrets (32+ bytes)</li> <li>Key Rotation: Implement regular key rotation policies</li> <li>Secure Storage: Use encrypted credential storage</li> <li>HTTPS Only: Always use TLS for transport security</li> <li>Input Validation: Set appropriate <code>MaxInputSize</code> limits</li> <li>Clock Sync: Ensure server clocks are synchronized (NTP)</li> <li>Monitoring: Log and monitor authentication failures</li> </ol>"},{"location":"provider/hmacprovider/#performance-optimization","title":"Performance Optimization","text":"<ol> <li>Choose Appropriate Backend:</li> <li>Memory: Single-instance, low-traffic</li> <li>Redis: Multi-instance, high-traffic</li> <li> <p>Custom KV: Specific requirements</p> </li> <li> <p>Tune Configuration:</p> </li> <li>Adjust TTL based on security requirements</li> <li>Set cleanup intervals based on traffic</li> <li> <p>Choose eviction policy based on memory</p> </li> <li> <p>Connection Pooling:</p> </li> <li>Use connection pools for Redis</li> <li>Configure appropriate timeouts</li> </ol>"},{"location":"provider/hmacprovider/#error-handling","title":"Error Handling","text":"<pre><code>func handleHMACError(err error, clientIP string) {\n    if err != nil {\n        switch {\n        case strings.Contains(err.Error(), \"invalid request\"):\n            // Input validation failure\n            log.Warn(\"Invalid HMAC request\", \"ip\", clientIP, \"error\", err)\n        case strings.Contains(err.Error(), \"input too large\"):\n            // Potential DoS attempt\n            log.Error(\"HMAC input too large\", \"ip\", clientIP, \"error\", err)\n        case strings.Contains(err.Error(), \"nonce already used\"):\n            // Replay attack\n            log.Error(\"HMAC replay attack detected\", \"ip\", clientIP, \"error\", err)\n        default:\n            // Other errors\n            log.Error(\"HMAC verification failed\", \"ip\", clientIP, \"error\", err)\n        }\n    }\n}\n</code></pre>"},{"location":"provider/hmacprovider/#examples","title":"Examples","text":""},{"location":"provider/hmacprovider/#multi-tenant-api","title":"Multi-Tenant API","text":"<pre><code>type TenantKeyProvider struct {\n    tenants map[string]*secure.Credential\n    mu      sync.RWMutex\n}\n\nfunc (t *TenantKeyProvider) GetKey(tenantId string) (*secure.Credential, error) {\n    t.mu.RLock()\n    defer t.mu.RUnlock()\n\n    cred, exists := t.tenants[tenantId]\n    if !exists {\n        return nil, fmt.Errorf(\"unknown tenant: %s\", tenantId)\n    }\n    return cred, nil\n}\n\nfunc (t *TenantKeyProvider) ListKeyIds() []string {\n    t.mu.RLock()\n    defer t.mu.RUnlock()\n\n    ids := make([]string, 0, len(t.tenants))\n    for id := range t.tenants {\n        ids = append(ids, id)\n    }\n    return ids\n}\n\n// Usage\ntenantProvider := &amp;TenantKeyProvider{\n    tenants: loadTenantKeys(),\n}\n\nhmacProvider := hmacprovider.NewHmacProvider(\n    tenantProvider,\n    hmacprovider.WithNonceStore(redisStore),\n    hmacprovider.WithKeyInterval(10*time.Minute),\n)\n</code></pre>"},{"location":"provider/hmacprovider/#webhook-verification","title":"Webhook Verification","text":"<pre><code>func verifyWebhook(provider *hmacprovider.HMACProvider, r *http.Request) error {\n    // Extract headers\n    hash := r.Header.Get(\"X-Webhook-Signature\")\n    timestamp := r.Header.Get(\"X-Webhook-Timestamp\")\n    nonce := r.Header.Get(\"X-Webhook-Id\")\n\n    // Read body\n    body, err := io.ReadAll(r.Body)\n    if err != nil {\n        return fmt.Errorf(\"failed to read body: %w\", err)\n    }\n    r.Body = io.NopCloser(bytes.NewReader(body))\n\n    // Verify signature\n    keyId, valid, err := provider.Verify256(\n        bytes.NewReader(body), \n        hash, \n        timestamp, \n        nonce,\n    )\n\n    if err != nil {\n        return fmt.Errorf(\"verification error: %w\", err)\n    }\n\n    if !valid {\n        return errors.New(\"invalid webhook signature\")\n    }\n\n    log.Info(\"Webhook verified\", \"source\", keyId)\n    return nil\n}\n</code></pre>"},{"location":"provider/hmacprovider/#performance","title":"Performance","text":""},{"location":"provider/hmacprovider/#benchmarks","title":"Benchmarks","text":"<p>Performance results on Intel Core i5-10400F @ 2.90GHz:</p> <ul> <li>SHA256Sign: ~2.1\u03bcs per operation (2,184 B/op, 18 allocs/op)</li> <li>SHA256Verify: ~2.0\u03bcs per operation (2,008 B/op, 15 allocs/op)</li> <li>Sign256 (with nonce): ~3.1\u03bcs per operation (2,344 B/op, 25 allocs/op)</li> <li>Verify256 (with nonce): ~2.9\u03bcs per operation (2,213 B/op, 19 allocs/op)</li> <li>Full Cycle (Sign256 + Verify256): ~6.1\u03bcs per operation (4,557 B/op, 44 allocs/op)</li> </ul>"},{"location":"provider/hmacprovider/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Reuse Provider Instances: Create once, use many times</li> <li>Buffer Pool: Use sync.Pool for byte buffers</li> <li>Batch Operations: Process multiple items in sequence</li> <li>Connection Pooling: Configure Redis connection pools</li> <li>Async Processing: Use goroutines for independent verifications</li> </ol>"},{"location":"provider/hmacprovider/#troubleshooting","title":"Troubleshooting","text":""},{"location":"provider/hmacprovider/#common-issues","title":"Common Issues","text":""},{"location":"provider/hmacprovider/#invalid-request-error","title":"\"invalid request\" Error","text":"<p>Cause: Input validation failure Solution:  - Check all parameters are provided - Verify timestamp format (RFC3339) - Ensure nonce is valid UUID</p>"},{"location":"provider/hmacprovider/#input-too-large-error","title":"\"input too large\" Error","text":"<p>Cause: Input exceeds MaxInputSize Solution: - Increase limit with <code>WithMaxInputSize</code> - Reduce input size - Check for erroneous large inputs</p>"},{"location":"provider/hmacprovider/#nonce-already-used-error","title":"\"nonce already used\" Error","text":"<p>Cause: Replay attack or duplicate request Solution: - Ensure unique nonce generation - Check for request retry logic - Verify nonce store is working</p>"},{"location":"provider/hmacprovider/#clock-drift-issues","title":"Clock Drift Issues","text":"<p>Symptoms: Intermittent verification failures Solution: - Sync server clocks with NTP - Increase KeyInterval tolerance - Monitor timestamp differences</p>"},{"location":"provider/hmacprovider/#constants","title":"Constants","text":"<ul> <li><code>DefaultKeyInterval</code>: 5 minutes (300 seconds)</li> <li><code>DefaultMaxInputSize</code>: 32MB (33554432 bytes)</li> <li><code>DefaultTTL</code>: 4 hours (nonce stores)</li> <li><code>DefaultMaxSize</code>: 2,000,000 entries (memory store)</li> <li><code>DefaultCleanupInterval</code>: 15 minutes (memory store)</li> </ul>"},{"location":"provider/htpasswd/","title":"blueprint.provider.htpasswd","text":"<p>Blueprint htpasswd provider for managing Apache-style password files.</p>"},{"location":"provider/htpasswd/#overview","title":"Overview","text":"<p>The htpasswd provider offers a comprehensive solution for managing user authentication files compatible with Apache's htpasswd format. It supports multiple hash algorithms, thread-safe operations, and provides both programmatic API and command-line tools.</p> <p>Key features:</p> <ul> <li>Multiple hash algorithms (bcrypt, Apache MD5, SHA1/256/512, crypt, plaintext)</li> <li>Thread-safe container operations with mutex protection</li> <li>Apache htpasswd file format compatibility</li> <li>Comprehensive input validation (UTF-8, byte limits, forbidden characters)</li> <li>In-memory and file-based operations</li> <li>Command-line utility compatible with Apache htpasswd</li> </ul>"},{"location":"provider/htpasswd/#supported-hash-algorithms","title":"Supported Hash Algorithms","text":"Algorithm Prefix Security Recommended bcrypt <code>$2a$</code>, <code>$2y$</code> High Yes (default) Apache MD5 <code>$apr1$</code> Medium \ufe0f Legacy compatibility SHA256 <code>{SHA256}</code> Medium \ufe0f No salt SHA512 <code>{SHA512}</code> Medium \ufe0f No salt SHA1 <code>{SHA}</code> Low Deprecated Crypt None (13 chars) Low Deprecated Plain None None Development only"},{"location":"provider/htpasswd/#container-api","title":"Container API","text":""},{"location":"provider/htpasswd/#basic-usage","title":"Basic Usage","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"github.com/oddbit-project/blueprint/provider/htpasswd\"\n)\n\nfunc main() {\n    // Create new container\n    container := htpasswd.NewContainer()\n\n    // Add user with bcrypt (recommended)\n    err := container.AddUserPassword(\"alice\", \"secret123\")\n    if err != nil {\n        panic(err)\n    }\n\n    // Verify user password\n    valid, err := container.VerifyUser(\"alice\", \"secret123\")\n    if err != nil {\n        panic(err)\n    }\n    fmt.Printf(\"Password valid: %v\\n\", valid)\n\n    // Save to file\n    file, err := os.Create(\"users.htpasswd\")\n    if err != nil {\n        panic(err)\n    }\n    defer file.Close()\n\n    err = container.Write(file)\n    if err != nil {\n        panic(err)\n    }\n}\n</code></pre>"},{"location":"provider/htpasswd/#loading-from-file","title":"Loading from File","text":"<pre><code>// Load existing htpasswd file\ncontainer, err := htpasswd.NewFromFile(\"/etc/apache2/.htpasswd\")\nif err != nil {\npanic(err)\n}\n\n// Or from any io.Reader\nfile, err := os.Open(\"users.htpasswd\")\nif err != nil {\npanic(err)\n}\ndefer file.Close()\n\ncontainer, err = htpasswd.NewFromReader(file)\nif err != nil {\npanic(err)\n}\n</code></pre>"},{"location":"provider/htpasswd/#user-management","title":"User Management","text":"<pre><code>// Check if user exists\nif container.UserExists(\"alice\") {\nfmt.Println(\"User alice exists\")\n}\n\n// Get user entry\nentry, err := container.GetUser(\"alice\")\nif err != nil {\npanic(err)\n}\nfmt.Printf(\"Username: %s, Hash: %s\\n\", entry.Username, entry.Hash)\n\n// List all users\nusers := container.ListUsers()\nfmt.Printf(\"Total users: %d\\n\", container.Count())\n\n// Delete user\nerr = container.DeleteUser(\"alice\")\nif err != nil {\npanic(err)\n}\n</code></pre>"},{"location":"provider/htpasswd/#hash-algorithm-selection","title":"Hash Algorithm Selection","text":"<pre><code>// Use specific hash algorithm\nerr := container.AddUserWithHash(\"bob\", \"password\", htpasswd.HashTypeBcrypt)\nerr = container.AddUserWithHash(\"charlie\", \"password\", htpasswd.HashTypeApacheMD5)\nerr = container.AddUserWithHash(\"dave\", \"password\", htpasswd.HashTypeSHA256)\n</code></pre>"},{"location":"provider/htpasswd/#hash-functions","title":"Hash Functions","text":""},{"location":"provider/htpasswd/#direct-hash-operations","title":"Direct Hash Operations","text":"<pre><code>// Generate hash\nhash, err := htpasswd.HashPassword(\"mypassword\", htpasswd.HashTypeBcrypt)\nif err != nil {\npanic(err)\n}\nfmt.Printf(\"Generated hash: %s\\n\", hash)\n\n// Verify password against hash\nvalid := htpasswd.VerifyPassword(\"mypassword\", hash)\nfmt.Printf(\"Password valid: %v\\n\", valid)\n\n// Detect hash type\nhashType := htpasswd.DetectHashType(hash)\nfmt.Printf(\"Hash type: %v\\n\", hashType)\n</code></pre>"},{"location":"provider/htpasswd/#algorithm-specific-functions","title":"Algorithm-Specific Functions","text":"<pre><code>// Bcrypt (recommended)\nhash, err := htpasswd.HashBcrypt(\"password\")\nvalid := htpasswd.VerifyBcrypt(\"password\", hash)\n\n// Apache MD5\nhash, err = htpasswd.HashApacheMD5(\"password\")\nvalid = htpasswd.VerifyApacheMD5(\"password\", hash)\n\n// SHA variants\nhash, err = htpasswd.HashSHA256(\"password\")\nvalid = htpasswd.VerifySHA256(\"password\", hash)\n</code></pre>"},{"location":"provider/htpasswd/#input-validation","title":"Input Validation","text":"<p>The provider includes comprehensive validation:</p> <pre><code>// Username validation\nerr := htpasswd.ValidateUsername(\"alice\") // Valid\nerr = htpasswd.ValidateUsername(\"\") // Not valid - empty\nerr = htpasswd.ValidateUsername(\"user:name\") // Not valid - contains colon\nerr = htpasswd.ValidateUsername(string(make([]byte, 256))) // Not valid &gt; 255 bytes\n\n// Password validation  \nerr = htpasswd.ValidatePassword(\"secret123\") // Valid\nerr = htpasswd.ValidatePassword(\"\") // Not valid - empty\nerr = htpasswd.ValidatePassword(\"\\xFF\\xFE\") // Not valid - invalid UTF-8\n</code></pre>"},{"location":"provider/htpasswd/#validation-rules","title":"Validation Rules","text":"<p>Username constraints:</p> <ul> <li>Must not be empty (after trimming whitespace)</li> <li>Cannot contain colon (<code>:</code>) character</li> <li>Maximum 255 bytes length</li> <li>Must be valid UTF-8</li> </ul> <p>Password constraints:</p> <ul> <li>Must not be empty</li> <li>Must be valid UTF-8</li> </ul>"},{"location":"provider/htpasswd/#command-line-tool","title":"Command-Line Tool","text":"<p>The included <code>htpasswd</code> command-line tool provides Apache compatibility:</p>"},{"location":"provider/htpasswd/#installation","title":"Installation","text":"<pre><code>cd sample/htpasswd\ngo build -o htpasswd main.go\n</code></pre>"},{"location":"provider/htpasswd/#usage-examples","title":"Usage Examples","text":"<pre><code># Create new file with user\n./htpasswd -c users.htpasswd alice\n\n# Add user to existing file\n./htpasswd users.htpasswd bob\n\n# Batch mode (scripting)\n./htpasswd -b users.htpasswd charlie password123\n\n# Use specific algorithm\n./htpasswd -b -B sha256 users.htpasswd dave secret\n\n# Delete user\n./htpasswd -D users.htpasswd alice\n\n# Verify password\n./htpasswd -v users.htpasswd bob\n</code></pre>"},{"location":"provider/htpasswd/#command-line-options","title":"Command-Line Options","text":"Option Description <code>-c</code> Create a new file <code>-D</code> Delete the specified user <code>-v</code> Verify password for the specified user <code>-b</code> Use batch mode (password on command line) <code>-B algorithm</code> Force hash algorithm (bcrypt, apr1, sha, sha256, sha512, crypt, plain) <code>-h</code> Show help message <code>-version</code> Show version information"},{"location":"provider/htpasswd/#security-considerations","title":"Security Considerations","text":""},{"location":"provider/htpasswd/#best-practices","title":"Best Practices","text":"<ol> <li>Use bcrypt - Default and recommended for new implementations</li> <li>Validate inputs - Always validate usernames and passwords</li> <li>Secure file permissions - Set appropriate file permissions (600 or 644)</li> <li>Regular updates - Update weak hashes to stronger algorithms</li> </ol>"},{"location":"provider/htpasswd/#security-features","title":"Security Features","text":"<ul> <li>Timing attack resistance - Uses <code>crypto/subtle.ConstantTimeCompare</code></li> <li>Thread safety - All operations are mutex-protected</li> <li>Input validation - Comprehensive UTF-8 and constraint checking</li> <li>Secure defaults - bcrypt with default cost factor</li> </ul>"},{"location":"provider/htpasswd/#migration-example","title":"Migration Example","text":"<pre><code>// Migrate from SHA1 to bcrypt\ncontainer, err := htpasswd.NewFromFile(\"legacy.htpasswd\")\nif err != nil {\npanic(err)\n}\n\nfor _, username := range container.ListUsers() {\nentry, _ := container.GetUser(username)\n\n// Check if using weak hash\nif htpasswd.DetectHashType(entry.Hash) == htpasswd.HashTypeSHA1 {\nfmt.Printf(\"User %s uses weak hash, manual password reset required\\n\", username)\n// Note: Cannot migrate without knowing original password\n}\n}\n</code></pre>"},{"location":"provider/htpasswd/#file-format","title":"File Format","text":"<p>Standard Apache htpasswd format:</p> <pre><code>username1:$2y$10$abcdefghijklmnopqrstuvwxyz0123456789\nusername2:{SHA}5baa61e4c9b93f3f0682250b6cf8331b7ee68fd8\nusername3:$apr1$salt$hash\n</code></pre>"},{"location":"provider/htpasswd/#error-handling","title":"Error Handling","text":"<pre><code>// Common error scenarios\ncontainer := htpasswd.NewContainer()\n\n// Handle validation errors\nerr := container.AddUser(\"user:invalid\", \"password\")\nif err != nil {\nfmt.Printf(\"Validation error: %v\\n\", err)\n}\n\n// Handle file errors\n_, err = htpasswd.NewFromFile(\"nonexistent.htpasswd\")\nif err != nil {\nfmt.Printf(\"File error: %v\\n\", err)\n}\n\n// Handle user not found\n_, err = container.GetUser(\"missing\")\nif err != nil {\nfmt.Printf(\"User not found: %v\\n\", err)\n}\n</code></pre>"},{"location":"provider/htpasswd/#testing","title":"Testing","text":"<p>The provider includes comprehensive test coverage:</p> <pre><code># Run all tests\ngo test -v ./provider/htpasswd/...\n\n# Check coverage\ngo test -cover ./provider/htpasswd/...\n\n# Run with race detection\ngo test -race ./provider/htpasswd/...\n</code></pre>"},{"location":"provider/jwtprovider/","title":"blueprint.provider.jwtprovider","text":"<p>Blueprint JWT provider for comprehensive JSON Web Token authentication and management.</p>"},{"location":"provider/jwtprovider/#overview","title":"Overview","text":"<p>The JWT provider offers a complete solution for managing JWT tokens in Go applications. It supports multiple signing algorithms, token revocation, refresh capabilities, and secure key management.</p> <p>Key features:</p> <ul> <li>Multiple signing algorithms (HMAC, RSA, ECDSA, EdDSA)</li> <li>Token revocation system with pluggable backends</li> <li>User token tracking and session management</li> <li>Configurable concurrent session limits</li> <li>Token refresh functionality</li> <li>Secure key management with Blueprint's credential system</li> <li>Comprehensive validation options</li> <li>Thread-safe operations</li> </ul>"},{"location":"provider/jwtprovider/#supported-signing-algorithms","title":"Supported Signing Algorithms","text":"Algorithm Type Security Key Requirements Recommended HS256 HMAC High Shared secret Yes HS384 HMAC High Shared secret Yes HS512 HMAC High Shared secret Yes RS256 RSA High RSA key pair Yes RS384 RSA High RSA key pair Yes RS512 RSA High RSA key pair Yes ES256 ECDSA High ECDSA key pair Yes ES384 ECDSA High ECDSA key pair Yes ES512 ECDSA High ECDSA key pair Yes EdDSA EdDSA High Ed25519 key pair Yes"},{"location":"provider/jwtprovider/#configuration","title":"Configuration","text":""},{"location":"provider/jwtprovider/#basic-configuration","title":"Basic Configuration","text":"<pre><code>type JWTConfig struct {\n    SigningKey        *secure.DefaultCredentialConfig `json:\"signingKey,omitempty\"`     // For HMAC algorithms\n    PrivateKey        *secure.KeyConfig               `json:\"privateKey,omitempty\"`     // For asymmetric algorithms\n    PublicKey         *secure.KeyConfig               `json:\"publicKey,omitempty\"`      // For asymmetric algorithms\n    SigningAlgorithm  string                          `json:\"signingAlgorithm\"`         // Algorithm to use\n    ExpirationSeconds int                             `json:\"expirationSeconds\"`        // Token expiration\n    Issuer            string                          `json:\"issuer\"`                   // Token issuer\n    Audience          string                          `json:\"audience\"`                 // Token audience\n    KeyID             string                          `json:\"keyID\"`                    // Key ID for JWKS\n    MaxTokenSize      int                             `json:\"maxTokenSize,omitempty\"`   // Maximum token size (bytes)\n    RequireIssuer     bool                            `json:\"requireIssuer\"`            // Enforce issuer validation\n    RequireAudience   bool                            `json:\"requireAudience\"`          // Enforce audience validation\n\n    // User Token Tracking\n    TrackUserTokens   bool                            `json:\"trackUserTokens\"`          // Enable user token tracking\n    MaxUserSessions   int                             `json:\"maxUserSessions,omitempty\"` // Max concurrent sessions per user (0 = unlimited)\n}\n</code></pre>"},{"location":"provider/jwtprovider/#default-values","title":"Default Values","text":"<pre><code>const (\n    DefaultTTL      = time.Second * 86400 // 1 day\n    DefaultIssuer   = \"blueprint\"\n    DefaultAudience = \"api\"\n)\n</code></pre>"},{"location":"provider/jwtprovider/#basic-usage","title":"Basic Usage","text":""},{"location":"provider/jwtprovider/#hmac-algorithms-hs256hs384hs512","title":"HMAC Algorithms (HS256/HS384/HS512)","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"github.com/oddbit-project/blueprint/provider/jwtprovider\"\n    \"github.com/oddbit-project/blueprint/crypt/secure\"\n)\n\nfunc main() {\n    // Create configuration for HMAC signing\n    config := jwtprovider.NewJWTConfig()\n    config.SigningAlgorithm = jwtprovider.HS256\n    config.ExpirationSeconds = 3600 // 1 hour\n    config.Issuer = \"my-app\"\n    config.Audience = \"api\"\n    config.RequireIssuer = true\n    config.RequireAudience = true\n\n    // Set up signing key\n    signingKey, err := secure.GenerateKey()\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    config.SigningKey = &amp;secure.DefaultCredentialConfig{\n        Key: signingKey,\n    }\n\n    // Create JWT provider\n    provider, err := jwtprovider.NewProvider(config)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Generate a token\n    customData := map[string]any{\n        \"role\":        \"admin\",\n        \"permissions\": []string{\"read\", \"write\"},\n    }\n\n    token, err := provider.GenerateToken(\"user123\", customData)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Printf(\"Generated token: %s\\n\", token)\n\n    // Parse and validate the token\n    claims, err := provider.ParseToken(token)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Printf(\"Subject: %s\\n\", claims.Subject)\n    fmt.Printf(\"Custom data: %v\\n\", claims.Data)\n}\n</code></pre>"},{"location":"provider/jwtprovider/#rsa-algorithms-rs256rs384rs512","title":"RSA Algorithms (RS256/RS384/RS512)","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"github.com/oddbit-project/blueprint/provider/jwtprovider\"\n    \"github.com/oddbit-project/blueprint/crypt/secure\"\n)\n\nfunc main() {\n    // Create configuration for RSA signing\n    config := jwtprovider.NewJWTConfig()\n    config.SigningAlgorithm = jwtprovider.RS256\n    config.ExpirationSeconds = 3600\n    config.Issuer = \"my-app\"\n    config.Audience = \"api\"\n    config.KeyID = \"key-1\" // For JWKS support\n\n    // Set up RSA key pair (PEM encoded PKCS#8)\n    privateKeyPEM := `-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQC7...\n-----END PRIVATE KEY-----`\n\n    publicKeyPEM := `-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAu8...\n-----END PUBLIC KEY-----`\n\n    // Configure private key\n    privateKeyConfig, err := secure.NewKeyConfig([]byte(privateKeyPEM))\n    if err != nil {\n        log.Fatal(err)\n    }\n    config.PrivateKey = privateKeyConfig\n\n    // Configure public key  \n    publicKeyConfig, err := secure.NewKeyConfig([]byte(publicKeyPEM))\n    if err != nil {\n        log.Fatal(err)\n    }\n    config.PublicKey = publicKeyConfig\n\n    // Create provider\n    provider, err := jwtprovider.NewProvider(config)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Generate and parse tokens same as HMAC example...\n}\n</code></pre>"},{"location":"provider/jwtprovider/#token-revocation","title":"Token Revocation","text":""},{"location":"provider/jwtprovider/#setting-up-revocation","title":"Setting Up Revocation","text":"<pre><code>// Create in-memory revocation backend\nrevocationBackend := jwtprovider.NewMemoryRevocationBackend()\n\n// Create revocation manager\nrevocationManager := jwtprovider.NewRevocationManager(revocationBackend)\n\n// Create provider with revocation support\nprovider, err := jwtprovider.NewProvider(config, \n    jwtprovider.WithRevocationManager(revocationManager))\nif err != nil {\n    log.Fatal(err)\n}\n</code></pre>"},{"location":"provider/jwtprovider/#revoking-tokens","title":"Revoking Tokens","text":"<pre><code>// Revoke a specific token\nerr := provider.RevokeToken(tokenString)\nif err != nil {\n    log.Fatal(err)\n}\n\n// Revoke by token ID (from claims)\nclaims, err := provider.ParseToken(tokenString)\nif err != nil {\n    log.Fatal(err)\n}\n\nerr = provider.RevokeTokenByID(claims.ID, claims.ExpiresAt.Time)\nif err != nil {\n    log.Fatal(err)\n}\n\n// Check if token is revoked\nisRevoked := provider.IsTokenRevoked(claims.ID)\nfmt.Printf(\"Token revoked: %v\\n\", isRevoked)\n</code></pre>"},{"location":"provider/jwtprovider/#custom-revocation-backend","title":"Custom Revocation Backend","text":"<pre><code>// Implement custom revocation backend\ntype DatabaseRevocationBackend struct {\n    db *sql.DB\n}\n\nfunc (d *DatabaseRevocationBackend) RevokeToken(tokenID string, expiresAt time.Time) error {\n    _, err := d.db.Exec(\"INSERT INTO revoked_tokens (token_id, expires_at, revoked_at) VALUES (?, ?, ?)\",\n        tokenID, expiresAt, time.Now())\n    return err\n}\n\nfunc (d *DatabaseRevocationBackend) IsTokenRevoked(tokenID string) bool {\n    var count int\n    err := d.db.QueryRow(\"SELECT COUNT(*) FROM revoked_tokens WHERE token_id = ? AND expires_at &gt; ?\",\n        tokenID, time.Now()).Scan(&amp;count)\n    return err == nil &amp;&amp; count &gt; 0\n}\n\n// Implement other RevocationBackend methods...\n\n// Use custom backend\ncustomBackend := &amp;DatabaseRevocationBackend{db: yourDB}\nrevocationManager := jwtprovider.NewRevocationManager(customBackend)\n</code></pre>"},{"location":"provider/jwtprovider/#user-token-tracking","title":"User Token Tracking","text":"<p>The JWT provider supports comprehensive user token tracking for session management, security auditing, and bulk operations.</p>"},{"location":"provider/jwtprovider/#enabling-token-tracking","title":"Enabling Token Tracking","text":"<pre><code>// Configure provider with user token tracking\nconfig := jwtprovider.NewJWTConfig()\nconfig.TrackUserTokens = true    // Enable token tracking\nconfig.MaxUserSessions = 5       // Limit concurrent sessions (0 = unlimited)\n\n// Create revocation manager (required for tracking)\nrevocationMgr := jwtprovider.NewRevocationManager(\n    jwtprovider.NewMemoryRevocationBackend(),\n)\n\nprovider, err := jwtprovider.NewProvider(config,\n    jwtprovider.WithRevocationManager(revocationMgr))\nif err != nil {\n    log.Fatal(err)\n}\ndefer revocationMgr.Close()\n</code></pre>"},{"location":"provider/jwtprovider/#session-management","title":"Session Management","text":"<pre><code>userID := \"user123\"\n\n// Generate token (automatically tracked when enabled)\ntoken, err := provider.GenerateToken(userID, map[string]any{\n    \"role\": \"admin\",\n})\n\n// Handle session limit exceeded\nif err == jwtprovider.ErrMaxSessionsExceeded {\n    return fmt.Errorf(\"maximum concurrent sessions reached\")\n}\n\n// Check active session count\nsessionCount := provider.GetUserSessionCount(userID)\nfmt.Printf(\"Active sessions: %d\\n\", sessionCount)\n\n// Get all active tokens for user\nactiveTokens, err := provider.GetActiveUserTokens(userID)\nif err != nil {\n    log.Fatal(err)\n}\n\nfmt.Printf(\"User has %d active tokens\\n\", len(activeTokens))\nfor i, tokenID := range activeTokens {\n    fmt.Printf(\"  %d. %s\\n\", i+1, tokenID)\n}\n</code></pre>"},{"location":"provider/jwtprovider/#bulk-token-operations","title":"Bulk Token Operations","text":"<pre><code>// Revoke all tokens for a user (e.g., on password change)\nerr := provider.RevokeAllUserTokens(userID)\nif err != nil {\n    log.Fatal(err)\n}\n\n// Useful for security events:\n// - Password reset\n// - Account compromise\n// - Security policy changes\n// - User logout from all devices\n</code></pre>"},{"location":"provider/jwtprovider/#complete-session-management-example","title":"Complete Session Management Example","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"github.com/oddbit-project/blueprint/provider/jwtprovider\"\n)\n\nfunc main() {\n    // Setup provider with session tracking\n    config := jwtprovider.NewJWTConfig()\n    config.TrackUserTokens = true\n    config.MaxUserSessions = 3\n\n    // Set up signing key\n    signingKey := []byte(\"your-secret-key-32-bytes-minimum\")\n    config.CfgSigningKey = &amp;secure.DefaultCredentialConfig{\n        Password: string(signingKey),\n    }\n\n    revocationMgr := jwtprovider.NewRevocationManager(\n        jwtprovider.NewMemoryRevocationBackend(),\n    )\n\n    provider, err := jwtprovider.NewProvider(config,\n        jwtprovider.WithRevocationManager(revocationMgr))\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer revocationMgr.Close()\n\n    userID := \"user123\"\n\n    // Generate multiple tokens\n    fmt.Printf(\"Generating tokens for user %s...\\n\", userID)\n\n    var tokens []string\n    for i := 1; i &lt;= 4; i++ {\n        token, err := provider.GenerateToken(userID, map[string]any{\n            \"session_id\": fmt.Sprintf(\"session_%d\", i),\n        })\n\n        if err != nil {\n            if err == jwtprovider.ErrMaxSessionsExceeded {\n                fmt.Printf(\"Token %d: FAILED - session limit exceeded\\n\", i)\n                continue\n            }\n            log.Fatal(err)\n        }\n\n        tokens = append(tokens, token)\n        fmt.Printf(\"Token %d: SUCCESS\\n\", i)\n\n        count := provider.GetUserSessionCount(userID)\n        fmt.Printf(\"  Current sessions: %d\\n\", count)\n    }\n\n    // Security event: revoke all user tokens\n    fmt.Println(\"\\nSecurity event: revoking all user tokens...\")\n    err = provider.RevokeAllUserTokens(userID)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Verify all tokens are revoked\n    fmt.Println(\"Verifying token revocation...\")\n    for i, token := range tokens {\n        _, err := provider.ParseToken(token)\n        if err != nil {\n            fmt.Printf(\"Token %d: REVOKED \u2713\\n\", i+1)\n        } else {\n            fmt.Printf(\"Token %d: STILL VALID \u2717\\n\", i+1)\n        }\n    }\n\n    finalCount := provider.GetUserSessionCount(userID)\n    fmt.Printf(\"\\nFinal session count: %d\\n\", finalCount)\n}\n</code></pre>"},{"location":"provider/jwtprovider/#security-benefits","title":"Security Benefits","text":"<p>Session Control: - Prevent credential sharing by limiting concurrent sessions - Automatically handle session limits during token generation - Track all active sessions per user</p> <p>Security Response: - Quickly revoke all user tokens during security incidents - Audit trail of token issuance and revocation - Detect unusual session patterns</p> <p>Memory Management: - Automatic cleanup of expired token metadata - Efficient storage with O(1) lookup performance - Background cleanup prevents memory leaks</p>"},{"location":"provider/jwtprovider/#token-metadata","title":"Token Metadata","text":"<p>When tracking is enabled, the provider stores comprehensive metadata:</p> <pre><code>type TokenMetadata struct {\n    TokenID   string    `json:\"tokenId\"`\n    UserID    string    `json:\"userId\"`\n    IssuedAt  time.Time `json:\"issuedAt\"`\n    ExpiresAt time.Time `json:\"expiresAt\"`\n    ClientIP  string    `json:\"clientIP,omitempty\"`   // For future use\n    UserAgent string    `json:\"userAgent,omitempty\"`  // For future use\n}\n</code></pre>"},{"location":"provider/jwtprovider/#error-handling","title":"Error Handling","text":"<pre><code>const (\n    ErrMaxSessionsExceeded = \"maximum concurrent sessions exceeded\"\n)\n\n// Handle session limits\ntoken, err := provider.GenerateToken(userID, data)\nif err != nil {\n    switch err {\n    case jwtprovider.ErrMaxSessionsExceeded:\n        // Inform user about session limit\n        return \"Too many active sessions. Please log out from other devices.\"\n    case jwtprovider.ErrNoRevocationManager:\n        // Tracking requires revocation manager\n        log.Error(\"Token tracking requires revocation manager\")\n    default:\n        log.Errorf(\"Token generation failed: %v\", err)\n    }\n}\n</code></pre>"},{"location":"provider/jwtprovider/#performance-considerations","title":"Performance Considerations","text":"<p>Memory Usage: - O(n) memory where n = number of active tokens - Automatic cleanup of expired metadata - Configurable cleanup intervals</p> <p>Lookup Performance: - O(1) token revocation checks - O(1) user session count queries - O(k) user token retrieval where k = user's token count</p> <p>Concurrency: - Thread-safe operations with read-write locks - Minimal lock contention for read operations - Background cleanup doesn't block operations</p>"},{"location":"provider/jwtprovider/#token-refresh","title":"Token Refresh","text":"<pre><code>// Refresh an existing token\nnewToken, err := provider.Refresh(oldTokenString)\nif err != nil {\n    log.Fatal(err)\n}\n\nfmt.Printf(\"Refreshed token: %s\\n\", newToken)\n</code></pre>"},{"location":"provider/jwtprovider/#claims-structure","title":"Claims Structure","text":"<pre><code>type Claims struct {\n    jwt.RegisteredClaims              // Standard JWT claims\n    Data map[string]any `json:\"data,omitempty\"` // Custom data\n}\n\n// Standard claims include:\n// - Subject (sub)\n// - Issuer (iss) \n// - Audience (aud)\n// - ExpiresAt (exp)\n// - NotBefore (nbf)\n// - IssuedAt (iat)\n// - ID (jti)\n</code></pre>"},{"location":"provider/jwtprovider/#error-handling_1","title":"Error Handling","text":"<pre><code>const (\n    ErrInvalidSigningAlgorithm = \"JWT signing algorithm is invalid\"\n    ErrInvalidToken            = \"invalid token\"\n    ErrTokenExpired            = \"token has expired\"\n    ErrMissingIssuer           = \"issuer validation failed\"\n    ErrMissingAudience         = \"audience validation failed\"\n    ErrNoRevocationManager     = \"revocation manager not available\"\n    ErrTokenAlreadyRevoked     = \"token is already revoked\"\n    ErrInvalidTokenID          = \"invalid token ID\"\n    ErrMaxSessionsExceeded     = \"maximum concurrent sessions exceeded\"\n    ErrTokenTooLarge           = \"token too large\"\n    ErrTokenParsingTimeout     = \"token parsing timeout\"\n)\n\n// Example error handling\ntoken, err := provider.GenerateToken(\"user123\", data)\nif err != nil {\n    switch err {\n    case jwtprovider.ErrInvalidSigningAlgorithm:\n        log.Fatal(\"Invalid signing algorithm configured\")\n    case jwtprovider.ErrMaxSessionsExceeded:\n        log.Printf(\"User has too many concurrent sessions\")\n        // Handle session limit - maybe offer to logout other devices\n    case jwtprovider.ErrTokenTooLarge:\n        log.Printf(\"Token payload too large, reduce custom claims\")\n    default:\n        log.Fatalf(\"Token generation failed: %v\", err)\n    }\n}\n</code></pre>"},{"location":"provider/jwtprovider/#integration-with-http-server","title":"Integration with HTTP Server","text":""},{"location":"provider/jwtprovider/#middleware-integration","title":"Middleware Integration","text":"<pre><code>package main\n\nimport (\n    \"github.com/gin-gonic/gin\"\n    \"github.com/oddbit-project/blueprint/log\"\n    \"github.com/oddbit-project/blueprint/provider/httpserver\"\n    \"github.com/oddbit-project/blueprint/provider/httpserver/auth\"\n    \"github.com/oddbit-project/blueprint/provider/jwtprovider\"\n    \"net/http\"\n    \"os\"\n)\n\nfunc main() {\n    // Configure logger\n    log.Configure(log.NewDefaultConfig())\n    logger := log.New(\"jwt-demo\")\n\n    // Create server config\n    serverConfig := httpserver.NewServerConfig()\n    serverConfig.Host = \"localhost\"\n    serverConfig.Port = 8080\n    serverConfig.Debug = true\n\n    // Create HTTP server\n    server, err := httpserver.NewServer(serverConfig, logger)\n    if err != nil {\n        logger.Fatal(err, \"could not create server\")\n        os.Exit(1)\n    }\n\n    // Set up JWT provider...\n    provider, err := jwtprovider.NewProvider(config)\n    if err != nil {\n        logger.Fatal(err, \"could not create JWT provider\")\n        os.Exit(1)\n    }\n\n    // Public route for login\n    server.Route().POST(\"/login\", loginHandler(provider))\n\n    // Apply JWT authentication to all subsequent routes\n    server.UseAuth(auth.NewAuthJWT(provider))\n\n    // Protected routes\n    server.Route().GET(\"/api/profile\", profileHandler)\n\n    // Start server\n    if err := server.Start(); err != nil {\n        logger.Fatal(err, \"failed to start server\")\n    }\n}\n\nfunc profileHandler(c *gin.Context) {\n    // Get claims using Blueprint auth helper\n    claims, ok := auth.GetClaims(c)\n    if !ok {\n        c.JSON(http.StatusUnauthorized, gin.H{\"error\": \"Unauthorized\"})\n        return\n    }\n    c.JSON(http.StatusOK, gin.H{\"user\": claims})\n}\n\nfunc loginHandler(provider jwtprovider.JWTProvider) gin.HandlerFunc {\n    return func(c *gin.Context) {\n        // Simple authentication\n        var credentials struct {\n            Username string `json:\"username\" binding:\"required\"`\n            Password string `json:\"password\" binding:\"required\"`\n        }\n\n        if err := c.ShouldBindJSON(&amp;credentials); err != nil {\n            c.JSON(http.StatusBadRequest, gin.H{\"error\": \"Invalid request\"})\n            return\n        }\n\n        // Dummy validation\n        if credentials.Username != \"admin\" || credentials.Password != \"secret\" {\n            c.JSON(http.StatusUnauthorized, gin.H{\"error\": \"Invalid credentials\"})\n            return\n        }\n\n        token, err := provider.GenerateToken(credentials.Username, map[string]any{\n            \"role\": \"admin\",\n        })\n        if err != nil {\n            // Handle session limits gracefully\n            if err == jwtprovider.ErrMaxSessionsExceeded {\n                c.JSON(http.StatusTooManyRequests, gin.H{\n                    \"error\": \"Too many active sessions\",\n                    \"message\": \"Please log out from other devices\",\n                    \"active_sessions\": provider.GetUserSessionCount(credentials.Username),\n                })\n                return\n            }\n            c.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to generate token\"})\n            return\n        }\n\n        c.JSON(http.StatusOK, gin.H{\n            \"token\": token,\n            \"active_sessions\": provider.GetUserSessionCount(credentials.Username),\n        })\n    }\n}\n</code></pre>"},{"location":"provider/jwtprovider/#security-best-practices","title":"Security Best Practices","text":""},{"location":"provider/jwtprovider/#key-management","title":"Key Management","text":"<ol> <li>Use strong keys: Minimum 256 bits for HMAC, 2048 bits for RSA</li> <li>Secure storage: Use Blueprint's secure credential system</li> <li>Key rotation: Implement regular key rotation</li> <li>Separate keys: Use different keys for different environments</li> </ol>"},{"location":"provider/jwtprovider/#token-security","title":"Token Security","text":"<ol> <li>Short expiration: Use appropriate token lifetimes (15-60 minutes)</li> <li>Revocation: Implement token revocation for security events</li> <li>Refresh tokens: Use refresh tokens for long-lived sessions</li> <li>Secure transmission: Always use HTTPS</li> <li>Validation: Validate all claims (issuer, audience, expiration)</li> <li>Session limits: Configure reasonable concurrent session limits</li> <li>Input validation: Enable token size limits and parsing timeouts</li> <li>User tracking: Enable token tracking for security audit trails</li> </ol>"},{"location":"provider/jwtprovider/#configuration-security","title":"Configuration Security","text":"<pre><code>// Production configuration example\nconfig := jwtprovider.NewJWTConfig()\nconfig.SigningAlgorithm = jwtprovider.RS256  // Asymmetric algorithm\nconfig.ExpirationSeconds = 900               // 15 minutes\nconfig.Issuer = \"my-production-app\"\nconfig.Audience = \"api-production\"\nconfig.RequireIssuer = true                  // Enforce validation\nconfig.RequireAudience = true                // Enforce validation\nconfig.KeyID = \"prod-key-2024-01\"           // Key identification\nconfig.MaxTokenSize = 8192                   // 8KB token limit\nconfig.TrackUserTokens = true                // Enable session tracking\nconfig.MaxUserSessions = 5                   // Reasonable session limit\n</code></pre>"},{"location":"provider/jwtprovider/#jwks-json-web-key-set-support","title":"JWKS (JSON Web Key Set) Support","text":"<pre><code>// Configure with Key ID for JWKS\nconfig.KeyID = \"my-key-1\"\n\n// The provider will include the \"kid\" header in generated tokens\n// This allows for key rotation and multiple simultaneous keys\n</code></pre>"},{"location":"provider/jwtprovider/#performance-considerations_1","title":"Performance Considerations","text":"<ol> <li>Algorithm choice: HMAC algorithms are faster than asymmetric</li> <li>Key caching: Keys are cached after first use</li> <li>Revocation backend: In-memory backend is fastest, database backend for persistence</li> <li>Token size: Minimize custom claims to reduce token size</li> <li>Validation caching: Consider caching validation results for frequently accessed tokens</li> <li>Token tracking: Adds minimal overhead (O(1) operations, automatic cleanup)</li> <li>Memory usage: User tracking requires O(n) memory where n = active tokens</li> <li>Session limits: Early validation prevents unnecessary token generation</li> </ol>"},{"location":"provider/jwtprovider/#complete-example-application","title":"Complete Example Application","text":"<pre><code>package main\n\nimport (\n    \"github.com/gin-gonic/gin\"\n    \"github.com/oddbit-project/blueprint/log\"\n    \"github.com/oddbit-project/blueprint/provider/httpserver\"\n    \"github.com/oddbit-project/blueprint/provider/httpserver/auth\"\n    \"github.com/oddbit-project/blueprint/provider/jwtprovider\"\n    \"github.com/oddbit-project/blueprint/crypt/secure\"\n    \"net/http\"\n    \"os\"\n)\n\nfunc main() {\n    // Configure logger\n    log.Configure(log.NewDefaultConfig())\n    logger := log.New(\"jwt-demo\")\n\n    // Create server config\n    serverConfig := httpserver.NewServerConfig()\n    serverConfig.Host = \"localhost\"\n    serverConfig.Port = 8080\n    serverConfig.Debug = true\n\n    // Create HTTP server\n    server, err := httpserver.NewServer(serverConfig, logger)\n    if err != nil {\n        logger.Fatal(err, \"could not create server\")\n        os.Exit(1)\n    }\n\n    // Configure JWT provider using proper constructor\n    config := jwtprovider.NewJWTConfig()\n    config.SigningAlgorithm = jwtprovider.HS256\n    config.ExpirationSeconds = 3600\n    config.Issuer = \"demo-app\"\n    config.Audience = \"api\"\n    config.RequireIssuer = true\n    config.RequireAudience = true\n    config.TrackUserTokens = true // Enable session tracking\n    config.MaxUserSessions = 3    // Limit concurrent sessions\n\n    // Generate signing key\n    signingKey, err := secure.GenerateKey()\n    if err != nil {\n        logger.Fatal(err, \"could not generate signing key\")\n        os.Exit(1)\n    }\n\n    config.CfgSigningKey = &amp;secure.DefaultCredentialConfig{Password: string(signingKey)}\n\n    // Create provider with revocation\n    revocationBackend := jwtprovider.NewMemoryRevocationBackend()\n    revocationManager := jwtprovider.NewRevocationManager(revocationBackend)\n\n    provider, err := jwtprovider.NewProvider(config,\n        jwtprovider.WithRevocationManager(revocationManager))\n    if err != nil {\n        logger.Fatal(err, \"could not create JWT provider\")\n        os.Exit(1)\n    }\n\n    // Public login route\n    server.Route().POST(\"/login\", func(c *gin.Context) {\n        // Simple authentication (replace with real auth)\n        var loginReq struct {\n            Username string `json:\"username\" binding:\"required\"`\n            Password string `json:\"password\" binding:\"required\"`\n        }\n\n        if err := c.ShouldBindJSON(&amp;loginReq); err != nil {\n            c.JSON(http.StatusBadRequest, gin.H{\"error\": \"Invalid request\"})\n            return\n        }\n\n        if loginReq.Username == \"admin\" &amp;&amp; loginReq.Password == \"secret\" {\n            token, err := provider.GenerateToken(loginReq.Username, map[string]any{\n                \"role\": \"admin\",\n            })\n            if err != nil {\n                // Handle session limits\n                if err == jwtprovider.ErrMaxSessionsExceeded {\n                    c.JSON(http.StatusTooManyRequests, gin.H{\n                        \"error\": \"Too many active sessions\",\n                        \"active_sessions\": provider.GetUserSessionCount(loginReq.Username),\n                    })\n                    return\n                }\n                c.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to generate token\"})\n                return\n            }\n\n            c.JSON(http.StatusOK, gin.H{\n                \"token\": token,\n                \"active_sessions\": provider.GetUserSessionCount(loginReq.Username),\n            })\n        } else {\n            c.JSON(http.StatusUnauthorized, gin.H{\"error\": \"Invalid credentials\"})\n        }\n    })\n\n    // Apply JWT authentication to protected routes\n    server.UseAuth(auth.NewAuthJWT(provider))\n\n    server.Route().POST(\"/logout\", func(c *gin.Context) {\n        claims, ok := auth.GetClaims(c)\n        if !ok {\n            c.JSON(http.StatusUnauthorized, gin.H{\"error\": \"Unauthorized\"})\n            return\n        }\n\n        err := provider.RevokeTokenByID(claims.ID, claims.ExpiresAt.Time)\n        if err != nil {\n            c.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to logout\"})\n            return\n        }\n\n        c.JSON(http.StatusOK, gin.H{\"message\": \"Logged out successfully\"})\n    })\n\n    server.Route().GET(\"/api/profile\", func(c *gin.Context) {\n        claims, ok := auth.GetClaims(c)\n        if !ok {\n            c.JSON(http.StatusUnauthorized, gin.H{\"error\": \"Unauthorized\"})\n            return\n        }\n        c.JSON(http.StatusOK, gin.H{\"user\": claims})\n    })\n\n    // Session management endpoints\n    server.Route().GET(\"/api/sessions\", func(c *gin.Context) {\n        claims, ok := auth.GetClaims(c)\n        if !ok {\n            c.JSON(http.StatusUnauthorized, gin.H{\"error\": \"Unauthorized\"})\n            return\n        }\n\n        activeTokens, err := provider.GetActiveUserTokens(claims.Subject)\n        if err != nil {\n            c.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to get sessions\"})\n            return\n        }\n\n        c.JSON(http.StatusOK, gin.H{\n            \"active_sessions\": len(activeTokens),\n            \"tokens\": activeTokens,\n        })\n    })\n\n    server.Route().DELETE(\"/api/sessions\", func(c *gin.Context) {\n        claims, ok := auth.GetClaims(c)\n        if !ok {\n            c.JSON(http.StatusUnauthorized, gin.H{\"error\": \"Unauthorized\"})\n            return\n        }\n\n        err := provider.RevokeAllUserTokens(claims.Subject)\n        if err != nil {\n            c.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to revoke sessions\"})\n            return\n        }\n\n        c.JSON(http.StatusOK, gin.H{\"message\": \"All sessions revoked\"})\n    })\n\n    // Start server\n    logger.Info(\"Server starting on http://localhost:8080\")\n    logger.Info(\"Available endpoints:\")\n    logger.Info(\"  POST /login        - Authenticate (public)\")\n    logger.Info(\"  POST /logout       - Logout (protected)\")\n    logger.Info(\"  GET  /api/profile  - User profile (protected)\")\n    logger.Info(\"  GET  /api/sessions - List sessions (protected)\")\n    logger.Info(\"  DELETE /api/sessions - Revoke all sessions (protected)\")\n\n    if err := server.Start(); err != nil {\n        logger.Fatal(err, \"failed to start server\")\n    }\n}\n</code></pre>"},{"location":"provider/kafka/","title":"blueprint.provider.kafka","text":"<p>Blueprint Kafka client with enhanced security and performance features.</p> <p>The client supports the following authentication modes: - <code>none</code> - No authentication - <code>plain</code> - SASL PLAIN authentication - <code>scram256</code> - SCRAM-SHA-256 authentication - <code>scram512</code> - SCRAM-SHA-512 authentication</p>"},{"location":"provider/kafka/#features","title":"Features","text":"<ul> <li>Secure credential handling with in-memory encryption</li> <li>TLS support for secure connections</li> <li>Configurable producer options for performance tuning</li> <li>JSON message support</li> <li>Context-aware logging with tracing</li> <li>Batch operations</li> </ul>"},{"location":"provider/kafka/#using-the-kafka-producer","title":"Using the Kafka Producer","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"github.com/oddbit-project/blueprint/log\"\n    \"github.com/oddbit-project/blueprint/provider/kafka\"\n    tlsProvider \"github.com/oddbit-project/blueprint/provider/tls\"\n    \"time\"\n)\n\nfunc main() {\n    ctx := context.Background()\n    logger := log.NewLogger(\"kafka-example\")\n\n    // Configure the producer\n    producerCfg := &amp;kafka.ProducerConfig{\n        Brokers:  \"localhost:9093\",\n        Topic:    \"test_topic\",\n        AuthType: \"scram256\",\n        Username: \"someUsername\",\n        DefaultCredentialConfig: secure.DefaultCredentialConfig{\n            Password: \"somePassword\",\n            // Or use environment variables or files\n            // PasswordEnvVar: \"KAFKA_PASSWORD\",\n            // PasswordFile: \"/path/to/password.txt\",\n        },\n        ClientConfig: tlsProvider.ClientConfig{\n            TLSEnable: true,\n            TLSCA: \"/path/to/ca.crt\",\n        },\n        ProducerOptions: kafka.ProducerOptions{\n            BatchSize: 100,\n            BatchTimeout: 1000, // ms\n            RequiredAcks: \"one\",\n            Async: true,\n        },\n    }\n\n    // Create the producer\n    producer, err := kafka.NewProducer(producerCfg, logger)\n    if err != nil {\n        logger.Fatal(err, \"Failed to create Kafka producer\", nil)\n    }\n    defer producer.Disconnect()\n\n    // Write a simple message\n    err = producer.Write(ctx, []byte(\"Hello, Kafka!\"))\n    if err != nil {\n        logger.Error(err, \"Failed to write message\", nil)\n    }\n\n    // Write with a key\n    err = producer.Write(ctx, []byte(\"Message with key\"), []byte(\"user-123\"))\n    if err != nil {\n        logger.Error(err, \"Failed to write message with key\", nil)\n    }\n\n    // Write a JSON message\n    type User struct {\n        ID   string `json:\"id\"`\n        Name string `json:\"name\"`\n    }\n\n    user := User{\n        ID:   \"123\",\n        Name: \"John Doe\",\n    }\n\n    err = producer.WriteJson(ctx, user)\n    if err != nil {\n        logger.Error(err, \"Failed to write JSON message\", nil)\n    }\n\n    // Write multiple messages\n    messages := [][]byte{\n        []byte(\"Message 1\"),\n        []byte(\"Message 2\"),\n        []byte(\"Message 3\"),\n    }\n\n    err = producer.WriteMulti(ctx, messages...)\n    if err != nil {\n        logger.Error(err, \"Failed to write multiple messages\", nil)\n    }\n}\n</code></pre>"},{"location":"provider/kafka/#using-the-kafka-consumer","title":"Using the Kafka Consumer","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"github.com/oddbit-project/blueprint/log\"\n    \"github.com/oddbit-project/blueprint/provider/kafka\"\n    tlsProvider \"github.com/oddbit-project/blueprint/provider/tls\"\n    \"time\"\n)\n\nfunc main() {\n    logger := log.NewLogger(\"kafka-consumer\")\n\n    // Configure the consumer\n    consumerCfg := &amp;kafka.ConsumerConfig{\n        Brokers:  \"localhost:9093\",\n        Topic:    \"test_topic\",\n        Group:    \"consumer_group_1\",\n        AuthType: \"scram256\",\n        Username: \"someUsername\",\n        DefaultCredentialConfig: secure.DefaultCredentialConfig{\n            Password: \"somePassword\",\n            // Or use environment variables or files\n            // PasswordEnvVar: \"KAFKA_PASSWORD\",\n            // PasswordFile: \"/path/to/password.txt\",\n        },\n        ClientConfig: tlsProvider.ClientConfig{\n            TLSEnable: true,\n            TLSCA: \"/path/to/ca.crt\",\n        },\n        ConsumerOptions: kafka.ConsumerOptions{\n            MinBytes: 10,\n            MaxBytes: 10485760, // 10MB\n            MaxWait: 1000,      // ms\n        },\n    }\n\n    // Create a context with timeout\n    timeout := 30 * time.Second\n    ctx, cancel := context.WithTimeout(context.Background(), timeout)\n    defer cancel()\n\n    // Create the consumer\n    consumer, err := kafka.NewConsumer(consumerCfg, logger)\n    if err != nil {\n        logger.Fatal(err, \"Failed to create Kafka consumer\", nil)\n    }\n    defer consumer.Disconnect()\n\n    // Read a single message\n    msg, err := consumer.ReadMessage(ctx)\n    if err != nil {\n        logger.Error(err, \"Failed to read message\", nil)\n    } else {\n        logger.Info(\"Received message\", log.KV{\n            \"value\": string(msg.Value),\n            \"key\": string(msg.Key),\n            \"topic\": msg.Topic,\n            \"partition\": msg.Partition,\n            \"offset\": msg.Offset,\n        })\n    }\n\n    // Process messages in a loop\n    for {\n        select {\n        case &lt;-ctx.Done():\n            logger.Info(\"Context done, stopping consumer\", nil)\n            return\n        default:\n            msg, err := consumer.ReadMessage(ctx)\n            if err != nil {\n                logger.Error(err, \"Error reading message\", nil)\n                continue\n            }\n\n            // Process the message\n            logger.Info(\"Processing message\", log.KV{\n                \"value_len\": len(msg.Value),\n            })\n\n            // Parse JSON messages\n            if consumer.IsJsonMessage(msg) {\n                var data map[string]interface{}\n                if err := consumer.DecodeJson(msg, &amp;data); err != nil {\n                    logger.Error(err, \"Failed to decode JSON message\", nil)\n                } else {\n                    logger.Info(\"Received JSON message\", data)\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"provider/kafka/#performance-tuning","title":"Performance Tuning","text":"<p>The Kafka producer can be tuned for performance using the <code>ProducerOptions</code> struct:</p> <pre><code>type ProducerOptions struct {\n    MaxAttempts     uint   // Maximum number of retries\n    WriteBackoffMin uint   // Minimum backoff in milliseconds\n    WriteBackoffMax uint   // Maximum backoff in milliseconds\n    BatchSize       uint   // Number of messages in a batch\n    BatchBytes      uint64 // Maximum batch size in bytes\n    BatchTimeout    uint   // Time to wait for batch completion in milliseconds\n    ReadTimeout     uint   // Read timeout in milliseconds\n    WriteTimeout    uint   // Write timeout in milliseconds\n    RequiredAcks    string // Acknowledgment level: \"none\", \"one\", \"all\"\n    Async           bool   // Async mode (non-blocking writes)\n}\n</code></pre> <p>Similarly, the consumer can be tuned using the <code>ConsumerOptions</code> struct:</p> <pre><code>type ConsumerOptions struct {\n    MinBytes        uint   // Minimum number of bytes to fetch\n    MaxBytes        uint   // Maximum number of bytes to fetch\n    MaxWait         uint   // Maximum time to wait for data in milliseconds\n    ReadLagInterval uint   // Interval to update lag information in milliseconds\n    HeartbeatInterval uint // Heartbeat interval in milliseconds\n    CommitInterval uint    // Auto-commit interval in milliseconds\n    StartOffset     string // Where to start reading: \"newest\", \"oldest\"\n}\n</code></pre>"},{"location":"provider/kafka/#security-best-practices","title":"Security Best Practices","text":"<ol> <li>Always enable TLS in production environments</li> <li>Use SCRAM authentication instead of PLAIN when possible</li> <li>Store passwords in environment variables or secure files</li> <li>Rotate credentials regularly</li> <li>Limit topic access with proper ACLs</li> </ol>"},{"location":"provider/mqtt/","title":"blueprint.provider.mqtt","text":"<p>Blueprint MQTT client</p>"},{"location":"provider/mqtt/#configuration","title":"Configuration","text":"<p>The MQTT client uses the following configuration:</p> <pre><code>{\n  \"mqtt\": {\n    \"brokers\": [\"127.0.0.1:1883\"],\n    \"protocol\": \"tcp\",\n    \"username\": \"\",\n    \"password\": \"\",\n    \"timeout\": 5,\n    \"connectionTimeout\": 30,\n    \"qos\": 0,\n    \"clientId\": \"\",\n    \"retain\": false,\n    \"keepAlive\": 0,\n    \"autoReconnect\": true,\n    \"persistentSession\": false,\n    \"tlsEnable\": false,\n    \"tlsCa\": \"\",\n    \"tlsCert\": \"\",\n    \"tlsKey\": \"\",\n    \"tlsKeyPassword\": \"\",\n    \"tlsInsecureVerify\": true\n  }\n}\n</code></pre>"},{"location":"provider/mqtt/#using-the-mqtt-client","title":"Using the MQTT client","text":"<pre><code>package main\n\nimport (\n paho \"github.com/eclipse/paho.mqtt.golang\"\n \"github.com/oddbit-project/blueprint/log/zerolog/writer\"\n \"github.com/oddbit-project/blueprint/provider/mqtt\"\n \"github.com/rs/zerolog/log\"\n \"time\"\n)\n\nfunc main() {\n    // use zerolog as logger with console writer\n    writer.UseDefaultWriter()\n\n    cfg := mqtt.NewConfig()\n    cfg.Username = \"testUser\"\n    cfg.Password = \"someTestPassword\"\n    cfg.Protocol = \"tcp\"\n    cfg.Retain = false\n    cfg.TLSEnable = true\n    cfg.TLSInsecureSkipVerify = true\n    cfg.TLSCA = \"../../infra/mosquitto/config/certs/ca.crt\"\n    cfg.TLSCert = \"../../infra/mosquitto/config/certs/client.crt\"\n    cfg.TLSKey = \"../../infra/mosquitto/config/certs/client.key\"\n    cfg.QoS = 0\n    cfg.PersistentSession = false\n    cfg.Brokers = []string{\"localhost:18883\"}\n\n    client, err := mqtt.NewClient(cfg)\n    if err != nil {\n        log.Fatal().Msgf(\"cannot initialize mqtt: %v\", err)\n    }\n    _, err = client.Connect()\n    if err != nil {\n        log.Fatal().Msgf(\"cannot connect to mqtt: %v\", err)\n    }\n    defer client.Close()\n\n    topicName := \"blueprint/test\"\n    message := []byte(\"the quick brown fox jumps over the lazy dog\")\n\n    var received []byte = nil\n    // subscribe topic\n    client.Subscribe(topicName, 2, func(c paho.Client, msg paho.Message) {\n        log.Info().Msgf(\"Received message: %s\", msg.Payload())\n        received = msg.Payload()\n    })\n\n    // write to topic\n    log.Info().Msgf(\"Writing message: %v\", string(message))\n    client.Write(topicName, message)\n\n    for received == nil {\n        // sleep 10ms each time\n        time.Sleep(10 * time.Millisecond)\n    }\n}\n</code></pre>"},{"location":"provider/nats/","title":"blueprint.provider.nats","text":"<p>Blueprint NATS client implementation for message publishing and consumption.</p>"},{"location":"provider/nats/#overview","title":"Overview","text":"<p>The NATS client provides a simple interface for connecting to NATS servers, publishing messages, and consuming messages using subjects and queues. It supports:</p> <ul> <li>Multiple authentication methods (none, basic, token, NKey, JWT)</li> <li>TLS for secure connections</li> <li>Publish/Subscribe patterns</li> <li>Request/Reply patterns</li> <li>Queue groups for distributing message processing</li> <li>JSON serialization for structured messages</li> </ul>"},{"location":"provider/nats/#configuration","title":"Configuration","text":""},{"location":"provider/nats/#producer-configuration","title":"Producer Configuration","text":"<pre><code>type ProducerConfig struct {\n    URL      string // NATS server URL (e.g., \"nats://localhost:4222\")\n    Subject  string // Default subject to publish to\n    AuthType string // Authentication type: \"none\", \"basic\", \"token\", \"nkey\", \"jwt\"\n    Username string // Username for basic auth\n    Password string // Password for basic auth\n    NKeyPath string // Path to NKey seed file\n    JwtPath  string // Path to JWT file\n    Token    string // Auth token\n\n    // Connection settings\n    PingInterval uint // PingInterval in seconds, defaults to 2 minutes\n    MaxPingsOut  uint // MaxPingsOut value, defaults to 2\n    Timeout      uint // Connection timeout in milliseconds, defaults to 2000\n    DrainTimeout uint // Drain timeout in milliseconds, defaults to 30000\n\n    // TLS Configuration\n    TLSEnabled            bool   // Enable TLS\n    TLSInsecureSkipVerify bool   // Skip certificate verification\n    TLSCertFile           string // Client certificate file path\n    TLSKeyFile            string // Client key file path\n    TLSCaFile             string // CA certificate file path\n}\n</code></pre>"},{"location":"provider/nats/#consumer-configuration","title":"Consumer Configuration","text":"<pre><code>type ConsumerConfig struct {\n    URL        string // NATS server URL (e.g., \"nats://localhost:4222\")\n    Subject    string // Subject pattern to subscribe to\n    AuthType   string // Authentication type: \"none\", \"basic\", \"token\", \"nkey\", \"jwt\"\n    Username   string // Username for basic auth\n    Password   string // Password for basic auth\n    NKeyPath   string // Path to NKey seed file\n    JwtPath    string // Path to JWT file\n    Token      string // Auth token\n    QueueGroup string // Queue group for distributing messages among subscribers\n\n    // Connection settings\n    PingInterval uint // PingInterval in seconds, defaults to 2 minutes\n    MaxPingsOut  uint // MaxPingsOut value, defaults to 2\n    Timeout      uint // Connection timeout in milliseconds, defaults to 2000\n    DrainTimeout uint // Drain timeout in milliseconds, defaults to 30000\n\n    // TLS Configuration\n    TLSEnabled            bool   // Enable TLS\n    TLSInsecureSkipVerify bool   // Skip certificate verification\n    TLSCertFile           string // Client certificate file path\n    TLSKeyFile            string // Client key file path\n    TLSCaFile             string // CA certificate file path\n}\n</code></pre>"},{"location":"provider/nats/#producer-usage","title":"Producer Usage","text":""},{"location":"provider/nats/#creating-a-producer","title":"Creating a Producer","text":"<pre><code>package main\n\nimport (\n    \"github.com/oddbit-project/blueprint/log\"\n    \"github.com/oddbit-project/blueprint/provider/nats\"\n)\n\nfunc main() {\n    // Create producer configuration\n    config := &amp;nats.ProducerConfig{\n        URL:      \"nats://localhost:4222\",\n        Subject:  \"my.subject\",\n        AuthType: nats.AuthTypeNone,\n    }\n\n    // Create logger\n    logger := log.NewLogger()\n\n    // Create producer\n    producer, err := nats.NewProducer(config, logger)\n    if err != nil {\n        logger.Fatal(err, \"Failed to create NATS producer\", nil)\n    }\n    defer producer.Disconnect()\n\n    // Publish message\n    err = producer.Publish([]byte(\"Hello, NATS!\"))\n    if err != nil {\n        logger.Error(err, \"Failed to publish message\", nil)\n    }\n\n    // Publish JSON message\n    type Person struct {\n        Name string `json:\"name\"`\n        Age  int    `json:\"age\"`\n    }\n\n    person := Person{\n        Name: \"John Doe\",\n        Age:  30,\n    }\n\n    err = producer.PublishJSON(person)\n    if err != nil {\n        logger.Error(err, \"Failed to publish JSON message\", nil)\n    }\n}\n</code></pre>"},{"location":"provider/nats/#request-reply-pattern","title":"Request-Reply Pattern","text":"<pre><code>// Send a request and wait for a response\nmsg, err := producer.Request(\"request.subject\", []byte(\"Request data\"), time.Second*5)\nif err != nil {\n    logger.Error(err, \"Request failed\", nil)\n    return\n}\n\n// Process response\nlogger.Info(\"Received response\", log.KV{\n    \"data\": string(msg.Data),\n})\n</code></pre>"},{"location":"provider/nats/#consumer-usage","title":"Consumer Usage","text":""},{"location":"provider/nats/#creating-a-consumer","title":"Creating a Consumer","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"github.com/oddbit-project/blueprint/log\"\n    \"github.com/oddbit-project/blueprint/provider/nats\"\n    \"time\"\n)\n\nfunc main() {\n    // Create consumer configuration\n    config := &amp;nats.ConsumerConfig{\n        URL:      \"nats://localhost:4222\",\n        Subject:  \"my.subject\",\n        AuthType: nats.AuthTypeNone,\n        ConsumerOptions: nats.ConsumerOptions{\n            QueueGroup: \"my-service\",\n        },\n    }\n\n    // Create logger\n    logger := log.NewLogger()\n\n    // Create consumer\n    consumer, err := nats.NewConsumer(config, logger)\n    if err != nil {\n        logger.Fatal(err, \"Failed to create NATS consumer\", nil)\n    }\n    defer consumer.Disconnect()\n\n    // Create context with cancellation\n    ctx, cancel := context.WithCancel(context.Background())\n    defer cancel()\n\n    // Define message handler\n    handler := func(ctx context.Context, msg nats.Message) error {\n        logger.Info(\"Received message\", log.KV{\n            \"subject\": msg.Subject,\n            \"data\":    string(msg.Data),\n        })\n        return nil\n    }\n\n    // Subscribe to subject\n    err = consumer.Subscribe(ctx, handler)\n    if err != nil {\n        logger.Error(err, \"Failed to subscribe\", nil)\n        return\n    }\n\n    // Keep running for 1 minute\n    time.Sleep(time.Minute)\n}\n</code></pre>"},{"location":"provider/nats/#synchronous-message-consumption","title":"Synchronous Message Consumption","text":"<pre><code>// Subscribe synchronously\nsub, err := consumer.SubscribeSync()\nif err != nil {\n    logger.Error(err, \"Failed to subscribe\", nil)\n    return\n}\n\n// Get next message with timeout\nmsg, err := consumer.NextMsg(sub, time.Second*5)\nif err != nil {\n    if err == nats.ErrTimeout {\n        logger.Info(\"No message received within timeout\", nil)\n    } else {\n        logger.Error(err, \"Failed to get next message\", nil)\n    }\n    return\n}\n\n// Process message\nlogger.Info(\"Received message\", log.KV{\n    \"subject\": msg.Subject,\n    \"data\":    string(msg.Data),\n})\n\n// Unsubscribe when done\nconsumer.Unsubscribe(sub)\n</code></pre>"},{"location":"provider/nats/#authentication-methods","title":"Authentication Methods","text":""},{"location":"provider/nats/#basic-authentication","title":"Basic Authentication","text":"<pre><code>config := &amp;nats.ProducerConfig{\n    URL:      \"nats://localhost:4222\",\n    Subject:  \"my.subject\",\n    AuthType: nats.AuthTypeBasic,\n    Username: \"user\",\n    Password: \"password\",\n}\n</code></pre>"},{"location":"provider/nats/#token-authentication","title":"Token Authentication","text":"<pre><code>config := &amp;nats.ProducerConfig{\n    URL:      \"nats://localhost:4222\",\n    Subject:  \"my.subject\",\n    AuthType: nats.AuthTypeToken,\n    Token:    \"my-auth-token\",\n}\n</code></pre>"},{"location":"provider/nats/#nkey-authentication","title":"NKey Authentication","text":"<pre><code>config := &amp;nats.ProducerConfig{\n    URL:      \"nats://localhost:4222\",\n    Subject:  \"my.subject\",\n    AuthType: nats.AuthTypeNKey,\n    NKeyPath: \"/path/to/nkey.seed\",\n}\n</code></pre>"},{"location":"provider/nats/#jwt-authentication","title":"JWT Authentication","text":"<pre><code>config := &amp;nats.ProducerConfig{\n    URL:      \"nats://localhost:4222\",\n    Subject:  \"my.subject\",\n    AuthType: nats.AuthTypeJWT,\n    JwtPath:  \"/path/to/user.jwt\",\n}\n</code></pre>"},{"location":"provider/nats/#tls-configuration","title":"TLS Configuration","text":"<pre><code>config := &amp;nats.ProducerConfig{\n    URL:      \"nats://localhost:4222\",\n    Subject:  \"my.subject\",\n    AuthType: nats.AuthTypeNone,\n\n    // TLS Configuration\n    TLSEnabled:            true,\n    TLSInsecureSkipVerify: false,\n    TLSCertFile:           \"/path/to/client.crt\",\n    TLSKeyFile:            \"/path/to/client.key\",\n    TLSCaFile:             \"/path/to/ca.crt\",\n}\n</code></pre>"},{"location":"provider/pgsql/","title":"blueprint.provider.pgsql","text":"<p>Blueprint PostgreSQL client</p> <p>The client uses the pgx library.</p>"},{"location":"provider/pgsql/#using-the-client","title":"Using the client","text":"<p>The PostgreSQL client relies on a single DSN string:</p> <pre><code>{\n  \"clickhouse\": {\n    \"dsn\": \"postgres://username:password@localhost:5432/database?sslmode=allow\"\n  }\n}\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"github.com/oddbit-project/blueprint/provider/pgsql\"\n    \"log\"\n    \"os\"\n)\n\nfunc main() {\n    pgConfig := pgsql.NewClientConfig()\n    pgConfig.DSN = \"postgres://username:password@localhost:5432/database?sslmode=allow\"\n\n    client, err := pgsql.NewClient(pgConfig)\n    if err != nil {\n        log.Fatal(err)\n    }\n    if err = client.Connect(); err != nil {\n        log.Fatal(err)\n    }\n    defer client.Disconnect()\n\n    // do stuff\n}\n</code></pre>"},{"location":"provider/tls/","title":"TLS Provider","text":"<p>The TLS provider offers enhanced security for client and server connections by providing robust TLS configuration options. It supports certificate verification, custom cipher suites, and secure defaults.</p>"},{"location":"provider/tls/#client-configuration","title":"Client Configuration","text":"<p>The <code>ClientConfig</code> struct provides options for configuring TLS on clients:</p> <pre><code>import (\n    \"github.com/oddbit-project/blueprint/provider/tls\"\n)\n\n// Create a new client configuration\nclientConfig := &amp;tls.ClientConfig{\n    TLSCA: \"/path/to/ca.crt\",      // Root CA certificate for verifying server\n    TLSCert: \"/path/to/client.crt\", // Client certificate for mutual TLS\n    TLSKey: \"/path/to/client.key\",  // Client private key\n    TLSEnable: true,                // Enable TLS\n    TLSInsecureSkipVerify: false,   // Verify server certificate (recommended)\n}\n\n// For encrypted keys, set the key password\nclientConfig.TlsKeyCredential.Key = \"keypassword\"\n// Or use environment variables\nclientConfig.TlsKeyCredential.KeyEnvVar = \"KEY_PASSWORD\"\n// Or use a file\nclientConfig.TlsKeyCredential.KeyFile = \"/path/to/keypassword.txt\"\n\n// Generate the TLS configuration\ntlsConfig, err := clientConfig.TLSConfig()\nif err != nil {\n    // handle error\n}\n\n// Use tlsConfig with your client implementation\n// ...\n</code></pre>"},{"location":"provider/tls/#server-configuration","title":"Server Configuration","text":"<p>The <code>ServerConfig</code> struct provides options for configuring TLS on servers with enhanced security features:</p> <pre><code>import (\n    \"github.com/oddbit-project/blueprint/provider/tls\"\n)\n\n// Create a new server configuration\nserverConfig := &amp;tls.ServerConfig{\n    TLSCert: \"/path/to/server.crt\",                    // Server certificate\n    TLSKey: \"/path/to/server.key\",                     // Server private key\n    TLSAllowedCACerts: []string{\"/path/to/ca.crt\"},    // CA certs for client verification\n    TLSCipherSuites: []string{\"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\"}, // Custom cipher suites\n    TLSMinVersion: \"1.3\",                              // Minimum TLS version\n    TLSMaxVersion: \"1.3\",                              // Maximum TLS version\n    TLSAllowedDNSNames: []string{\"client.example.com\"}, // Allowed client cert names\n    TLSEnable: true,                                   // Enable TLS\n}\n\n// For encrypted keys, set the key password\nserverConfig.TlsKeyCredential.Key = \"keypassword\"\n// Or use environment variables\nserverConfig.TlsKeyCredential.KeyEnvVar = \"KEY_PASSWORD\"\n// Or use a file\nserverConfig.TlsKeyCredential.KeyFile = \"/path/to/keypassword.txt\"\n\n// Generate the TLS configuration\ntlsConfig, err := serverConfig.TLSConfig()\nif err != nil {\n    // handle error\n}\n\n// Use tlsConfig with your server implementation\n// ...\n</code></pre>"},{"location":"provider/tls/#security-features","title":"Security Features","text":""},{"location":"provider/tls/#enhanced-certificate-verification","title":"Enhanced Certificate Verification","text":"<p>The server configuration includes advanced certificate verification that checks:</p> <ul> <li>Certificate validity dates</li> <li>Allowed DNS names in client certificates</li> <li>Certificate integrity</li> </ul>"},{"location":"provider/tls/#secure-defaults","title":"Secure Defaults","text":"<ul> <li>TLS 1.3 is used by default for both clients and servers</li> <li>Strong cipher suites are preferred</li> <li>Client authentication is properly enforced when enabled</li> </ul>"},{"location":"provider/tls/#mutual-tls-support","title":"Mutual TLS Support","text":"<p>Both client and server configurations support mutual TLS authentication, where:</p> <ul> <li>Servers verify client certificates</li> <li>Clients verify server certificates</li> </ul>"},{"location":"provider/tls/#best-practices","title":"Best Practices","text":"<ol> <li>Always use TLS 1.3 when possible</li> <li>Avoid using <code>TLSInsecureSkipVerify: true</code> in production</li> <li>Regularly rotate certificates</li> <li>Protect private keys with strong passwords</li> <li>Use mutual TLS for sensitive services</li> </ol>"},{"location":"provider/httpserver/","title":"HTTP Server Framework","text":"<p>Blueprint provides a comprehensive HTTP server framework built on Gin with integrated security, authentication,  session management, and middleware components for building robust web applications and APIs.</p>"},{"location":"provider/httpserver/#architecture-overview","title":"Architecture Overview","text":"<p>The HTTP server framework consists of several key components:</p> <ul> <li>Core Server: HTTP server setup and lifecycle management with TLS support</li> <li>Session Management: Cookie-based sessions with multiple storage backends and encryption</li> <li>Security: Comprehensive security headers, CSRF protection, and rate limiting</li> <li>Authentication: Token-based, JWT, and session-based authentication providers</li> <li>Middleware: Extensible middleware system with security and utility components</li> <li>Device Fingerprinting: Multi-factor device identification for enhanced security</li> </ul>"},{"location":"provider/httpserver/#features","title":"Features","text":""},{"location":"provider/httpserver/#core-features","title":"Core Features","text":"<ul> <li>Gin Framework Integration: High-performance HTTP router with middleware support</li> <li>Graceful Shutdown: Proper server lifecycle management with context handling</li> <li>TLS Configuration: Built-in HTTPS support with certificate management</li> <li>Structured Logging: Integrated logging with configurable levels</li> <li>Configuration Management: JSON-based configuration with validation</li> </ul>"},{"location":"provider/httpserver/#security-features","title":"Security Features","text":"<ul> <li>Session Management: Secure cookie-based sessions with encryption</li> <li>CSRF Protection: Token-based protection against cross-site request forgery</li> <li>Security Headers: Comprehensive browser security protections (CSP, HSTS, XSS protection)</li> <li>Rate Limiting: Token bucket algorithm with per-IP and per-endpoint controls</li> <li>Device Fingerprinting: Multi-factor device identification and change detection</li> </ul>"},{"location":"provider/httpserver/#authentication-authorization","title":"Authentication &amp; Authorization","text":"<ul> <li>Multiple Auth Providers: JWT, HMAC, token-based, and session-based authentication</li> <li>Unified Interface: Consistent authentication API across all providers</li> <li>Context Integration: Authentication data available in request context</li> <li>Flexible Authorization: Route-based and middleware-based protection</li> </ul>"},{"location":"provider/httpserver/#quick-start","title":"Quick Start","text":""},{"location":"provider/httpserver/#basic-http-server","title":"Basic HTTP Server","text":"<pre><code>package main\n\nimport (\n    \"github.com/oddbit-project/blueprint/provider/httpserver\"\n    \"github.com/oddbit-project/blueprint/log\"\n)\n\nfunc main() {\n    logger := log.New(\"http-server\")\n\n    // Create server configuration\n    config := httpserver.NewConfig()\n    config.Host = \"localhost\"\n    config.Port = 8080\n\n    // Create and start server\n    server := httpserver.NewServer(config, logger)\n\n    // Add routes\n    server.Router().GET(\"/health\", func(c *gin.Context) {\n        c.JSON(200, gin.H{\"status\": \"healthy\"})\n    })\n\n    // Start server\n    if err := server.Start(); err != nil {\n        logger.Fatal(err, \"failed to start server\")\n    }\n}\n</code></pre>"},{"location":"provider/httpserver/#server-with-sessions-and-security","title":"Server with Sessions and Security","text":"<pre><code>package main\n\nimport (\n    \"github.com/oddbit-project/blueprint/provider/httpserver\"\n    \"github.com/oddbit-project/blueprint/provider/httpserver/session\"\n    \"github.com/oddbit-project/blueprint/provider/httpserver/security\"\n    \"github.com/oddbit-project/blueprint/provider/kv\"\n    \"github.com/oddbit-project/blueprint/log\"\n)\n\nfunc main() {\n    logger := log.New(\"secure-server\")\n\n    // Server configuration\n    config := httpserver.NewConfig()\n    config.Host = \"localhost\"\n    config.Port = 8080\n\n    server := httpserver.NewServer(config, logger)\n\n    // Session configuration\n    sessionConfig := session.NewConfig()\n    sessionConfig.Secure = true\n    sessionConfig.HttpOnly = true\n\n    // Use memory-based session store\n    backend := kv.NewMemoryKV()\n    sessionManager, err := server.UseSession(sessionConfig, backend, logger)\n    if err != nil {\n        logger.Fatal(err, \"failed to setup sessions\")\n    }\n\n    // Apply security headers\n    securityConfig := security.DefaultSecurityConfig()\n    server.Router().Use(security.SecurityMiddleware(securityConfig))\n\n    // Apply CSRF protection\n    server.Router().Use(security.CSRFProtection())\n\n    // Apply rate limiting\n    server.Router().Use(security.RateLimitMiddleware(rate.Every(time.Second), 10))\n\n    // Routes\n    setupRoutes(server)\n\n    // Start server\n    if err := server.Start(); err != nil {\n        logger.Fatal(err, \"failed to start server\")\n    }\n}\n\nfunc setupRoutes(server *httpserver.Server) {\n    router := server.Router()\n\n    // Public routes\n    router.GET(\"/\", homeHandler)\n    router.GET(\"/login\", loginFormHandler)\n    router.POST(\"/login\", loginHandler)\n\n    // Protected routes with session authentication\n    protected := router.Group(\"/dashboard\")\n    protected.Use(auth.AuthMiddleware(auth.NewAuthSession(&amp;UserIdentity{}))) // &amp;UserIdentity{} is the user identity type to be used\n    {\n        protected.GET(\"/\", dashboardHandler)\n        protected.POST(\"/logout\", logoutHandler)\n    }\n}\n</code></pre>"},{"location":"provider/httpserver/#components","title":"Components","text":""},{"location":"provider/httpserver/#core-server-api","title":"Core Server API","text":"<ul> <li>API Reference - Complete server API documentation</li> <li>Server lifecycle management (start, stop, graceful shutdown)</li> <li>Configuration options and environment variables</li> <li>Router and handler registration</li> </ul>"},{"location":"provider/httpserver/#session-management","title":"Session Management","text":"<ul> <li>Session Management - Comprehensive session system</li> <li>Multiple storage backends (memory, Redis, custom KV stores)</li> <li>Cookie security configuration (HttpOnly, Secure, SameSite)</li> <li>Session encryption with AES256GCM</li> <li>Flash messages and session regeneration</li> <li>Automatic cleanup and expiration handling</li> </ul>"},{"location":"provider/httpserver/#security-features_1","title":"Security Features","text":"<ul> <li>Security - Complete security middleware</li> <li>Security headers (CSP with nonce support, HSTS, XSS protection, frame options)</li> <li>CSRF protection with token generation and validation</li> <li>Rate limiting with token bucket algorithm and per-IP tracking</li> <li>Device fingerprinting for enhanced security</li> </ul>"},{"location":"provider/httpserver/#authentication-authorization_1","title":"Authentication &amp; Authorization","text":"<ul> <li>Authentication - All authentication providers</li> <li>JWT authentication with claims context injection</li> <li>Token-based authentication for APIs</li> <li>Session-based authentication for web applications</li> <li>HMAC authentication for secure service communication</li> <li>Custom authentication provider development</li> </ul>"},{"location":"provider/httpserver/#middleware-components","title":"Middleware Components","text":"<ul> <li>Middleware Guide - All available middleware</li> <li>Response helpers and standardized error handling</li> <li>Custom middleware development patterns</li> <li>Middleware ordering and best practices</li> </ul>"},{"location":"provider/httpserver/#configuration","title":"Configuration","text":""},{"location":"provider/httpserver/#server-configuration","title":"Server Configuration","text":"<pre><code>type ServerConfig struct {\n    Host         string            `json:\"host\"`         // Server host (default: \"localhost\")\n    Port         int               `json:\"port\"`         // Server port (default: 8080)\n    CertFile     string            `json:\"certFile\"`     // TLS certificate file\n    CertKeyFile  string            `json:\"certKeyFile\"`  // TLS private key file\n    ReadTimeout  int               `json:\"readTimeout\"`  // Read timeout in seconds\n    WriteTimeout int               `json:\"writeTimeout\"` // Write timeout in seconds\n    Debug        bool              `json:\"debug\"`        // Enable debug mode\n    Options      map[string]string `json:\"options\"`      // Additional options\n}\n</code></pre>"},{"location":"provider/httpserver/#session-configuration","title":"Session Configuration","text":"<pre><code>type SessionConfig struct {\n    CookieName             string                         `json:\"cookieName\"`             // Cookie name (default: \"blueprint_session\")\n    ExpirationSeconds      int                            `json:\"expirationSeconds\"`      // Session lifetime (default: 1800)\n    IdleTimeoutSeconds     int                            `json:\"idleTimeoutSeconds\"`     // Idle timeout (default: 900)\n    Secure                 bool                           `json:\"secure\"`                 // HTTPS only (default: true)\n    HttpOnly               bool                           `json:\"httpOnly\"`               // No JS access (default: true)\n    SameSite               int                            `json:\"sameSite\"`               // CSRF protection (default: Strict)\n    Domain                 string                         `json:\"domain\"`                 // Cookie domain\n    Path                   string                         `json:\"path\"`                   // Cookie path (default: \"/\")\n    EncryptionKey          secure.DefaultCredentialConfig `json:\"encryptionKey\"`          // Optional encryption\n    CleanupIntervalSeconds int                            `json:\"cleanupIntervalSeconds\"` // Cleanup frequency (default: 300)\n}\n</code></pre>"},{"location":"provider/httpserver/#common-use-cases","title":"Common Use Cases","text":""},{"location":"provider/httpserver/#rest-api-server","title":"REST API Server","text":"<ul> <li>JWT authentication for stateless API access</li> <li>Rate limiting to prevent abuse</li> <li>Security headers for browser protection</li> <li>Structured JSON responses with error handling</li> </ul>"},{"location":"provider/httpserver/#web-application","title":"Web Application","text":"<ul> <li>Session-based authentication for user login</li> <li>CSRF protection for form submissions</li> <li>Security headers and CSP for XSS prevention</li> <li>Flash messages for user feedback</li> <li>Device fingerprinting for security</li> </ul>"},{"location":"provider/httpserver/#microservice","title":"Microservice","text":"<ul> <li>Token-based authentication for service-to-service communication</li> <li>Health check endpoints for orchestration</li> <li>Structured logging and error handling</li> <li>Graceful shutdown for container environments</li> </ul>"},{"location":"provider/httpserver/#integration-examples","title":"Integration Examples","text":"<p>For comprehensive examples showing how to combine all components: - Integration Examples - Complete setup examples - REST API with authentication and rate limiting - Web application with sessions and CSRF protection - Microservice with health checks and monitoring</p>"},{"location":"provider/httpserver/#sample-applications","title":"Sample Applications","text":""},{"location":"provider/httpserver/#httpserver-session-sample","title":"httpserver-session Sample","text":"<p>The <code>samples/httpserver-session/</code> directory contains a complete example demonstrating:</p> <ul> <li>Session Management: Memory-based session store with secure cookies</li> <li>Authentication: Session-based authentication with custom identity types</li> <li>Security: CSRF protection and security headers</li> <li>Configuration: JSON-based configuration with validation</li> <li>Best Practices: Proper middleware ordering and error handling</li> </ul> <p>Key features demonstrated: <pre><code>// Session setup with security\nsessionConfig := session.NewConfig()\nsessionConfig.Secure = true\nsessionConfig.HttpOnly = true\nsessionConfig.ExpirationSeconds = 3600\n\n// Authentication with custom identity\ntype UserIdentity struct {\n    ID       int    `json:\"id\"`\n    Username string `json:\"username\"`\n    Email    string `json:\"email\"`\n}\n\n// Protected routes\nprotected.Use(auth.AuthMiddleware(auth.NewAuthSession(&amp;UserIdentity{})))\n</code></pre></p>"},{"location":"provider/httpserver/#performance-and-production","title":"Performance and Production","text":"<p>For production deployment guidance: - Performance Guide - Optimization and scaling - Connection management and timeouts - Load balancing strategies - Monitoring and observability setup</p>"},{"location":"provider/httpserver/#troubleshooting","title":"Troubleshooting","text":"<p>For debugging and troubleshooting information: - Troubleshooting Guide - Common issues and solutions - Configuration troubleshooting - Middleware debugging techniques - Performance issue diagnosis</p>"},{"location":"provider/httpserver/#next-steps","title":"Next Steps","text":"<ol> <li>Start with the API Reference for complete server documentation</li> <li>Review Session Management for stateful web applications</li> <li>Implement Security headers and CSRF protection</li> <li>Add Authentication for securing your endpoints</li> <li>Check Examples for complete integration patterns</li> </ol>"},{"location":"provider/httpserver/api-reference/","title":"HTTP Server API Reference","text":"<p>Complete API documentation for Blueprint's HTTP server framework built on Gin with integrated middleware components.</p>"},{"location":"provider/httpserver/api-reference/#core-server-api","title":"Core Server API","text":""},{"location":"provider/httpserver/api-reference/#serverconfig","title":"ServerConfig","text":"<p>Configuration structure for HTTP server settings:</p> <pre><code>type ServerConfig struct {\n    Host         string            `json:\"host\"`         // Server bind address (default: \"\")\n    Port         int               `json:\"port\"`         // Server port (default: 5000)\n    ReadTimeout  int               `json:\"readTimeout\"`  // Read timeout in seconds (default: 600)\n    WriteTimeout int               `json:\"writeTimeout\"` // Write timeout in seconds (default: 600)\n    Debug        bool              `json:\"debug\"`        // Enable debug mode (default: false)\n    Options      map[string]string `json:\"options\"`      // Additional server options\n    tlsProvider.ServerConfig                           // TLS configuration\n}\n</code></pre>"},{"location":"provider/httpserver/api-reference/#configuration-methods","title":"Configuration Methods","text":"<p><pre><code>func NewServerConfig() *ServerConfig\n</code></pre> Creates a new server configuration with default values.</p> <p><pre><code>func (c *ServerConfig) GetOption(key string, defaultValue string) string\n</code></pre> Retrieves option value by key, returns defaultValue if not found.</p> <p><pre><code>func (c *ServerConfig) Validate() error\n</code></pre> Validates the server configuration (currently returns nil).</p> <p><pre><code>func (c *ServerConfig) NewServer(logger *log.Logger) (*Server, error)\n</code></pre> Creates a new server instance using this configuration.</p>"},{"location":"provider/httpserver/api-reference/#default-values","title":"Default Values","text":"<pre><code>const (\n    ServerDefaultReadTimeout  = 600   // 10 minutes\n    ServerDefaultWriteTimeout = 600   // 10 minutes\n    ServerDefaultPort         = 5000  // Default port\n    ServerDefaultName         = \"http\" // Default server name\n)\n</code></pre>"},{"location":"provider/httpserver/api-reference/#configuration-options","title":"Configuration Options","text":"<p>The <code>Options</code> map supports these predefined keys:</p> <pre><code>const (\n    OptAuthTokenHeader        = \"authTokenHeader\"        // Custom auth header name\n    OptAuthTokenSecret        = \"authTokenSecret\"        // Auth token secret\n    OptDefaultSecurityHeaders = \"defaultSecurityHeaders\" // Enable default security headers\n)\n</code></pre> <p>Note: 'authTokenHeader' and 'authTokenSecret' will be used to configure automatically  simple token-based auth if ProcessOptions() is called; if no 'authTokenHeader' is specified, a default value is used</p> <p>Example: <pre><code>config := NewServerConfig()\nconfig.Host = \"localhost\"\nconfig.Port = 8080\nconfig.Debug = true\nconfig.Options[\"authTokenSecret\"] = \"my-secret-key\"\nconfig.Options[\"defaultSecurityHeaders\"] = \"true\"\n</code></pre></p>"},{"location":"provider/httpserver/api-reference/#server","title":"Server","text":"<p>Main server structure providing HTTP functionality:</p> <pre><code>type Server struct {\n    Config *ServerConfig  // Server configuration\n    Router *gin.Engine    // Gin router instance\n    Server *http.Server   // Underlying HTTP server\n    Logger *log.Logger    // Structured logger\n}\n</code></pre>"},{"location":"provider/httpserver/api-reference/#server-creation","title":"Server Creation","text":"<p><pre><code>func NewServer(cfg *ServerConfig, logger *log.Logger) (*Server, error)\n</code></pre> Creates a new HTTP server instance.</p> <p>Parameters: - <code>cfg</code>: Server configuration (nil uses defaults) - <code>logger</code>: Logger instance (nil creates default HTTP logger)</p> <p>Returns: - Configured Server instance with Gin router and HTTP server - Error if configuration validation fails</p> <p>Example: <pre><code>config := NewServerConfig()\nconfig.Port = 8080\n\nlogger := log.New(\"api-server\")\nserver, err := NewServer(config, logger)\nif err != nil {\n    log.Fatal(err)\n}\n</code></pre></p>"},{"location":"provider/httpserver/api-reference/#server-lifecycle","title":"Server Lifecycle","text":"<p><pre><code>func (s *Server) Start() error\n</code></pre> Starts the HTTP server (blocking call).</p> <ul> <li>Uses TLS if <code>TLSConfig</code> is configured</li> <li>Returns <code>nil</code> when gracefully shut down</li> <li>Returns error for startup failures</li> </ul> <p><pre><code>func (s *Server) Shutdown(ctx context.Context) error\n</code></pre> Gracefully shuts down the server.</p> <p>Parameters: - <code>ctx</code>: Context for shutdown timeout control</p> <p>Example: <pre><code>// Start server in goroutine\ngo func() {\n    if err := server.Start(); err != nil {\n        logger.Error(err, \"server failed\")\n    }\n}()\n\n// Graceful shutdown\nctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\ndefer cancel()\n\nif err := server.Shutdown(ctx); err != nil {\n    logger.Error(err, \"shutdown failed\")\n}\n</code></pre></p>"},{"location":"provider/httpserver/api-reference/#router-access","title":"Router Access","text":"<p><pre><code>func (s *Server) Route() *gin.Engine\n</code></pre> Returns the underlying Gin router for direct access.</p> <p><pre><code>func (s *Server) Group(relativePath string) *gin.RouterGroup\n</code></pre> Creates a new router group with the specified base path.</p> <p>Example: <pre><code>// Direct router access\nserver.Route().GET(\"/health\", healthHandler)\n\n// Router groups\napi := server.Group(\"/api/v1\")\napi.GET(\"/users\", getUsersHandler)\napi.POST(\"/users\", createUserHandler)\n\nadmin := server.Group(\"/admin\")\nadmin.GET(\"/stats\", adminStatsHandler)\n</code></pre></p>"},{"location":"provider/httpserver/api-reference/#middleware-management","title":"Middleware Management","text":"<p><pre><code>func (s *Server) AddMiddleware(middlewareFunc gin.HandlerFunc)\n</code></pre> Adds middleware to the server's router.</p> <p>Example: <pre><code>// Custom middleware\nserver.AddMiddleware(func(c *gin.Context) {\n    c.Header(\"X-Custom-Header\", \"value\")\n    c.Next()\n})\n\n// Third-party middleware\nserver.AddMiddleware(cors.Default())\n</code></pre></p>"},{"location":"provider/httpserver/api-reference/#options-processing","title":"Options Processing","text":"<p><pre><code>func (s *Server) ProcessOptions(withOptions ...OptionsFunc) error\n</code></pre> Processes server options and applies configuration-based middleware.</p> <p>Automatic Processing: - <code>OptDefaultSecurityHeaders</code>: Applies default security headers if \"true\" or \"1\" - <code>OptAuthTokenSecret</code>: Sets up token authentication with optional custom header</p> <p>Example: <pre><code>config.Options[\"defaultSecurityHeaders\"] = \"true\"\nconfig.Options[\"authTokenSecret\"] = \"my-api-key\"\nconfig.Options[\"authTokenHeader\"] = \"X-API-Key\"\n\nserver, _ := NewServer(config, logger)\nerr := server.ProcessOptions() // Applies security headers and auth\n</code></pre></p>"},{"location":"provider/httpserver/api-reference/#router-creation","title":"Router Creation","text":"<p><pre><code>func NewRouter(serverName string, debug bool, logger *log.Logger) *gin.Engine\n</code></pre> Creates a new Gin router with standardized configuration.</p> <p>Features: - Sets release mode for production (<code>!debug</code>) - Adds structured HTTP logging middleware - Includes recovery middleware - Configures error logging wrapper</p> <p>Example: <pre><code>router := NewRouter(\"my-api\", false, logger)\nrouter.GET(\"/test\", testHandler)\n</code></pre></p>"},{"location":"provider/httpserver/api-reference/#middleware-api","title":"Middleware API","text":""},{"location":"provider/httpserver/api-reference/#authentication-middleware","title":"Authentication Middleware","text":"<p><pre><code>func (s *Server) UseAuth(provider auth.Provider)\n</code></pre> Registers authentication middleware with the specified provider.</p> <p>Parameters: - <code>provider</code>: Authentication provider implementing <code>CanAccess(c *gin.Context) bool</code></p> <p>Example: <pre><code>// Token authentication\ntokenAuth := auth.NewAuthToken(\"X-API-Key\", \"secret-key\")\nserver.UseAuth(tokenAuth)\n\n// JWT authentication\njwtAuth := auth.NewAuthJWT(jwtProvider)\nserver.UseAuth(jwtAuth)\n</code></pre></p>"},{"location":"provider/httpserver/api-reference/#security-middleware","title":"Security Middleware","text":"<p><pre><code>func (s *Server) UseSecurityHeaders(config *security.SecurityConfig)\n</code></pre> Adds security headers middleware with custom configuration.</p> <p><pre><code>func (s *Server) UseDefaultSecurityHeaders()\n</code></pre> Adds security headers middleware with default configuration.</p> <p><pre><code>func (s *Server) UseCSRFProtection()\n</code></pre> Adds CSRF protection middleware.</p> <p>Example: <pre><code>// Custom security configuration\nsecurityConfig := &amp;security.SecurityConfig{\n    CSP: \"default-src 'self'\",\n    HSTS: \"max-age=31536000\",\n    FrameOptions: \"DENY\",\n}\nserver.UseSecurityHeaders(securityConfig)\n\n// Default security headers\nserver.UseDefaultSecurityHeaders()\n\n// CSRF protection\nserver.UseCSRFProtection()\n</code></pre></p>"},{"location":"provider/httpserver/api-reference/#rate-limiting","title":"Rate Limiting","text":"<p><pre><code>func (s *Server) UseRateLimiting(ratePerMinute int)\n</code></pre> Adds rate limiting middleware.</p> <p>Parameters: - <code>ratePerMinute</code>: Maximum requests per minute per IP - Uses burst size of 5 requests</p> <p>Example: <pre><code>// Allow 60 requests per minute\nserver.UseRateLimiting(60)\n</code></pre></p>"},{"location":"provider/httpserver/api-reference/#session-management","title":"Session Management","text":"<p><pre><code>func (s *Server) UseSession(config *session.Config, backend kv.KV, logger *log.Logger) *session.SessionManager\n</code></pre> Adds session middleware with specified configuration and storage backend.</p> <p>Parameters: - <code>config</code>: Session configuration (nil uses defaults) - <code>backend</code>: KV storage backend (memory, Redis, or custom) - <code>logger</code>: Logger for session operations</p> <p>Returns: - SessionManager instance for additional session operations</p> <p>Example: <pre><code>// Memory-based sessions\nbackend := kv.NewMemoryKV()\nsessionConfig := session.NewConfig()\nmanager := server.UseSession(sessionConfig, backend, logger)\n\n// Redis-based sessions\nredisBackend, _ := redis.NewClient(redisConfig)\nmanager := server.UseSession(sessionConfig, redisBackend, logger)\n</code></pre></p>"},{"location":"provider/httpserver/api-reference/#response-helper-api","title":"Response Helper API","text":""},{"location":"provider/httpserver/api-reference/#standard-response-types","title":"Standard Response Types","text":"<pre><code>type JSONResponse struct {\n    Success bool        `json:\"success\"`\n    Data    interface{} `json:\"data,omitempty\"`\n}\n\ntype JSONResponseError struct {\n    Success bool        `json:\"success\"`\n    Error   ErrorDetail `json:\"error\"`\n}\n\ntype ErrorDetail struct {\n    Message      string      `json:\"message,omitempty\"`\n    RequestError interface{} `json:\"requestError,omitempty\"`\n}\n</code></pre>"},{"location":"provider/httpserver/api-reference/#error-response-functions","title":"Error Response Functions","text":"<p>All response functions automatically detect JSON requests and return appropriate responses.</p> <p><pre><code>func Http401(ctx *gin.Context)\n</code></pre> Generates 401 Unauthorized response with logging.</p> <p><pre><code>func Http403(ctx *gin.Context)\n</code></pre> Generates 403 Forbidden response with logging.</p> <p><pre><code>func Http404(ctx *gin.Context)\n</code></pre> Generates 404 Not Found response with logging.</p> <p><pre><code>func Http400(ctx *gin.Context, message string)\n</code></pre> Generates 400 Bad Request response with custom message.</p> <p><pre><code>func Http429(ctx *gin.Context)\n</code></pre> Generates 429 Too Many Requests response.</p> <p><pre><code>func Http500(ctx *gin.Context, err error)\n</code></pre> Generates 500 Internal Server Error response with error logging.</p> <p><pre><code>func ValidationError(ctx *gin.Context, errors interface{})\n</code></pre> Generates 400 Bad Request response for validation failures.</p> <p>JSON Response Example: <pre><code>{\n    \"success\": false,\n    \"error\": {\n        \"message\": \"Unauthorized\",\n        \"requestError\": null\n    }\n}\n</code></pre></p> <p>Usage Example: <pre><code>func protectedHandler(c *gin.Context) {\n    token := c.GetHeader(\"Authorization\")\n    if token == \"\" {\n        response.Http401(c)\n        return\n    }\n\n    user, err := getUserFromToken(token)\n    if err != nil {\n        response.Http500(c, err)\n        return\n    }\n\n    c.JSON(200, response.JSONResponse{\n        Success: true,\n        Data:    user,\n    })\n}\n</code></pre></p>"},{"location":"provider/httpserver/api-reference/#complete-server-setup-example","title":"Complete Server Setup Example","text":"<p>check Blueprint samples</p>"},{"location":"provider/httpserver/auth/","title":"Authentication &amp; Authorization","text":"<p>Blueprint provides an extensible authentication system with multiple provider types, seamless middleware integration,  and robust security features for protecting HTTP endpoints.</p>"},{"location":"provider/httpserver/auth/#architecture-overview","title":"Architecture Overview","text":"<p>The authentication system is built around a Provider interface pattern that enables pluggable authentication mechanisms:</p> <pre><code>type Provider interface {\n    CanAccess(c *gin.Context) bool\n}\n</code></pre> <p>This simple interface allows any authentication method to be integrated by implementing a single method that determines  request access permissions.</p>"},{"location":"provider/httpserver/auth/#core-components","title":"Core Components","text":"<ul> <li>Provider Interface: Unified authentication contract</li> <li>Concrete Providers: JWT, Token, HMAC, Session authentication</li> <li>Middleware Integration: Seamless Gin framework integration  </li> <li>Context Storage: Authentication data available throughout request lifecycle</li> <li>Utility Functions: Helper methods for extracting authentication information</li> </ul>"},{"location":"provider/httpserver/auth/#authentication-providers","title":"Authentication Providers","text":""},{"location":"provider/httpserver/auth/#1-token-authentication","title":"1. Token Authentication","text":"<p>Simple API key authentication for basic access control.</p>"},{"location":"provider/httpserver/auth/#single-token-provider","title":"Single Token Provider","text":"<p>Note: NewAuthToken() relies on passing an unprotected token in the request header; this may pose a serious security issue when used in some production use cases</p> <pre><code>import \"github.com/oddbit-project/blueprint/provider/httpserver/auth\"\n\n// Create token provider\nauthToken := auth.NewAuthToken(\"X-API-Key\", \"your-secret-token\")\n\n// Apply globally\nserver.UseAuth(authToken)\n\n// Or apply to specific routes\nprotected := router.Group(\"/api\")\nprotected.Use(auth.AuthMiddleware(authToken))\n</code></pre> <p>Configuration: - Header Name: Custom header name (default: <code>X-API-Key</code>) - Token Value: Single valid token string - Behavior: Returns <code>true</code> if header matches configured token</p>"},{"location":"provider/httpserver/auth/#multiple-token-provider","title":"Multiple Token Provider","text":"<p>Note: NewAuthTokenList() relies on passing an unprotected token in the request header; this may pose a  serious security issue when used in some production use cases</p> <pre><code>// Support multiple valid tokens\nvalidTokens := []string{\"token1\", \"token2\", \"admin-token\"}\nauthTokens := auth.NewAuthTokenList(\"X-API-Key\", validTokens)\n\nserver.UseAuth(authTokens)\n</code></pre> <p>Use Cases: - API key authentication - Service-to-service communication - Simple client authentication - Development and testing environments</p>"},{"location":"provider/httpserver/auth/#2-jwt-authentication","title":"2. JWT Authentication","text":"<p>JSON Web Token authentication with comprehensive claim validation.</p>"},{"location":"provider/httpserver/auth/#setup","title":"Setup","text":"<pre><code>import (\n    \"github.com/oddbit-project/blueprint/provider/httpserver/auth\"\n    \"github.com/oddbit-project/blueprint/provider/jwtprovider\"\n)\n\n// Configure JWT provider\njwtConfig := jwtprovider.NewConfig()\njwtConfig.SecretKey = \"your-jwt-secret\"\njwtConfig.Issuer = \"your-app\"\n\njwtProvider, err := jwtprovider.NewProvider(jwtConfig)\nif err != nil {\n    log.Fatal(err, \"failed to create JWT provider\")\n}\n\n// Create auth provider\nauthJWT := auth.NewAuthJWT(jwtProvider)\nserver.UseAuth(authJWT)\n</code></pre>"},{"location":"provider/httpserver/auth/#token-usage","title":"Token Usage","text":"<p>Client Request: <pre><code>Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\n</code></pre></p> <p>Handler Access: <pre><code>func protectedHandler(c *gin.Context) {\n    // Get JWT token\n    token, ok := auth.GetJWTToken(c)\n    if !ok {\n        c.JSON(401, gin.H{\"error\": \"No token provided\"})\n        return\n    }\n\n    // Get parsed claims\n    claims, ok := auth.GetJWTClaims(c)\n    if !ok {\n        c.JSON(401, gin.H{\"error\": \"Invalid token\"})\n        return\n    }\n\n    userID := claims.Data[\"userId\"]\n    role := claims.Data[\"role\"]\n\n    c.JSON(200, gin.H{\n        \"user_id\": userID,\n        \"role\": role,\n        \"message\": \"Access granted\",\n    })\n}\n</code></pre></p> <p>Features: - Bearer token extraction from Authorization header - Cryptographic signature validation - Claims parsing and validation - Context storage for parsed claims - Expiration and issuer verification</p>"},{"location":"provider/httpserver/auth/#3-hmac-authentication","title":"3. HMAC Authentication","text":"<p>High-security authentication using HMAC-SHA256 signatures with replay protection.</p>"},{"location":"provider/httpserver/auth/#setup_1","title":"Setup","text":"<pre><code>import (\n    \"github.com/oddbit-project/blueprint/provider/httpserver/auth\"\n    \"github.com/oddbit-project/blueprint/provider/hmacprovider\"\n)\n\n// Create credential configuration\ncredential := secure.DefaultCredentialConfig{\n    Password: \"your-hmac-secret\",\n}\n\n// Configure HMAC provider\nhmacProvider := hmacprovider.NewHmacProvider(credential)\n\n// Create auth provider\nauthHMAC := auth.NewHMACAuthProvider(hmacProvider)\nserver.UseAuth(authHMAC)\n</code></pre>"},{"location":"provider/httpserver/auth/#client-implementation","title":"Client Implementation","text":"<p>Required Headers: <pre><code>X-HMAC-Hash: sha256-calculated-signature\nX-HMAC-Timestamp: 1640995200\nX-HMAC-Nonce: unique-request-id\nContent-Type: application/json\n</code></pre></p> <p>Signature Calculation: <pre><code>// Pseudo-code for client-side signature generation\ntimestamp := time.Now().Unix()\nnonce := generateUniqueNonce()\nmessage := httpMethod + \"\\n\" + requestPath + \"\\n\" + requestBody + \"\\n\" + timestamp + \"\\n\" + nonce\nsignature := hmacSHA256(secret, message)\n</code></pre></p>"},{"location":"provider/httpserver/auth/#security-features","title":"Security Features","text":"<ul> <li>Cryptographic Integrity: HMAC-SHA256 signature verification</li> <li>Replay Protection: Timestamp validation prevents old request reuse</li> <li>Duplicate Protection: Nonce validation prevents request duplication  </li> <li>Body Integrity: Full request body included in signature calculation</li> <li>Comprehensive Logging: Request authentication events with client details</li> </ul>"},{"location":"provider/httpserver/auth/#handler-access","title":"Handler Access","text":"<pre><code>func hmacProtectedHandler(c *gin.Context) {\n    // Check authentication flag\n    authenticated, exists := c.Get(\"AuthFlag\")\n    if !exists || !authenticated.(bool) {\n        c.JSON(401, gin.H{\"error\": \"Authentication failed\"})\n        return\n    }\n\n    // Get authentication metadata\n    timestamp, _ := c.Get(\"AuthTimestamp\")\n    nonce, _ := c.Get(\"AuthNonce\")\n\n    c.JSON(200, gin.H{\n        \"message\": \"HMAC authentication successful\",\n        \"timestamp\": timestamp,\n        \"nonce\": nonce,\n    })\n}\n</code></pre>"},{"location":"provider/httpserver/auth/#4-session-authentication","title":"4. Session Authentication","text":"<p>Cookie-based authentication integrated with the session management system.</p>"},{"location":"provider/httpserver/auth/#setup_2","title":"Setup","text":"<pre><code>import (\n    \"encoding/gob\"\n    \"github.com/oddbit-project/blueprint/provider/httpserver/auth\"\n    \"github.com/oddbit-project/blueprint/provider/httpserver/session\"\n)\n\n// Define user identity type\ntype UserIdentity struct {\n    ID       int    `json:\"id\"`\n    Username string `json:\"username\"`\n    Email    string `json:\"email\"`\n    Roles    []string `json:\"roles\"`\n}\n\n// Register for GOB serialization\nfunc init() {\n    gob.Register(&amp;UserIdentity{})\n}\n\n// Setup session management\nsessionConfig := session.NewConfig()\nsessionManager, err := server.UseSession(sessionConfig, backend, logger)\nif err != nil {\n    log.Fatal(err, \"failed to setup sessions\")\n}\n\n// Create session auth provider\nauthSession := auth.NewAuthSession(&amp;UserIdentity{})\nserver.UseAuth(authSession)\n</code></pre>"},{"location":"provider/httpserver/auth/#authentication-flow","title":"Authentication Flow","text":"<p>Login Handler: <pre><code>func loginHandler(c *gin.Context) {\n    var loginReq struct {\n        Username string `json:\"username\" binding:\"required\"`\n        Password string `json:\"password\" binding:\"required\"`\n    }\n\n    if err := c.ShouldBindJSON(&amp;loginReq); err != nil {\n        c.JSON(400, gin.H{\"error\": \"Invalid request\"})\n        return\n    }\n\n    // Authenticate user (your authentication logic)\n    user, err := authenticateUser(loginReq.Username, loginReq.Password)\n    if err != nil {\n        c.JSON(401, gin.H{\"error\": \"Invalid credentials\"})\n        return\n    }\n\n    // Get session and set identity\n    sess := session.Get(c)\n    identity := &amp;UserIdentity{\n        ID:       user.ID,\n        Username: user.Username,\n        Email:    user.Email,\n        Roles:    user.Roles,\n    }\n    sess.SetIdentity(identity)\n\n    // Regenerate session ID for security\n    sessionManager.Regenerate(c)\n\n    c.JSON(200, gin.H{\"message\": \"Login successful\"})\n}\n</code></pre></p> <p>Protected Handler: <pre><code>func protectedHandler(c *gin.Context) {\n    // Get user identity from session\n    identity, exists := auth.GetSessionIdentity(c)\n    if !exists {\n        c.JSON(401, gin.H{\"error\": \"Not authenticated\"})\n        return\n    }\n\n    user, ok := identity.(*UserIdentity)\n    if !ok {\n        c.JSON(500, gin.H{\"error\": \"Invalid identity type\"})\n        return\n    }\n\n    c.JSON(200, gin.H{\n        \"user\": user,\n        \"message\": \"Access granted\",\n    })\n}\n</code></pre></p> <p>Logout Handler: <pre><code>func logoutHandler(c *gin.Context) {\n    // Clear session\n    sessionManager := getSessionManager() // Your session manager instance\n    sessionManager.Clear(c)\n\n    c.JSON(200, gin.H{\"message\": \"Logged out successfully\"})\n}\n</code></pre></p>"},{"location":"provider/httpserver/auth/#middleware-integration","title":"Middleware Integration","text":""},{"location":"provider/httpserver/auth/#global-authentication","title":"Global Authentication","text":"<pre><code>// Apply to all routes\nauthProvider := auth.NewAuthToken(\"X-API-Key\", \"secret\")\nserver.UseAuth(authProvider)\n</code></pre>"},{"location":"provider/httpserver/auth/#route-group-authentication","title":"Route Group Authentication","text":"<pre><code>// Protected API routes\napi := router.Group(\"/api\")\napi.Use(auth.AuthMiddleware(authJWT))\n{\n    api.GET(\"/user/profile\", getProfileHandler)\n    api.PUT(\"/user/profile\", updateProfileHandler)\n}\n\n// Admin routes with different authentication\nadmin := router.Group(\"/admin\") \nadmin.Use(auth.AuthMiddleware(authToken))\n{\n    admin.GET(\"/users\", listUsersHandler)\n    admin.DELETE(\"/users/:id\", deleteUserHandler)\n}\n</code></pre>"},{"location":"provider/httpserver/auth/#multiple-authentication-methods","title":"Multiple Authentication Methods","text":"<pre><code>func setupRoutes(router *gin.Engine) {\n    // Public routes\n    router.GET(\"/\", homeHandler)\n    router.POST(\"/login\", loginHandler)\n\n    // Session-based web routes\n    web := router.Group(\"/dashboard\")\n    web.Use(auth.AuthMiddleware(authSession))\n    {\n        web.GET(\"/\", dashboardHandler)\n        web.POST(\"/logout\", logoutHandler)\n    }\n\n    // JWT-based API routes\n    api := router.Group(\"/api\")\n    api.Use(auth.AuthMiddleware(authJWT))\n    {\n        api.GET(\"/data\", getDataHandler)\n        api.POST(\"/data\", createDataHandler)\n    }\n\n    // HMAC-secured service routes\n    service := router.Group(\"/service\")\n    service.Use(auth.AuthMiddleware(authHMAC))\n    {\n        service.POST(\"/sync\", syncDataHandler)\n        service.GET(\"/health\", serviceHealthHandler)\n    }\n}\n</code></pre>"},{"location":"provider/httpserver/auth/#advanced-usage-patterns","title":"Advanced Usage Patterns","text":""},{"location":"provider/httpserver/auth/#custom-authentication-provider","title":"Custom Authentication Provider","text":"<pre><code>type CustomAuthProvider struct {\n    validator func(*gin.Context) bool\n}\n\nfunc (c *CustomAuthProvider) CanAccess(ctx *gin.Context) bool {\n    return c.validator(ctx)\n}\n\nfunc NewCustomAuth(validatorFunc func(*gin.Context) bool) *CustomAuthProvider {\n    return &amp;CustomAuthProvider{\n        validator: validatorFunc,\n    }\n}\n\n// Usage\ncustomAuth := NewCustomAuth(func(c *gin.Context) bool {\n    // Your custom authentication logic\n    token := c.GetHeader(\"Custom-Auth\")\n    return validateCustomToken(token)\n})\n\nserver.UseAuth(customAuth)\n</code></pre>"},{"location":"provider/httpserver/auth/#conditional-authentication","title":"Conditional Authentication","text":"<pre><code>func conditionalAuthMiddleware() gin.HandlerFunc {\n    return func(c *gin.Context) {\n        path := c.Request.URL.Path\n\n        // Skip authentication for public endpoints\n        if strings.HasPrefix(path, \"/public/\") {\n            c.Next()\n            return\n        }\n\n        // Use JWT for API endpoints\n        if strings.HasPrefix(path, \"/api/\") {\n            auth.AuthMiddleware(authJWT)(c)\n            return\n        }\n\n        // Use session auth for web endpoints\n        auth.AuthMiddleware(authSession)(c)\n    }\n}\n</code></pre>"},{"location":"provider/httpserver/auth/#role-based-authorization","title":"Role-Based Authorization","text":"<pre><code>func requireRole(role string) gin.HandlerFunc {\n    return func(c *gin.Context) {\n        identity, exists := auth.GetSessionIdentity(c)\n        if !exists {\n            c.AbortWithStatusJSON(401, gin.H{\"error\": \"Not authenticated\"})\n            return\n        }\n\n        user, ok := identity.(*UserIdentity)\n        if !ok {\n            c.AbortWithStatusJSON(500, gin.H{\"error\": \"Invalid identity\"})\n            return\n        }\n\n        hasRole := false\n        for _, userRole := range user.Roles {\n            if userRole == role {\n                hasRole = true\n                break\n            }\n        }\n\n        if !hasRole {\n            c.AbortWithStatusJSON(403, gin.H{\"error\": \"Insufficient privileges\"})\n            return\n        }\n\n        c.Next()\n    }\n}\n\n// Usage\nadmin := router.Group(\"/admin\")\nadmin.Use(auth.AuthMiddleware(authSession))\nadmin.Use(requireRole(\"admin\"))\n{\n    admin.GET(\"/users\", listUsersHandler)\n    admin.DELETE(\"/users/:id\", deleteUserHandler)\n}\n</code></pre>"},{"location":"provider/httpserver/auth/#configuration","title":"Configuration","text":""},{"location":"provider/httpserver/auth/#jwt-configuration","title":"JWT Configuration","text":"<pre><code>type JWTConfig struct {\n    SecretKey    string `json:\"secretKey\"`\n    Issuer       string `json:\"issuer\"`\n    Audience     string `json:\"audience\"`\n    ExpirationHours int `json:\"expirationHours\"`\n    Algorithm    string `json:\"algorithm\"`\n}\n</code></pre>"},{"location":"provider/httpserver/auth/#session-configuration","title":"Session Configuration","text":"<pre><code>type SessionConfig struct {\n    CookieName             string `json:\"cookieName\"`             // Cookie name\n    ExpirationSeconds      int    `json:\"expirationSeconds\"`      // Max lifetime\n    IdleTimeoutSeconds     int    `json:\"idleTimeoutSeconds\"`     // Idle timeout\n    Secure                 bool   `json:\"secure\"`                 // HTTPS only\n    HttpOnly               bool   `json:\"httpOnly\"`               // No JS access\n    SameSite               int    `json:\"sameSite\"`               // CSRF protection\n    Domain                 string `json:\"domain\"`                 // Cookie domain\n    Path                   string `json:\"path\"`                   // Cookie path\n    EncryptionKey          secure.DefaultCredentialConfig `json:\"encryptionKey\"` // Encryption\n    CleanupIntervalSeconds int    `json:\"cleanupIntervalSeconds\"` // Cleanup frequency\n}\n</code></pre>"},{"location":"provider/httpserver/auth/#hmac-configuration","title":"HMAC Configuration","text":"<pre><code>type HMACConfig struct {\n    Secret           string `json:\"secret\"`\n    TimestampWindow  int    `json:\"timestampWindow\"`  // Seconds\n    NonceExpiration  int    `json:\"nonceExpiration\"`  // Seconds\n    IncludeBody      bool   `json:\"includeBody\"`      // Include body in signature\n}\n</code></pre>"},{"location":"provider/httpserver/auth/#security-considerations","title":"Security Considerations","text":""},{"location":"provider/httpserver/auth/#production-security-checklist","title":"Production Security Checklist","text":"<ol> <li> <p>Use HTTPS: All authentication should occur over encrypted connections    <pre><code>sessionConfig.Secure = true\n</code></pre></p> </li> <li> <p>Strong Secrets: Use cryptographically secure random secrets    <pre><code># Generate secure JWT secret\nopenssl rand -base64 32\n</code></pre></p> </li> <li> <p>Token Expiration: Configure appropriate token lifetimes    <pre><code>jwtConfig.ExpirationHours = 1  // Short-lived tokens\nsessionConfig.ExpirationSeconds = 3600  // 1 hour sessions\n</code></pre></p> </li> <li> <p>Session Security: Enable all cookie security features    <pre><code>sessionConfig.HttpOnly = true\nsessionConfig.SameSite = int(http.SameSiteStrictMode)\n</code></pre></p> </li> <li> <p>Rate Limiting: Combine with rate limiting for auth endpoints    <pre><code>authGroup := router.Group(\"/auth\")\nauthGroup.Use(security.RateLimitMiddleware(rate.Every(time.Minute/5), 2))\n</code></pre></p> </li> </ol>"},{"location":"provider/httpserver/auth/#common-security-patterns","title":"Common Security Patterns","text":"<p>Token Refresh Pattern: <pre><code>func refreshTokenHandler(c *gin.Context) {\n    // Validate existing token\n    claims, ok := auth.GetJWTClaims(c)\n    if !ok {\n        c.JSON(401, gin.H{\"error\": \"Invalid token\"})\n        return\n    }\n\n    // Generate new token\n    newToken, err := jwtProvider.Generate(claims.Data)\n    if err != nil {\n        c.JSON(500, gin.H{\"error\": \"Token generation failed\"})\n        return\n    }\n\n    c.JSON(200, gin.H{\"token\": newToken})\n}\n</code></pre></p> <p>Session Regeneration on Privilege Change: <pre><code>func elevatePrivilegesHandler(c *gin.Context) {\n    sess := session.Get(c)\n    identity, _ := auth.GetSessionIdentity(c)\n    user := identity.(*UserIdentity)\n\n    // Update privileges\n    user.Roles = append(user.Roles, \"admin\")\n    sess.SetIdentity(user)\n\n    // Regenerate session for security\n    sessionManager.Regenerate(c)\n\n    c.JSON(200, gin.H{\"message\": \"Privileges elevated\"})\n}\n</code></pre></p>"},{"location":"provider/httpserver/examples/","title":"HTTP Server Integration Examples","text":"<p>Comprehensive examples showing how to combine Blueprint's HTTP server components for common use cases including  REST APIs, web applications, and microservices.</p>"},{"location":"provider/httpserver/examples/#example-1-rest-api-server","title":"Example 1: REST API Server","text":"<p>Complete REST API with JWT authentication, rate limiting, and security headers.</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"os\"\n    \"os/signal\"\n    \"syscall\"\n    \"time\"\n\n    \"github.com/gin-gonic/gin\"\n    \"github.com/oddbit-project/blueprint/provider/httpserver\"\n    \"github.com/oddbit-project/blueprint/provider/httpserver/auth\"\n    \"github.com/oddbit-project/blueprint/provider/httpserver/response\"\n    \"github.com/oddbit-project/blueprint/provider/jwtprovider\"\n    \"github.com/oddbit-project/blueprint/crypt/secure\"\n    \"github.com/oddbit-project/blueprint/log\"\n)\n\ntype User struct {\n    ID    int    `json:\"id\"`\n    Name  string `json:\"name\"`\n    Email string `json:\"email\"`\n}\n\nfunc main() {\n    logger := log.New(\"rest-api\")\n\n    // Server configuration\n    config := httpserver.NewServerConfig()\n    config.Port = 8080\n    config.Debug = false\n\n    // Create server\n    server, err := httpserver.NewServer(config, logger)\n    if err != nil {\n        logger.Fatal(err, \"failed to create server\")\n    }\n\n    // Setup middleware and routes\n    setupRESTAPIMiddleware(server, logger)\n    setupRESTAPIRoutes(server)\n\n    // Start with graceful shutdown\n    startWithGracefulShutdown(server, logger)\n}\n\nfunc setupRESTAPIMiddleware(server *httpserver.Server, logger *log.Logger) {\n    // 1. Security headers\n    server.UseDefaultSecurityHeaders()\n\n    // 2. Rate limiting - 100 requests per minute\n    server.UseRateLimiting(100)\n\n    // 3. Request ID middleware\n    server.AddMiddleware(func(c *gin.Context) {\n        requestID := generateRequestID()\n        c.Set(\"request_id\", requestID)\n        c.Header(\"X-Request-ID\", requestID)\n        c.Next()\n    })\n}\n\nfunc setupRESTAPIRoutes(server *httpserver.Server) {\n    router := server.Route()\n\n    // Health check endpoint\n    router.GET(\"/health\", func(c *gin.Context) {\n        c.JSON(200, response.JSONResponse{\n            Success: true,\n            Data:    gin.H{\"status\": \"healthy\", \"timestamp\": time.Now()},\n        })\n    })\n\n    // Authentication endpoint\n    router.POST(\"/auth/login\", loginHandler)\n\n    // Protected API routes\n    jwtProvider := setupJWTProvider()\n    jwtAuth := auth.NewAuthJWT(jwtProvider)\n\n    api := server.Group(\"/api/v1\")\n    api.Use(auth.AuthMiddleware(jwtAuth))\n    {\n        // User endpoints\n        api.GET(\"/users\", listUsersHandler)\n        api.GET(\"/users/:id\", getUserHandler)\n        api.POST(\"/users\", createUserHandler)\n        api.PUT(\"/users/:id\", updateUserHandler)\n        api.DELETE(\"/users/:id\", deleteUserHandler)\n\n        // Profile endpoints\n        api.GET(\"/profile\", getProfileHandler)\n        api.PUT(\"/profile\", updateProfileHandler)\n    }\n}\n\nfunc setupJWTProvider() jwtprovider.JWTParser {\n    config := jwtprovider.NewJWTConfig()\n    config.SigningAlgorithm = jwtprovider.HS256\n    config.CfgSigningKey = &amp;secure.DefaultCredentialConfig{\n        Password: \"your-jwt-secret-key-here\",\n    }\n    config.Issuer = \"rest-api\"\n    config.Audience = \"api-users\"\n    config.ExpirationSeconds = 3600 // 1 hour\n\n    provider, err := jwtprovider.NewProvider(config)\n    if err != nil {\n        panic(err)\n    }\n\n    return provider\n}\n\n// Authentication handler\nfunc loginHandler(c *gin.Context) {\n    var loginRequest struct {\n        Email    string `json:\"email\" binding:\"required,email\"`\n        Password string `json:\"password\" binding:\"required\"`\n    }\n\n    if err := c.ShouldBindJSON(&amp;loginRequest); err != nil {\n        response.ValidationError(c, err)\n        return\n    }\n\n    // Validate credentials (implement your logic)\n    user, err := authenticateUser(loginRequest.Email, loginRequest.Password)\n    if err != nil {\n        response.Http401(c)\n        return\n    }\n\n    // Generate JWT token\n    token, err := generateJWTToken(user)\n    if err != nil {\n        response.Http500(c, err)\n        return\n    }\n\n    c.JSON(200, response.JSONResponse{\n        Success: true,\n        Data: gin.H{\n            \"token\": token,\n            \"user\":  user,\n        },\n    })\n}\n\n// User CRUD handlers\nfunc listUsersHandler(c *gin.Context) {\n    users := []User{\n        {ID: 1, Name: \"John Doe\", Email: \"john@example.com\"},\n        {ID: 2, Name: \"Jane Smith\", Email: \"jane@example.com\"},\n    }\n\n    c.JSON(200, response.JSONResponse{\n        Success: true,\n        Data:    users,\n    })\n}\n\nfunc getUserHandler(c *gin.Context) {\n    userID := c.Param(\"id\")\n\n    // Get user from database (implement your logic)\n    user, err := getUserByID(userID)\n    if err != nil {\n        response.Http404(c)\n        return\n    }\n\n    c.JSON(200, response.JSONResponse{\n        Success: true,\n        Data:    user,\n    })\n}\n\nfunc createUserHandler(c *gin.Context) {\n    var newUser User\n    if err := c.ShouldBindJSON(&amp;newUser); err != nil {\n        response.ValidationError(c, err)\n        return\n    }\n\n    // Create user in database (implement your logic)\n    createdUser, err := createUser(newUser)\n    if err != nil {\n        response.Http500(c, err)\n        return\n    }\n\n    c.JSON(201, response.JSONResponse{\n        Success: true,\n        Data:    createdUser,\n    })\n}\n\nfunc updateUserHandler(c *gin.Context) {\n    userID := c.Param(\"id\")\n    var updateData User\n\n    if err := c.ShouldBindJSON(&amp;updateData); err != nil {\n        response.ValidationError(c, err)\n        return\n    }\n\n    // Update user in database (implement your logic)\n    updatedUser, err := updateUser(userID, updateData)\n    if err != nil {\n        response.Http500(c, err)\n        return\n    }\n\n    c.JSON(200, response.JSONResponse{\n        Success: true,\n        Data:    updatedUser,\n    })\n}\n\nfunc deleteUserHandler(c *gin.Context) {\n    userID := c.Param(\"id\")\n\n    // Delete user from database (implement your logic)\n    if err := deleteUser(userID); err != nil {\n        response.Http500(c, err)\n        return\n    }\n\n    c.JSON(200, response.JSONResponse{\n        Success: true,\n        Data:    gin.H{\"deleted\": true},\n    })\n}\n\nfunc getProfileHandler(c *gin.Context) {\n    // Get JWT claims from context\n    claimsValue, exists := c.Get(auth.ContextJwtClaims)\n    if !exists {\n        response.Http401(c)\n        return\n    }\n\n    claims, ok := claimsValue.(*jwtprovider.Claims)\n    if !ok {\n        response.Http401(c)\n        return\n    }\n\n    // Get user profile\n    user, err := getUserByID(claims.Subject)\n    if err != nil {\n        response.Http404(c)\n        return\n    }\n\n    c.JSON(200, response.JSONResponse{\n        Success: true,\n        Data:    user,\n    })\n}\n\nfunc updateProfileHandler(c *gin.Context) {\n    // Implementation similar to updateUserHandler but using JWT claims for user ID\n    // ... implementation here\n}\n\n// Helper functions (implement according to your needs)\nfunc generateRequestID() string {\n    // Generate unique request ID\n    return \"req-\" + time.Now().Format(\"20060102150405\")\n}\n\nfunc authenticateUser(email, password string) (*User, error) {\n    // Implement user authentication logic\n    return &amp;User{ID: 1, Name: \"Test User\", Email: email}, nil\n}\n\nfunc generateJWTToken(user *User) (string, error) {\n    // Implement JWT token generation\n    return \"jwt-token-here\", nil\n}\n\nfunc getUserByID(id string) (*User, error) {\n    // Implement user lookup\n    return &amp;User{ID: 1, Name: \"Test User\", Email: \"test@example.com\"}, nil\n}\n\nfunc createUser(user User) (*User, error) {\n    // Implement user creation\n    user.ID = 123\n    return &amp;user, nil\n}\n\nfunc updateUser(id string, user User) (*User, error) {\n    // Implement user update\n    return &amp;user, nil\n}\n\nfunc deleteUser(id string) error {\n    // Implement user deletion\n    return nil\n}\n\nfunc startWithGracefulShutdown(server *httpserver.Server, logger *log.Logger) {\n    // Start server in goroutine\n    go func() {\n        logger.Info(\"starting REST API server\", \"port\", server.Config.Port)\n        if err := server.Start(); err != nil {\n            logger.Error(err, \"server failed\")\n        }\n    }()\n\n    // Wait for interrupt signal\n    quit := make(chan os.Signal, 1)\n    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)\n    &lt;-quit\n\n    logger.Info(\"shutting down server...\")\n\n    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n    defer cancel()\n\n    if err := server.Shutdown(ctx); err != nil {\n        logger.Error(err, \"forced shutdown\")\n    }\n\n    logger.Info(\"server stopped\")\n}\n</code></pre>"},{"location":"provider/httpserver/examples/#example-2-web-application-with-sessions","title":"Example 2: Web Application with Sessions","text":"<p>Complete web application with session management, CSRF protection, and form handling.</p> <pre><code>package main\n\nimport (\n    \"net/http\"\n    \"github.com/gin-gonic/gin\"\n    \"github.com/oddbit-project/blueprint/provider/httpserver\"\n    \"github.com/oddbit-project/blueprint/provider/httpserver/security\"\n    \"github.com/oddbit-project/blueprint/provider/httpserver/session\"\n    \"github.com/oddbit-project/blueprint/provider/kv\"\n    \"github.com/oddbit-project/blueprint/log\"\n)\n\nfunc main() {\n    logger := log.New(\"web-app\")\n\n    // Server configuration\n    config := httpserver.NewServerConfig()\n    config.Port = 8080\n    config.Debug = true // Enable for template development\n\n    server, err := httpserver.NewServer(config, logger)\n    if err != nil {\n        logger.Fatal(err, \"failed to create server\")\n    }\n\n    // Setup web application\n    setupWebAppMiddleware(server, logger)\n    setupWebAppRoutes(server)\n\n    // Load HTML templates\n    server.Route().LoadHTMLGlob(\"templates/*\")\n\n    // Serve static files\n    server.Route().Static(\"/static\", \"./static\")\n\n    logger.Info(\"starting web application\", \"port\", config.Port)\n    if err := server.Start(); err != nil {\n        logger.Fatal(err, \"server failed\")\n    }\n}\n\nfunc setupWebAppMiddleware(server *httpserver.Server, logger *log.Logger) {\n    // 1. Security headers for web content\n    securityConfig := security.DefaultSecurityConfig()\n    securityConfig.CSP = \"default-src 'self'; script-src 'self' 'nonce-{nonce}'; style-src 'self' 'nonce-{nonce}' 'unsafe-inline'\"\n    server.UseSecurityHeaders(securityConfig)\n\n    // 2. Rate limiting\n    server.UseRateLimiting(60)\n\n    // 3. Session management\n    backend := kv.NewMemoryKV()\n    sessionConfig := session.NewConfig()\n    sessionConfig.Secure = false // For development over HTTP\n    sessionManager := server.UseSession(sessionConfig, backend, logger)\n\n    // 4. CSRF protection\n    server.UseCSRFProtection()\n}\n\nfunc setupWebAppRoutes(server *httpserver.Server) {\n    router := server.Route()\n\n    // Home page\n    router.GET(\"/\", homeHandler)\n\n    // Authentication routes\n    router.GET(\"/login\", loginFormHandler)\n    router.POST(\"/login\", loginPostHandler)\n    router.POST(\"/logout\", logoutHandler)\n\n    // User registration\n    router.GET(\"/register\", registerFormHandler)\n    router.POST(\"/register\", registerPostHandler)\n\n    // Protected user area\n    protected := server.Group(\"/dashboard\")\n    protected.Use(authRequiredMiddleware())\n    {\n        protected.GET(\"/\", dashboardHandler)\n        protected.GET(\"/profile\", profileHandler)\n        protected.POST(\"/profile\", updateProfileHandler)\n    }\n}\n\n// Page handlers\nfunc homeHandler(c *gin.Context) {\n    sess := session.Get(c)\n    isLoggedIn := sess.Has(\"user_id\")\n\n    c.HTML(http.StatusOK, \"home.html\", gin.H{\n        \"title\":      \"Welcome\",\n        \"loggedIn\":   isLoggedIn,\n        \"user\":       sess.Get(\"user_name\"),\n        \"flashMsg\":   getFlashMessage(c),\n        \"csrfToken\":  security.GenerateCSRFToken(c),\n    })\n}\n\nfunc loginFormHandler(c *gin.Context) {\n    sess := session.Get(c)\n    if sess.Has(\"user_id\") {\n        c.Redirect(http.StatusFound, \"/dashboard\")\n        return\n    }\n\n    c.HTML(http.StatusOK, \"login.html\", gin.H{\n        \"title\":     \"Login\",\n        \"csrfToken\": security.GenerateCSRFToken(c),\n        \"flashMsg\":  getFlashMessage(c),\n    })\n}\n\nfunc loginPostHandler(c *gin.Context) {\n    var loginForm struct {\n        Email    string `form:\"email\" binding:\"required,email\"`\n        Password string `form:\"password\" binding:\"required\"`\n    }\n\n    if err := c.ShouldBind(&amp;loginForm); err != nil {\n        setFlashMessage(c, \"error\", \"Please provide valid email and password\")\n        c.Redirect(http.StatusFound, \"/login\")\n        return\n    }\n\n    // Authenticate user (implement your logic)\n    user, err := authenticateWebUser(loginForm.Email, loginForm.Password)\n    if err != nil {\n        setFlashMessage(c, \"error\", \"Invalid email or password\")\n        c.Redirect(http.StatusFound, \"/login\")\n        return\n    }\n\n    // Create session\n    sess := session.Get(c)\n    sess.Set(\"user_id\", user.ID)\n    sess.Set(\"user_name\", user.Name)\n    sess.Set(\"user_email\", user.Email)\n\n    // Regenerate session ID for security\n    if manager, exists := c.Get(\"session_manager\"); exists {\n        if sessionManager, ok := manager.(*session.SessionManager); ok {\n            sessionManager.Regenerate(c)\n        }\n    }\n\n    setFlashMessage(c, \"success\", \"Welcome back, \"+user.Name+\"!\")\n    c.Redirect(http.StatusFound, \"/dashboard\")\n}\n\nfunc logoutHandler(c *gin.Context) {\n    // Clear session\n    if manager, exists := c.Get(\"session_manager\"); exists {\n        if sessionManager, ok := manager.(*session.SessionManager); ok {\n            sessionManager.Clear(c)\n        }\n    }\n\n    setFlashMessage(c, \"info\", \"You have been logged out\")\n    c.Redirect(http.StatusFound, \"/\")\n}\n\nfunc registerFormHandler(c *gin.Context) {\n    c.HTML(http.StatusOK, \"register.html\", gin.H{\n        \"title\":     \"Register\",\n        \"csrfToken\": security.GenerateCSRFToken(c),\n        \"flashMsg\":  getFlashMessage(c),\n    })\n}\n\nfunc registerPostHandler(c *gin.Context) {\n    var registerForm struct {\n        Name            string `form:\"name\" binding:\"required\"`\n        Email           string `form:\"email\" binding:\"required,email\"`\n        Password        string `form:\"password\" binding:\"required,min=6\"`\n        ConfirmPassword string `form:\"confirm_password\" binding:\"required\"`\n    }\n\n    if err := c.ShouldBind(&amp;registerForm); err != nil {\n        setFlashMessage(c, \"error\", \"Please check your input\")\n        c.Redirect(http.StatusFound, \"/register\")\n        return\n    }\n\n    if registerForm.Password != registerForm.ConfirmPassword {\n        setFlashMessage(c, \"error\", \"Passwords do not match\")\n        c.Redirect(http.StatusFound, \"/register\")\n        return\n    }\n\n    // Create user (implement your logic)\n    user, err := createWebUser(registerForm.Name, registerForm.Email, registerForm.Password)\n    if err != nil {\n        setFlashMessage(c, \"error\", \"Registration failed: \"+err.Error())\n        c.Redirect(http.StatusFound, \"/register\")\n        return\n    }\n\n    setFlashMessage(c, \"success\", \"Registration successful! Please log in.\")\n    c.Redirect(http.StatusFound, \"/login\")\n}\n\nfunc dashboardHandler(c *gin.Context) {\n    sess := session.Get(c)\n\n    c.HTML(http.StatusOK, \"dashboard.html\", gin.H{\n        \"title\":     \"Dashboard\",\n        \"user\":      sess.Get(\"user_name\"),\n        \"email\":     sess.Get(\"user_email\"),\n        \"flashMsg\":  getFlashMessage(c),\n        \"csrfToken\": security.GenerateCSRFToken(c),\n    })\n}\n\nfunc profileHandler(c *gin.Context) {\n    sess := session.Get(c)\n\n    c.HTML(http.StatusOK, \"profile.html\", gin.H{\n        \"title\":     \"Profile\",\n        \"user\":      sess.Get(\"user_name\"),\n        \"email\":     sess.Get(\"user_email\"),\n        \"flashMsg\":  getFlashMessage(c),\n        \"csrfToken\": security.GenerateCSRFToken(c),\n    })\n}\n\nfunc updateProfileHandler(c *gin.Context) {\n    var profileForm struct {\n        Name  string `form:\"name\" binding:\"required\"`\n        Email string `form:\"email\" binding:\"required,email\"`\n    }\n\n    if err := c.ShouldBind(&amp;profileForm); err != nil {\n        setFlashMessage(c, \"error\", \"Invalid input\")\n        c.Redirect(http.StatusFound, \"/dashboard/profile\")\n        return\n    }\n\n    sess := session.Get(c)\n    userID := sess.GetInt(\"user_id\")\n\n    // Update user profile (implement your logic)\n    err := updateWebUserProfile(userID, profileForm.Name, profileForm.Email)\n    if err != nil {\n        setFlashMessage(c, \"error\", \"Update failed: \"+err.Error())\n        c.Redirect(http.StatusFound, \"/dashboard/profile\")\n        return\n    }\n\n    // Update session data\n    sess.Set(\"user_name\", profileForm.Name)\n    sess.Set(\"user_email\", profileForm.Email)\n\n    setFlashMessage(c, \"success\", \"Profile updated successfully\")\n    c.Redirect(http.StatusFound, \"/dashboard/profile\")\n}\n\n// Middleware functions\nfunc authRequiredMiddleware() gin.HandlerFunc {\n    return func(c *gin.Context) {\n        sess := session.Get(c)\n        if !sess.Has(\"user_id\") {\n            setFlashMessage(c, \"error\", \"Please log in to access this page\")\n            c.Redirect(http.StatusFound, \"/login\")\n            c.Abort()\n            return\n        }\n        c.Next()\n    }\n}\n\n// Flash message helpers\nfunc setFlashMessage(c *gin.Context, msgType, message string) {\n    sess := session.Get(c)\n    sess.FlashString(msgType + \":\" + message)\n}\n\nfunc getFlashMessage(c *gin.Context) gin.H {\n    sess := session.Get(c)\n    if flashMsg, ok := sess.GetFlashString(); ok {\n        parts := strings.SplitN(flashMsg, \":\", 2)\n        if len(parts) == 2 {\n            return gin.H{\n                \"type\":    parts[0],\n                \"message\": parts[1],\n            }\n        }\n    }\n    return nil\n}\n\n// Helper functions (implement according to your needs)\nfunc authenticateWebUser(email, password string) (*User, error) {\n    // Implement web user authentication\n    return &amp;User{ID: 1, Name: \"Web User\", Email: email}, nil\n}\n\nfunc createWebUser(name, email, password string) (*User, error) {\n    // Implement user creation\n    return &amp;User{ID: 123, Name: name, Email: email}, nil\n}\n\nfunc updateWebUserProfile(userID int, name, email string) error {\n    // Implement profile update\n    return nil\n}\n</code></pre>"},{"location":"provider/httpserver/examples/#example-3-microservice-with-health-checks","title":"Example 3: Microservice with Health Checks","text":"<p>Lightweight microservice with health checks, metrics, and monitoring endpoints.</p> <pre><code>package main\n\nimport (\n    \"github.com/gin-gonic/gin\"\n    \"github.com/oddbit-project/blueprint/provider/httpserver\"\n    \"github.com/oddbit-project/blueprint/provider/httpserver/auth\"\n    \"github.com/oddbit-project/blueprint/provider/httpserver/response\"\n    \"github.com/oddbit-project/blueprint/log\"\n)\n\ntype HealthStatus struct {\n    Status      string            `json:\"status\"`\n    Version     string            `json:\"version\"`\n    Timestamp   string            `json:\"timestamp\"`\n    Uptime      string            `json:\"uptime\"`\n    Dependencies map[string]string `json:\"dependencies\"`\n}\n\nfunc main() {\n    logger := log.New(\"microservice\")\n\n    // Minimal configuration for microservice\n    config := httpserver.NewServerConfig()\n    config.Port = 8080\n    config.Debug = false\n\n    server, err := httpserver.NewServer(config, logger)\n    if err != nil {\n        logger.Fatal(err, \"failed to create server\")\n    }\n\n    setupMicroserviceMiddleware(server, logger)\n    setupMicroserviceRoutes(server)\n\n    logger.Info(\"starting microservice\", \"port\", config.Port)\n    if err := server.Start(); err != nil {\n        logger.Fatal(err, \"server failed\")\n    }\n}\n\nfunc setupMicroserviceMiddleware(server *httpserver.Server, logger *log.Logger) {\n    // Minimal middleware for microservice\n    server.UseDefaultSecurityHeaders()\n    server.UseRateLimiting(1000) // Higher limit for microservice\n\n    // Service-to-service authentication\n    tokenAuth := auth.NewAuthToken(\"X-Service-Token\", \"service-secret-key\")\n\n    // Only protect internal endpoints\n    internal := server.Group(\"/internal\")\n    internal.Use(auth.AuthMiddleware(tokenAuth))\n}\n\nfunc setupMicroserviceRoutes(server *httpserver.Server) {\n    router := server.Route()\n\n    // Public health endpoints\n    router.GET(\"/health\", healthCheckHandler)\n    router.GET(\"/health/ready\", readinessHandler)\n    router.GET(\"/health/live\", livenessHandler)\n    router.GET(\"/metrics\", metricsHandler)\n\n    // Business logic endpoints\n    router.GET(\"/api/data\", getDataHandler)\n    router.POST(\"/api/process\", processDataHandler)\n\n    // Internal endpoints (protected)\n    internal := server.Group(\"/internal\")\n    {\n        internal.GET(\"/config\", getConfigHandler)\n        internal.POST(\"/refresh\", refreshCacheHandler)\n        internal.GET(\"/stats\", getStatsHandler)\n    }\n}\n\nfunc healthCheckHandler(c *gin.Context) {\n    status := HealthStatus{\n        Status:    \"healthy\",\n        Version:   \"1.0.0\",\n        Timestamp: time.Now().Format(time.RFC3339),\n        Uptime:    getUptime(),\n        Dependencies: map[string]string{\n            \"database\": \"healthy\",\n            \"cache\":    \"healthy\",\n            \"queue\":    \"healthy\",\n        },\n    }\n\n    c.JSON(200, status)\n}\n\nfunc readinessHandler(c *gin.Context) {\n    // Check if service is ready to serve traffic\n    if !isServiceReady() {\n        c.JSON(503, gin.H{\n            \"status\": \"not ready\",\n            \"reason\": \"dependencies not available\",\n        })\n        return\n    }\n\n    c.JSON(200, gin.H{\"status\": \"ready\"})\n}\n\nfunc livenessHandler(c *gin.Context) {\n    // Check if service is alive\n    c.JSON(200, gin.H{\n        \"status\": \"alive\",\n        \"timestamp\": time.Now().Format(time.RFC3339),\n    })\n}\n\nfunc metricsHandler(c *gin.Context) {\n    // Return Prometheus-style metrics\n    metrics := `\n# HELP http_requests_total Total number of HTTP requests\n# TYPE http_requests_total counter\nhttp_requests_total{method=\"GET\"} 1234\nhttp_requests_total{method=\"POST\"} 567\n\n# HELP http_request_duration_seconds HTTP request latency\n# TYPE http_request_duration_seconds histogram\nhttp_request_duration_seconds_bucket{le=\"0.1\"} 100\nhttp_request_duration_seconds_bucket{le=\"0.5\"} 200\nhttp_request_duration_seconds_bucket{le=\"1.0\"} 300\nhttp_request_duration_seconds_bucket{le=\"+Inf\"} 350\n`\n\n    c.String(200, metrics)\n}\n\nfunc getDataHandler(c *gin.Context) {\n    // Business logic endpoint\n    data := gin.H{\n        \"message\": \"Service is working\",\n        \"data\":    []string{\"item1\", \"item2\", \"item3\"},\n    }\n\n    c.JSON(200, response.JSONResponse{\n        Success: true,\n        Data:    data,\n    })\n}\n\nfunc processDataHandler(c *gin.Context) {\n    var request map[string]interface{}\n    if err := c.ShouldBindJSON(&amp;request); err != nil {\n        response.ValidationError(c, err)\n        return\n    }\n\n    // Process the data\n    result := processBusinessLogic(request)\n\n    c.JSON(200, response.JSONResponse{\n        Success: true,\n        Data:    result,\n    })\n}\n\n// Protected internal endpoints\nfunc getConfigHandler(c *gin.Context) {\n    config := gin.H{\n        \"database_url\": \"***hidden***\",\n        \"cache_ttl\":    3600,\n        \"worker_count\": 10,\n    }\n\n    c.JSON(200, response.JSONResponse{\n        Success: true,\n        Data:    config,\n    })\n}\n\nfunc refreshCacheHandler(c *gin.Context) {\n    // Refresh internal caches\n    err := refreshInternalCache()\n    if err != nil {\n        response.Http500(c, err)\n        return\n    }\n\n    c.JSON(200, response.JSONResponse{\n        Success: true,\n        Data:    gin.H{\"cache_refreshed\": true},\n    })\n}\n\nfunc getStatsHandler(c *gin.Context) {\n    stats := gin.H{\n        \"requests_processed\": 12345,\n        \"errors_count\":      23,\n        \"average_latency\":   \"45ms\",\n        \"memory_usage\":      \"128MB\",\n    }\n\n    c.JSON(200, response.JSONResponse{\n        Success: true,\n        Data:    stats,\n    })\n}\n\n// Helper functions\nfunc getUptime() string {\n    // Calculate service uptime\n    return \"2h 15m 30s\"\n}\n\nfunc isServiceReady() bool {\n    // Check dependencies\n    return true\n}\n\nfunc processBusinessLogic(data map[string]interface{}) gin.H {\n    // Implement business logic\n    return gin.H{\n        \"processed\": true,\n        \"result\":    data,\n    }\n}\n\nfunc refreshInternalCache() error {\n    // Implement cache refresh\n    return nil\n}\n</code></pre>"},{"location":"provider/httpserver/examples/#configuration-examples","title":"Configuration Examples","text":""},{"location":"provider/httpserver/examples/#environment-based-configuration","title":"Environment-based Configuration","text":"<pre><code>func createServerFromEnv() (*httpserver.Server, error) {\n    config := httpserver.NewServerConfig()\n\n    // Read from environment variables\n    if port := os.Getenv(\"SERVER_PORT\"); port != \"\" {\n        if p, err := strconv.Atoi(port); err == nil {\n            config.Port = p\n        }\n    }\n\n    config.Host = os.Getenv(\"SERVER_HOST\")\n    config.Debug = os.Getenv(\"DEBUG\") == \"true\"\n\n    // TLS configuration\n    if certFile := os.Getenv(\"TLS_CERT_FILE\"); certFile != \"\" {\n        config.TLSCert = certFile\n        config.TLSKey = os.Getenv(\"TLS_KEY_FILE\")\n        config.TLSEnable = true\n    }\n\n    // Options from environment\n    config.Options[httpserver.OptAuthTokenSecret] = os.Getenv(\"API_SECRET\")\n    config.Options[httpserver.OptDefaultSecurityHeaders] = \"true\"\n\n    logger := log.New(\"app\")\n    return httpserver.NewServer(config, logger)\n}\n</code></pre>"},{"location":"provider/httpserver/examples/#docker-ready-configuration","title":"Docker-ready Configuration","text":"<pre><code>func createDockerServer() (*httpserver.Server, error) {\n    config := httpserver.NewServerConfig()\n    config.Host = \"0.0.0.0\" // Bind to all interfaces in container\n    config.Port = 8080\n    config.Debug = false\n\n    // Production timeouts\n    config.ReadTimeout = 30\n    config.WriteTimeout = 30\n\n    logger := log.New(\"docker-app\")\n    server, err := httpserver.NewServer(config, logger)\n    if err != nil {\n        return nil, err\n    }\n\n    // Production middleware\n    server.UseDefaultSecurityHeaders()\n    server.UseRateLimiting(100)\n\n    return server, nil\n}\n</code></pre> <p>These examples demonstrate complete, production-ready applications using Blueprint's HTTP server framework with all the integrated components working together seamlessly.</p>"},{"location":"provider/httpserver/middleware/","title":"HTTP Server Middleware","text":"<p>Blueprint provides a comprehensive middleware system for HTTP servers with built-in components for common functionality and easy custom middleware development.</p>"},{"location":"provider/httpserver/middleware/#middleware-overview","title":"Middleware Overview","text":"<p>The HTTP server supports middleware through Gin's middleware system with additional Blueprint-specific components:</p> <ul> <li>Authentication Middleware: Token and JWT-based authentication (auth.md)</li> <li>Security Middleware: Headers, CSRF, and rate limiting (security.md)</li> <li>Session Middleware: Cookie-based session management (session.md)</li> <li>Logging Middleware: Structured HTTP request logging</li> <li>Response Helpers: Standardized error and success responses</li> <li>Recovery Middleware: Panic recovery with logging</li> </ul>"},{"location":"provider/httpserver/middleware/#core-middleware-components","title":"Core Middleware Components","text":""},{"location":"provider/httpserver/middleware/#http-logging-middleware","title":"HTTP Logging Middleware","text":"<p>Blueprint provides structured HTTP logging that integrates with the application logger.</p>"},{"location":"provider/httpserver/middleware/#features","title":"Features","text":"<ul> <li>Structured logging with request details</li> <li>Configurable log levels</li> <li>Integration with Blueprint's logging framework</li> <li>Request correlation IDs</li> <li>Performance metrics</li> </ul>"},{"location":"provider/httpserver/middleware/#usage","title":"Usage","text":"<pre><code>import \"github.com/oddbit-project/blueprint/provider/httpserver/log\"\n\n// Automatic integration when creating router\nrouter := httpserver.NewRouter(\"api-server\", false, logger)\n// Logging middleware is automatically added\n\n// Manual integration\nrouter.Use(log.HTTPLogMiddleware(logger))\n</code></pre>"},{"location":"provider/httpserver/middleware/#log-output","title":"Log Output","text":"<p>The middleware logs requests with structured data:</p> <pre><code>{\n    \"level\": \"info\",\n    \"time\": \"2024-01-15T10:30:00Z\",\n    \"logger\": \"api-server\",\n    \"message\": \"HTTP Request\",\n    \"method\": \"GET\",\n    \"path\": \"/api/users\",\n    \"status\": 200,\n    \"latency\": \"15ms\",\n    \"client_ip\": \"192.168.1.100\",\n    \"user_agent\": \"Mozilla/5.0...\",\n    \"request_id\": \"req-123456\"\n}\n</code></pre>"},{"location":"provider/httpserver/middleware/#request-logging-functions","title":"Request Logging Functions","text":"<pre><code>// Log informational messages with request context\nlog.RequestInfo(ctx *gin.Context, message string, fields map[string]interface{})\n\n// Log warnings with request context\nlog.RequestWarn(ctx *gin.Context, message string, fields map[string]interface{})\n\n// Log errors with request context and stack trace\nlog.RequestError(ctx *gin.Context, err error, message string, fields map[string]interface{})\n</code></pre> <p>Example: <pre><code>func userHandler(c *gin.Context) {\n    userID := c.Param(\"id\")\n\n    log.RequestInfo(c, \"fetching user\", map[string]interface{}{\n        \"user_id\": userID,\n    })\n\n    user, err := getUserByID(userID)\n    if err != nil {\n        log.RequestError(c, err, \"failed to fetch user\", map[string]interface{}{\n            \"user_id\": userID,\n        })\n        response.Http500(c, err)\n        return\n    }\n\n    c.JSON(200, user)\n}\n</code></pre></p>"},{"location":"provider/httpserver/middleware/#recovery-middleware","title":"Recovery Middleware","text":"<p>Gin's recovery middleware is automatically included with Blueprint's error logging.</p>"},{"location":"provider/httpserver/middleware/#features_1","title":"Features","text":"<ul> <li>Catches panics and recovers gracefully</li> <li>Logs panic details with stack trace</li> <li>Returns 500 Internal Server Error response</li> <li>Integrates with Blueprint's logging system</li> </ul>"},{"location":"provider/httpserver/middleware/#configuration","title":"Configuration","text":"<pre><code>// Recovery is automatically added in NewRouter\nrouter := httpserver.NewRouter(\"api-server\", false, logger)\n\n// Manual addition (if needed)\nrouter.Use(gin.Recovery())\n</code></pre>"},{"location":"provider/httpserver/middleware/#request-detection-middleware","title":"Request Detection Middleware","text":"<p>Blueprint provides utilities for detecting request types and content.</p>"},{"location":"provider/httpserver/middleware/#json-request-detection","title":"JSON Request Detection","text":"<pre><code>import \"github.com/oddbit-project/blueprint/provider/httpserver/request\"\n\nfunc handler(c *gin.Context) {\n    if request.IsJSONRequest(c) {\n        // Handle JSON request\n        c.JSON(200, gin.H{\"type\": \"json\"})\n    } else {\n        // Handle non-JSON request\n        c.String(200, \"text response\")\n    }\n}\n</code></pre>"},{"location":"provider/httpserver/middleware/#response-middleware","title":"Response Middleware","text":""},{"location":"provider/httpserver/middleware/#standardized-response-helpers","title":"Standardized Response Helpers","text":"<p>Blueprint provides consistent response helpers that automatically detect request type and format responses appropriately.</p>"},{"location":"provider/httpserver/middleware/#success-responses","title":"Success Responses","text":"<pre><code>import \"github.com/oddbit-project/blueprint/provider/httpserver/response\"\n\nfunc successHandler(c *gin.Context) {\n    // For JSON requests, returns structured JSON\n    // For other requests, may return different formats\n    c.JSON(200, response.JSONResponse{\n        Success: true,\n        Data:    gin.H{\"message\": \"Operation successful\"},\n    })\n}\n</code></pre>"},{"location":"provider/httpserver/middleware/#error-responses","title":"Error Responses","text":"<pre><code>func errorHandler(c *gin.Context) {\n    // Automatic request type detection and logging\n    response.Http400(c, \"Invalid input provided\")\n\n    // For validation errors\n    validationErrors := map[string]string{\n        \"email\": \"Invalid email format\",\n        \"age\": \"Must be a positive number\",\n    }\n    response.ValidationError(c, validationErrors)\n}\n</code></pre>"},{"location":"provider/httpserver/middleware/#response-types","title":"Response Types","text":"<p>All response helpers support both JSON and non-JSON requests:</p> <ul> <li>JSON Requests: Return structured JSON with <code>success</code>, <code>data</code>, and <code>error</code> fields</li> <li>Non-JSON Requests: Return appropriate HTTP status codes</li> </ul>"},{"location":"provider/httpserver/middleware/#custom-middleware-development","title":"Custom Middleware Development","text":""},{"location":"provider/httpserver/middleware/#creating-custom-middleware","title":"Creating Custom Middleware","text":"<pre><code>// Simple middleware example\nfunc CustomHeaderMiddleware(headerValue string) gin.HandlerFunc {\n    return func(c *gin.Context) {\n        c.Header(\"X-Custom-Header\", headerValue)\n        c.Next()\n    }\n}\n\n// Middleware with error handling\nfunc ValidationMiddleware() gin.HandlerFunc {\n    return func(c *gin.Context) {\n        if c.Request.Header.Get(\"Content-Type\") == \"\" {\n            response.Http400(c, \"Content-Type header required\")\n            return\n        }\n        c.Next()\n    }\n}\n\n// Usage\nserver.AddMiddleware(CustomHeaderMiddleware(\"my-value\"))\nserver.AddMiddleware(ValidationMiddleware())\n</code></pre>"},{"location":"provider/httpserver/middleware/#middleware-with-dependencies","title":"Middleware with Dependencies","text":"<pre><code>type DatabaseMiddleware struct {\n    db *sql.DB\n    logger *log.Logger\n}\n\nfunc NewDatabaseMiddleware(db *sql.DB, logger *log.Logger) *DatabaseMiddleware {\n    return &amp;DatabaseMiddleware{\n        db: db,\n        logger: logger,\n    }\n}\n\nfunc (m *DatabaseMiddleware) Middleware() gin.HandlerFunc {\n    return func(c *gin.Context) {\n        // Add database connection to context\n        c.Set(\"db\", m.db)\n\n        // Log database operations\n        m.logger.Info(\"database middleware applied\", map[string]interface{}{\n            \"path\": c.Request.URL.Path,\n        })\n\n        c.Next()\n    }\n}\n\n// Usage\ndbMiddleware := NewDatabaseMiddleware(db, logger)\nserver.AddMiddleware(dbMiddleware.Middleware())\n</code></pre>"},{"location":"provider/httpserver/middleware/#request-context-middleware","title":"Request Context Middleware","text":"<pre><code>func RequestIDMiddleware() gin.HandlerFunc {\n    return func(c *gin.Context) {\n        requestID := uuid.New().String()\n        c.Set(\"request_id\", requestID)\n        c.Header(\"X-Request-ID\", requestID)\n        c.Next()\n    }\n}\n\nfunc UserContextMiddleware(userService UserService) gin.HandlerFunc {\n    return func(c *gin.Context) {\n        // Extract user from token/session\n        userID := extractUserIDFromRequest(c)\n        if userID != \"\" {\n            user, err := userService.GetUser(userID)\n            if err == nil {\n                c.Set(\"current_user\", user)\n            }\n        }\n        c.Next()\n    }\n}\n</code></pre>"},{"location":"provider/httpserver/middleware/#middleware-ordering","title":"Middleware Ordering","text":"<p>Middleware order is crucial for proper functionality. Blueprint recommends this order:</p>"},{"location":"provider/httpserver/middleware/#1-security-headers","title":"1. Security Headers","text":"<pre><code>server.UseDefaultSecurityHeaders()\n</code></pre>"},{"location":"provider/httpserver/middleware/#2-request-identification","title":"2. Request Identification","text":"<pre><code>server.AddMiddleware(RequestIDMiddleware())\n</code></pre>"},{"location":"provider/httpserver/middleware/#3-rate-limiting","title":"3. Rate Limiting","text":"<pre><code>server.UseRateLimiting(100)\n</code></pre>"},{"location":"provider/httpserver/middleware/#4-session-management","title":"4. Session Management","text":"<pre><code>sessionManager := server.UseSession(sessionConfig, backend, logger)\n</code></pre>"},{"location":"provider/httpserver/middleware/#5-csrf-protection","title":"5. CSRF Protection","text":"<pre><code>server.UseCSRFProtection()\n</code></pre>"},{"location":"provider/httpserver/middleware/#6-authentication","title":"6. Authentication","text":"<pre><code>server.UseAuth(authProvider)\n</code></pre>"},{"location":"provider/httpserver/middleware/#7-business-logic-middleware","title":"7. Business Logic Middleware","text":"<pre><code>server.AddMiddleware(CustomBusinessLogicMiddleware())\n</code></pre>"},{"location":"provider/httpserver/middleware/#complete-middleware-stack-example","title":"Complete Middleware Stack Example","text":"<pre><code>func setupMiddleware(server *httpserver.Server, logger *log.Logger) {\n    // 1. Security headers (first)\n    server.UseDefaultSecurityHeaders()\n\n    // 2. Request identification\n    server.AddMiddleware(RequestIDMiddleware())\n\n    // 3. Rate limiting (early to prevent abuse)\n    server.UseRateLimiting(100)\n\n    // 4. Sessions (before CSRF and auth)\n    backend := kv.NewMemoryKV()\n    sessionManager := server.UseSession(nil, backend, logger)\n\n    // 5. CSRF protection (after sessions)\n    server.UseCSRFProtection()\n\n    // 6. Custom business middleware\n    server.AddMiddleware(DatabaseConnectionMiddleware(db))\n    server.AddMiddleware(MetricsMiddleware())\n\n    // 7. Authentication (last, so other middleware is available)\n    tokenAuth := auth.NewAuthToken(\"X-API-Key\", \"secret\")\n    server.UseAuth(tokenAuth)\n}\n</code></pre>"},{"location":"provider/httpserver/middleware/#route-specific-middleware","title":"Route-Specific Middleware","text":""},{"location":"provider/httpserver/middleware/#group-middleware","title":"Group Middleware","text":"<pre><code>func setupRoutes(server *httpserver.Server) {\n    router := server.Route()\n\n    // Public routes (no additional middleware)\n    router.GET(\"/health\", healthHandler)\n    router.POST(\"/login\", loginHandler)\n\n    // API routes with rate limiting\n    api := server.Group(\"/api/v1\")\n    api.Use(RateLimitMiddleware(60)) // 60 requests per minute\n    {\n        api.GET(\"/users\", getUsersHandler)\n        api.POST(\"/users\", createUserHandler)\n    }\n\n    // Admin routes with stricter auth\n    admin := server.Group(\"/admin\")\n    admin.Use(AdminAuthMiddleware())\n    admin.Use(AuditLogMiddleware())\n    {\n        admin.GET(\"/users\", adminListUsersHandler)\n        admin.DELETE(\"/users/:id\", adminDeleteUserHandler)\n    }\n}\n</code></pre>"},{"location":"provider/httpserver/middleware/#conditional-middleware","title":"Conditional Middleware","text":"<pre><code>func ConditionalMiddleware(condition func(*gin.Context) bool, middleware gin.HandlerFunc) gin.HandlerFunc {\n    return func(c *gin.Context) {\n        if condition(c) {\n            middleware(c)\n        } else {\n            c.Next()\n        }\n    }\n}\n\n// Usage\nserver.AddMiddleware(ConditionalMiddleware(\n    func(c *gin.Context) bool {\n        return strings.HasPrefix(c.Request.URL.Path, \"/api/\")\n    },\n    RateLimitMiddleware(100),\n))\n</code></pre>"},{"location":"provider/httpserver/middleware/#error-handling-in-middleware","title":"Error Handling in Middleware","text":""},{"location":"provider/httpserver/middleware/#graceful-error-handling","title":"Graceful Error Handling","text":"<pre><code>func SafeMiddleware() gin.HandlerFunc {\n    return func(c *gin.Context) {\n        defer func() {\n            if r := recover(); r != nil {\n                log.RequestError(c, fmt.Errorf(\"middleware panic: %v\", r), \n                    \"middleware panic recovered\", nil)\n                response.Http500(c, fmt.Errorf(\"internal error\"))\n            }\n        }()\n\n        // Middleware logic here\n        c.Next()\n    }\n}\n</code></pre>"},{"location":"provider/httpserver/middleware/#error-response-middleware","title":"Error Response Middleware","text":"<pre><code>func ErrorHandlingMiddleware() gin.HandlerFunc {\n    return func(c *gin.Context) {\n        c.Next()\n\n        // Check for errors after request processing\n        if len(c.Errors) &gt; 0 {\n            err := c.Errors.Last()\n            log.RequestError(c, err, \"request processing error\", nil)\n\n            // Return appropriate error response\n            if !c.Writer.Written() {\n                response.Http500(c, err)\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"provider/httpserver/middleware/#middleware-testing","title":"Middleware Testing","text":""},{"location":"provider/httpserver/middleware/#testing-custom-middleware","title":"Testing Custom Middleware","text":"<pre><code>func TestCustomMiddleware(t *testing.T) {\n    // Create test router\n    router := gin.New()\n    router.Use(CustomHeaderMiddleware(\"test-value\"))\n\n    // Add test route\n    router.GET(\"/test\", func(c *gin.Context) {\n        c.String(200, \"OK\")\n    })\n\n    // Create test request\n    req := httptest.NewRequest(\"GET\", \"/test\", nil)\n    w := httptest.NewRecorder()\n\n    // Execute request\n    router.ServeHTTP(w, req)\n\n    // Assert results\n    assert.Equal(t, 200, w.Code)\n    assert.Equal(t, \"test-value\", w.Header().Get(\"X-Custom-Header\"))\n}\n</code></pre>"},{"location":"provider/httpserver/middleware/#integration-testing","title":"Integration Testing","text":"<pre><code>func TestMiddlewareStack(t *testing.T) {\n    logger := log.New(\"test\")\n    config := httpserver.NewServerConfig()\n    server, _ := httpserver.NewServer(config, logger)\n\n    // Apply middleware\n    setupMiddleware(server, logger)\n\n    // Add test route\n    server.Route().GET(\"/protected\", func(c *gin.Context) {\n        c.JSON(200, gin.H{\"status\": \"ok\"})\n    })\n\n    // Test requests\n    req := httptest.NewRequest(\"GET\", \"/protected\", nil)\n    req.Header.Set(\"X-API-Key\", \"secret\")\n\n    w := httptest.NewRecorder()\n    server.Route().ServeHTTP(w, req)\n\n    assert.Equal(t, 200, w.Code)\n}\n</code></pre>"},{"location":"provider/httpserver/middleware/#best-practices","title":"Best Practices","text":""},{"location":"provider/httpserver/middleware/#middleware-design","title":"Middleware Design","text":"<ol> <li>Single Responsibility: Each middleware should have one clear purpose</li> <li>Error Handling: Always handle errors gracefully and log appropriately</li> <li>Performance: Minimize processing time in middleware</li> <li>Context Management: Use context appropriately for request-scoped data</li> <li>Testing: Write tests for all custom middleware</li> </ol>"},{"location":"provider/httpserver/middleware/#performance-considerations","title":"Performance Considerations","text":"<ol> <li>Order Matters: Place faster middleware first</li> <li>Early Exit: Stop processing on authentication failures</li> <li>Caching: Cache expensive operations where appropriate</li> <li>Avoid Blocking: Don't perform blocking operations in middleware</li> </ol>"},{"location":"provider/httpserver/middleware/#security-guidelines","title":"Security Guidelines","text":"<ol> <li>Input Validation: Validate all inputs in middleware</li> <li>Error Information: Don't expose sensitive information in error responses</li> <li>Logging: Log security events appropriately</li> <li>Dependencies: Keep middleware dependencies minimal</li> </ol> <p>The middleware system provides a flexible foundation for building secure, performant HTTP applications with Blueprint's integrated components and custom business logic.</p>"},{"location":"provider/httpserver/performance/","title":"HTTP Server Performance Guide","text":"<p>Comprehensive guide for optimizing Blueprint's HTTP server performance, scaling strategies, and production deployment best practices.</p>"},{"location":"provider/httpserver/performance/#performance-fundamentals","title":"Performance Fundamentals","text":""},{"location":"provider/httpserver/performance/#server-configuration-optimization","title":"Server Configuration Optimization","text":""},{"location":"provider/httpserver/performance/#connection-timeouts","title":"Connection Timeouts","text":"<pre><code>func optimizeServerTimeouts(config *httpserver.ServerConfig) {\n    // Production timeouts\n    config.ReadTimeout = 30   // 30 seconds read timeout\n    config.WriteTimeout = 30  // 30 seconds write timeout\n\n    // For API servers with long-running operations\n    config.ReadTimeout = 60   // 1 minute\n    config.WriteTimeout = 300 // 5 minutes for large responses\n\n    // For microservices with quick responses\n    config.ReadTimeout = 10   // 10 seconds\n    config.WriteTimeout = 10  // 10 seconds\n}\n</code></pre>"},{"location":"provider/httpserver/performance/#http-server-tuning","title":"HTTP Server Tuning","text":"<pre><code>func createOptimizedServer(config *httpserver.ServerConfig, logger *log.Logger) (*httpserver.Server, error) {\n    server, err := httpserver.NewServer(config, logger)\n    if err != nil {\n        return nil, err\n    }\n\n    // Optimize underlying HTTP server\n    server.Server.MaxHeaderBytes = 1 &lt;&lt; 20 // 1MB max header size\n    server.Server.IdleTimeout = 120 * time.Second\n    server.Server.ReadHeaderTimeout = 5 * time.Second\n\n    return server, nil\n}\n</code></pre>"},{"location":"provider/httpserver/performance/#gin-router-optimization","title":"Gin Router Optimization","text":""},{"location":"provider/httpserver/performance/#release-mode","title":"Release Mode","text":"<pre><code>func optimizeGinRouter() {\n    // Always use release mode in production\n    gin.SetMode(gin.ReleaseMode)\n\n    // Or set via environment\n    os.Setenv(\"GIN_MODE\", \"release\")\n}\n</code></pre>"},{"location":"provider/httpserver/performance/#router-configuration","title":"Router Configuration","text":"<pre><code>func createOptimizedRouter(logger *log.Logger) *gin.Engine {\n    // Disable debug features\n    gin.SetMode(gin.ReleaseMode)\n\n    router := gin.New()\n\n    // Use only necessary middleware\n    if logger != nil {\n        router.Use(httplog.HTTPLogMiddleware(logger))\n    }\n    router.Use(gin.Recovery())\n\n    // Avoid unnecessary middleware in production\n    // router.Use(gin.Logger()) // Skip default logger\n\n    return router\n}\n</code></pre>"},{"location":"provider/httpserver/performance/#middleware-performance","title":"Middleware Performance","text":""},{"location":"provider/httpserver/performance/#middleware-ordering","title":"Middleware Ordering","text":"<p>Optimize middleware order for best performance:</p> <pre><code>func optimizeMiddlewareOrder(server *httpserver.Server, logger *log.Logger) {\n    // 1. Fast security headers (minimal overhead)\n    server.UseDefaultSecurityHeaders()\n\n    // 2. Rate limiting (early rejection of excess traffic)\n    server.UseRateLimiting(1000)\n\n    // 3. Request ID (lightweight)\n    server.AddMiddleware(requestIDMiddleware())\n\n    // 4. Authentication (reject unauthorized early)\n    tokenAuth := auth.NewAuthToken(\"X-API-Key\", \"secret\")\n    server.UseAuth(tokenAuth)\n\n    // 5. Expensive middleware last\n    server.UseSession(sessionConfig, backend, logger)\n    server.UseCSRFProtection()\n}\n</code></pre>"},{"location":"provider/httpserver/performance/#efficient-rate-limiting","title":"Efficient Rate Limiting","text":"<pre><code>func efficientRateLimiting(server *httpserver.Server) {\n    // Use efficient rate limiting\n    r := rate.Every(time.Second / 100) // 100 requests per second\n    burst := 50                        // Allow bursts\n\n    server.AddMiddleware(security.RateLimitMiddleware(r, burst))\n\n    // For high-traffic scenarios, consider Redis-based rate limiting\n    // with connection pooling and distributed counters\n}\n</code></pre>"},{"location":"provider/httpserver/performance/#lightweight-middleware","title":"Lightweight Middleware","text":"<pre><code>func lightweightMiddleware() gin.HandlerFunc {\n    return func(c *gin.Context) {\n        // Minimal processing\n        c.Header(\"X-Request-ID\", generateFastID())\n        c.Next()\n    }\n}\n\n// Avoid expensive operations in middleware\nfunc avoidSlowMiddleware() gin.HandlerFunc {\n    return func(c *gin.Context) {\n        // Avoid:\n        // - Database queries\n        // - External API calls\n        // - Heavy computations\n        // - Large memory allocations\n\n        c.Next()\n    }\n}\n</code></pre>"},{"location":"provider/httpserver/performance/#memory-optimization","title":"Memory Optimization","text":""},{"location":"provider/httpserver/performance/#connection-management","title":"Connection Management","text":"<pre><code>func optimizeConnections(server *httpserver.Server) {\n    // Configure connection pooling\n    server.Server.SetKeepAlivesEnabled(true)\n    server.Server.IdleTimeout = 60 * time.Second\n\n    // For high-concurrency scenarios\n    server.Server.MaxHeaderBytes = 32 &lt;&lt; 10 // 32KB max headers\n}\n</code></pre>"},{"location":"provider/httpserver/performance/#memory-usage-monitoring","title":"Memory Usage Monitoring","text":"<pre><code>func memoryMonitoringMiddleware() gin.HandlerFunc {\n    return func(c *gin.Context) {\n        // Monitor memory usage periodically, not on every request\n        if rand.Intn(1000) == 0 { // 0.1% sampling\n            var m runtime.MemStats\n            runtime.ReadMemStats(&amp;m)\n\n            if m.Alloc &gt; 500&lt;&lt;20 { // 500MB threshold\n                log.Warn(\"High memory usage\", \"alloc\", m.Alloc)\n            }\n        }\n\n        c.Next()\n    }\n}\n</code></pre>"},{"location":"provider/httpserver/performance/#garbage-collection-optimization","title":"Garbage Collection Optimization","text":"<pre><code>func optimizeGC() {\n    // Tune GC for server workloads\n    debug.SetGCPercent(100) // Default is usually good\n\n    // For memory-constrained environments\n    debug.SetGCPercent(50)\n\n    // For high-throughput scenarios\n    debug.SetGCPercent(200)\n\n    // Set memory limit (Go 1.19+)\n    debug.SetMemoryLimit(1 &lt;&lt; 30) // 1GB limit\n}\n</code></pre>"},{"location":"provider/httpserver/performance/#session-performance","title":"Session Performance","text":""},{"location":"provider/httpserver/performance/#efficient-session-storage","title":"Efficient Session Storage","text":"<pre><code>func optimizeSessionStorage(logger *log.Logger) kv.KV {\n    // For single instance - memory is fastest\n    if isSingleInstance() {\n        return kv.NewMemoryKV()\n    }\n\n    // For distributed - Redis with connection pooling\n    redisConfig := redis.NewConfig()\n    redisConfig.Address = \"redis:6379\"\n    redisConfig.MaxConnections = 100\n    redisConfig.MaxIdle = 20\n    redisConfig.IdleTimeout = 300 * time.Second\n\n    backend, err := redis.NewClient(redisConfig)\n    if err != nil {\n        logger.Error(err, \"failed to connect to Redis, falling back to memory\")\n        return kv.NewMemoryKV()\n    }\n\n    return backend\n}\n</code></pre>"},{"location":"provider/httpserver/performance/#session-configuration","title":"Session Configuration","text":"<pre><code>func optimizeSessionConfig() *session.Config {\n    config := session.NewConfig()\n\n    // Optimize timeouts\n    config.ExpirationSeconds = 3600      // 1 hour\n    config.IdleTimeoutSeconds = 1800     // 30 minutes\n    config.CleanupIntervalSeconds = 300  // 5 minutes\n\n    // Optimize for performance\n    config.HttpOnly = true               // Prevent XSS\n    config.Secure = true                 // HTTPS only in production\n    config.SameSite = http.SameSiteStrictMode\n\n    return config\n}\n</code></pre>"},{"location":"provider/httpserver/performance/#database-and-external-services","title":"Database and External Services","text":""},{"location":"provider/httpserver/performance/#connection-pooling","title":"Connection Pooling","text":"<pre><code>type OptimizedService struct {\n    db     *sql.DB\n    cache  *redis.Client\n    logger *log.Logger\n}\n\nfunc NewOptimizedService() *OptimizedService {\n    // Database connection pool\n    db, _ := sql.Open(\"postgres\", dsn)\n    db.SetMaxOpenConns(100)          // Max concurrent connections\n    db.SetMaxIdleConns(10)           // Idle connections to keep\n    db.SetConnMaxLifetime(time.Hour) // Connection lifetime\n\n    // Redis connection pool\n    redisClient := redis.NewClient(&amp;redis.Options{\n        Addr:         \"redis:6379\",\n        PoolSize:     100,\n        MinIdleConns: 10,\n        PoolTimeout:  4 * time.Second,\n    })\n\n    return &amp;OptimizedService{\n        db:    db,\n        cache: redisClient,\n    }\n}\n</code></pre>"},{"location":"provider/httpserver/performance/#caching-strategies","title":"Caching Strategies","text":"<pre><code>func cacheMiddleware(cache *redis.Client) gin.HandlerFunc {\n    return func(c *gin.Context) {\n        // Only cache GET requests\n        if c.Request.Method != \"GET\" {\n            c.Next()\n            return\n        }\n\n        cacheKey := generateCacheKey(c.Request.URL.Path, c.Request.URL.RawQuery)\n\n        // Try cache first\n        if cached, err := cache.Get(ctx, cacheKey).Result(); err == nil {\n            c.Header(\"X-Cache\", \"HIT\")\n            c.Data(200, \"application/json\", []byte(cached))\n            return\n        }\n\n        // Capture response\n        w := &amp;responseWriter{ResponseWriter: c.Writer}\n        c.Writer = w\n        c.Next()\n\n        // Cache successful responses\n        if w.status == 200 &amp;&amp; len(w.body) &gt; 0 {\n            cache.Set(ctx, cacheKey, w.body, 5*time.Minute)\n        }\n    }\n}\n\ntype responseWriter struct {\n    gin.ResponseWriter\n    body   []byte\n    status int\n}\n\nfunc (w *responseWriter) Write(data []byte) (int, error) {\n    w.body = append(w.body, data...)\n    return w.ResponseWriter.Write(data)\n}\n\nfunc (w *responseWriter) WriteHeader(status int) {\n    w.status = status\n    w.ResponseWriter.WriteHeader(status)\n}\n</code></pre>"},{"location":"provider/httpserver/performance/#load-balancing-and-scaling","title":"Load Balancing and Scaling","text":""},{"location":"provider/httpserver/performance/#horizontal-scaling","title":"Horizontal Scaling","text":"<pre><code>func createLoadBalancedServer(instanceID string) *httpserver.Server {\n    config := httpserver.NewServerConfig()\n\n    // Each instance gets a unique port for development\n    basePort := 8080\n    port := basePort + instanceID\n    config.Port = port\n\n    // Shared configuration\n    config.ReadTimeout = 30\n    config.WriteTimeout = 30\n\n    logger := log.New(fmt.Sprintf(\"instance-%d\", instanceID))\n    server, _ := httpserver.NewServer(config, logger)\n\n    return server\n}\n</code></pre>"},{"location":"provider/httpserver/performance/#health-checks-for-load-balancers","title":"Health Checks for Load Balancers","text":"<pre><code>func setupHealthChecks(server *httpserver.Server) {\n    router := server.Route()\n\n    // Simple health check\n    router.GET(\"/health\", func(c *gin.Context) {\n        c.JSON(200, gin.H{\"status\": \"healthy\"})\n    })\n\n    // Detailed health check\n    router.GET(\"/health/detailed\", func(c *gin.Context) {\n        checks := performHealthChecks()\n\n        allHealthy := true\n        for _, status := range checks {\n            if status != \"healthy\" {\n                allHealthy = false\n                break\n            }\n        }\n\n        statusCode := 200\n        if !allHealthy {\n            statusCode = 503\n        }\n\n        c.JSON(statusCode, gin.H{\n            \"status\": allHealthy,\n            \"checks\": checks,\n            \"instance\": os.Getenv(\"INSTANCE_ID\"),\n            \"timestamp\": time.Now(),\n        })\n    })\n\n    // Readiness check (for Kubernetes)\n    router.GET(\"/ready\", func(c *gin.Context) {\n        if isReady() {\n            c.JSON(200, gin.H{\"ready\": true})\n        } else {\n            c.JSON(503, gin.H{\"ready\": false})\n        }\n    })\n\n    // Liveness check (for Kubernetes)\n    router.GET(\"/live\", func(c *gin.Context) {\n        c.JSON(200, gin.H{\"alive\": true})\n    })\n}\n\nfunc performHealthChecks() map[string]string {\n    checks := make(map[string]string)\n\n    // Database check\n    if pingDatabase() {\n        checks[\"database\"] = \"healthy\"\n    } else {\n        checks[\"database\"] = \"unhealthy\"\n    }\n\n    // Redis check\n    if pingRedis() {\n        checks[\"redis\"] = \"healthy\"\n    } else {\n        checks[\"redis\"] = \"unhealthy\"\n    }\n\n    // Memory check\n    if checkMemoryUsage() {\n        checks[\"memory\"] = \"healthy\"\n    } else {\n        checks[\"memory\"] = \"warning\"\n    }\n\n    return checks\n}\n</code></pre>"},{"location":"provider/httpserver/performance/#graceful-shutdown","title":"Graceful Shutdown","text":"<pre><code>func gracefulShutdownServer(server *httpserver.Server, logger *log.Logger) {\n    // Channel to receive OS signals\n    quit := make(chan os.Signal, 1)\n    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)\n\n    // Start server in goroutine\n    go func() {\n        logger.Info(\"server starting\", \"port\", server.Config.Port)\n        if err := server.Start(); err != nil {\n            logger.Error(err, \"server failed to start\")\n        }\n    }()\n\n    // Block until signal received\n    &lt;-quit\n    logger.Info(\"shutting down server...\")\n\n    // Create context with timeout for graceful shutdown\n    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)\n    defer cancel()\n\n    // Attempt graceful shutdown\n    if err := server.Shutdown(ctx); err != nil {\n        logger.Error(err, \"forced shutdown\")\n        os.Exit(1)\n    }\n\n    logger.Info(\"server stopped gracefully\")\n}\n</code></pre>"},{"location":"provider/httpserver/performance/#monitoring-and-metrics","title":"Monitoring and Metrics","text":""},{"location":"provider/httpserver/performance/#performance-metrics","title":"Performance Metrics","text":"<pre><code>func performanceMetricsMiddleware() gin.HandlerFunc {\n    return func(c *gin.Context) {\n        start := time.Now()\n\n        c.Next()\n\n        duration := time.Since(start)\n\n        // Record metrics (use your preferred metrics library)\n        recordMetrics(c.Request.Method, c.FullPath(), c.Writer.Status(), duration)\n\n        // Log slow requests\n        if duration &gt; 1*time.Second {\n            log.Warn(\"slow request\",\n                \"path\", c.Request.URL.Path,\n                \"method\", c.Request.Method,\n                \"duration\", duration,\n                \"status\", c.Writer.Status())\n        }\n    }\n}\n\nfunc recordMetrics(method, path string, status int, duration time.Duration) {\n    // Implementation depends on your metrics system\n    // Examples: Prometheus, StatsD, CloudWatch, etc.\n}\n</code></pre>"},{"location":"provider/httpserver/performance/#prometheus-metrics","title":"Prometheus Metrics","text":"<pre><code>import (\n    \"github.com/prometheus/client_golang/prometheus\"\n    \"github.com/prometheus/client_golang/prometheus/promhttp\"\n)\n\nvar (\n    httpDuration = prometheus.NewHistogramVec(\n        prometheus.HistogramOpts{\n            Name: \"http_request_duration_seconds\",\n            Help: \"Duration of HTTP requests in seconds\",\n        },\n        []string{\"method\", \"path\", \"status\"},\n    )\n\n    httpRequests = prometheus.NewCounterVec(\n        prometheus.CounterOpts{\n            Name: \"http_requests_total\",\n            Help: \"Total number of HTTP requests\",\n        },\n        []string{\"method\", \"path\", \"status\"},\n    )\n)\n\nfunc init() {\n    prometheus.MustRegister(httpDuration)\n    prometheus.MustRegister(httpRequests)\n}\n\nfunc prometheusMiddleware() gin.HandlerFunc {\n    return func(c *gin.Context) {\n        start := time.Now()\n\n        c.Next()\n\n        duration := time.Since(start)\n        status := strconv.Itoa(c.Writer.Status())\n\n        httpDuration.WithLabelValues(c.Request.Method, c.FullPath(), status).Observe(duration.Seconds())\n        httpRequests.WithLabelValues(c.Request.Method, c.FullPath(), status).Inc()\n    }\n}\n\nfunc setupMetricsEndpoint(server *httpserver.Server) {\n    server.Route().GET(\"/metrics\", gin.WrapH(promhttp.Handler()))\n}\n</code></pre>"},{"location":"provider/httpserver/performance/#production-deployment","title":"Production Deployment","text":""},{"location":"provider/httpserver/performance/#container-optimization","title":"Container Optimization","text":"<pre><code># Dockerfile optimized for performance\nFROM golang:1.21-alpine AS builder\n\nWORKDIR /app\nCOPY go.mod go.sum ./\nRUN go mod download\n\nCOPY ../../httpserver .\nRUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main .\n\nFROM alpine:latest\nRUN apk --no-cache add ca-certificates\nWORKDIR /root/\n\nCOPY --from=builder /app/main .\n\n# Performance-optimized runtime\nENV GIN_MODE=release\nENV GOGC=100\nENV GOMAXPROCS=0\n\nEXPOSE 8080\nCMD [\"./main\"]\n</code></pre>"},{"location":"provider/httpserver/performance/#environment-configuration","title":"Environment Configuration","text":"<pre><code>func productionConfig() *httpserver.ServerConfig {\n    config := httpserver.NewServerConfig()\n\n    // Read from environment\n    config.Port = getEnvInt(\"PORT\", 8080)\n    config.Host = getEnv(\"HOST\", \"0.0.0.0\")\n    config.ReadTimeout = getEnvInt(\"READ_TIMEOUT\", 30)\n    config.WriteTimeout = getEnvInt(\"WRITE_TIMEOUT\", 30)\n\n    // Production settings\n    config.Debug = false\n\n    // TLS configuration\n    if certFile := os.Getenv(\"TLS_CERT_FILE\"); certFile != \"\" {\n        config.TLSCert = certFile\n        config.TLSKey = os.Getenv(\"TLS_KEY_FILE\")\n        config.TLSEnable = true\n    }\n\n    return config\n}\n\nfunc getEnv(key, defaultValue string) string {\n    if value := os.Getenv(key); value != \"\" {\n        return value\n    }\n    return defaultValue\n}\n\nfunc getEnvInt(key string, defaultValue int) int {\n    if value := os.Getenv(key); value != \"\" {\n        if i, err := strconv.Atoi(value); err == nil {\n            return i\n        }\n    }\n    return defaultValue\n}\n</code></pre>"},{"location":"provider/httpserver/performance/#kubernetes-deployment","title":"Kubernetes Deployment","text":"<pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: http-server\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: http-server\n  template:\n    metadata:\n      labels:\n        app: http-server\n    spec:\n      containers:\n      - name: http-server\n        image: your-app:latest\n        ports:\n        - containerPort: 8080\n        env:\n        - name: PORT\n          value: \"8080\"\n        - name: GIN_MODE\n          value: \"release\"\n        resources:\n          requests:\n            memory: \"128Mi\"\n            cpu: \"100m\"\n          limits:\n            memory: \"512Mi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /live\n            port: 8080\n          initialDelaySeconds: 30\n          periodSeconds: 10\n        readinessProbe:\n          httpGet:\n            path: /ready\n            port: 8080\n          initialDelaySeconds: 5\n          periodSeconds: 5\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: http-server-service\nspec:\n  selector:\n    app: http-server\n  ports:\n  - protocol: TCP\n    port: 80\n    targetPort: 8080\n  type: LoadBalancer\n</code></pre>"},{"location":"provider/httpserver/performance/#performance-testing","title":"Performance Testing","text":""},{"location":"provider/httpserver/performance/#load-testing","title":"Load Testing","text":"<pre><code>func loadTestEndpoint() {\n    // Example using built-in testing\n    func TestServerPerformance(t *testing.T) {\n        server := setupTestServer()\n\n        // Concurrent requests\n        concurrency := 100\n        requests := 1000\n\n        var wg sync.WaitGroup\n        results := make(chan time.Duration, requests)\n\n        for i := 0; i &lt; concurrency; i++ {\n            wg.Add(1)\n            go func() {\n                defer wg.Done()\n                for j := 0; j &lt; requests/concurrency; j++ {\n                    start := time.Now()\n\n                    req := httptest.NewRequest(\"GET\", \"/api/test\", nil)\n                    w := httptest.NewRecorder()\n                    server.Route().ServeHTTP(w, req)\n\n                    results &lt;- time.Since(start)\n                }\n            }()\n        }\n\n        wg.Wait()\n        close(results)\n\n        // Analyze results\n        var durations []time.Duration\n        for duration := range results {\n            durations = append(durations, duration)\n        }\n\n        sort.Slice(durations, func(i, j int) bool {\n            return durations[i] &lt; durations[j]\n        })\n\n        p50 := durations[len(durations)/2]\n        p95 := durations[int(float64(len(durations))*0.95)]\n        p99 := durations[int(float64(len(durations))*0.99)]\n\n        t.Logf(\"Performance Results: P50=%v, P95=%v, P99=%v\", p50, p95, p99)\n\n        // Assert performance requirements\n        assert.True(t, p95 &lt; 100*time.Millisecond, \"95th percentile should be under 100ms\")\n    }\n}\n</code></pre>"},{"location":"provider/httpserver/performance/#best-practices-summary","title":"Best Practices Summary","text":""},{"location":"provider/httpserver/performance/#configuration","title":"Configuration","text":"<ul> <li>Use release mode in production</li> <li>Set appropriate timeouts</li> <li>Configure connection pooling</li> <li>Enable keep-alive connections</li> </ul>"},{"location":"provider/httpserver/performance/#middleware","title":"Middleware","text":"<ul> <li>Order middleware by execution cost</li> <li>Minimize middleware overhead</li> <li>Use efficient rate limiting</li> <li>Implement proper caching</li> </ul>"},{"location":"provider/httpserver/performance/#memory-management","title":"Memory Management","text":"<ul> <li>Monitor memory usage</li> <li>Tune garbage collection</li> <li>Limit request sizes</li> <li>Use connection pooling</li> </ul>"},{"location":"provider/httpserver/performance/#monitoring","title":"Monitoring","text":"<ul> <li>Implement health checks</li> <li>Add performance metrics</li> <li>Monitor error rates</li> <li>Set up alerting</li> </ul>"},{"location":"provider/httpserver/performance/#scaling","title":"Scaling","text":"<ul> <li>Design for horizontal scaling</li> <li>Implement graceful shutdown</li> <li>Use load balancers</li> <li>Cache frequently accessed data</li> </ul>"},{"location":"provider/httpserver/performance/#security-vs-performance","title":"Security vs Performance","text":"<ul> <li>Balance security and performance</li> <li>Use efficient authentication</li> <li>Implement reasonable rate limits</li> <li>Cache security validations when possible</li> </ul> <p>This performance guide provides a comprehensive foundation for building high-performance HTTP servers with Blueprint while maintaining security and reliability.</p>"},{"location":"provider/httpserver/request/","title":"HTTP Request and Response Utilities","text":"<p>Blueprint provides utilities for working with HTTP requests and responses in the Gin framework, making it easier to handle different content types, validate request data, and generate standardized responses.</p>"},{"location":"provider/httpserver/request/#request-utilities","title":"Request Utilities","text":""},{"location":"provider/httpserver/request/#content-type-detection","title":"Content Type Detection","text":"<p>You can use the <code>IsJSONRequest</code> function to determine if a request expects or contains JSON data:</p> <pre><code>import (\n    \"github.com/gin-gonic/gin\"\n    \"github.com/oddbit-project/blueprint/provider/httpserver/request\"\n)\n\nfunc HandleRequest(ctx *gin.Context) {\n    if request.IsJSONRequest(ctx) {\n        // Handle JSON request\n        // ...\n        ctx.JSON(200, gin.H{\"message\": \"Success\"})\n    } else {\n        // Handle other content types\n        // ...\n        ctx.HTML(200, \"template.html\", gin.H{\"message\": \"Success\"})\n    }\n}\n</code></pre>"},{"location":"provider/httpserver/request/#content-type-constants","title":"Content Type Constants","text":"<p>The request package provides constants for common content types:</p> <pre><code>const (\n    HeaderAccept      = \"Accept\"\n    HeaderContentType = \"Content-Type\"\n\n    ContentTypeHtml   = \"text/html\"\n    ContentTypeJson   = \"application/json\"\n    ContentTypeBinary = \"application/octet-stream\"\n)\n</code></pre>"},{"location":"provider/httpserver/request/#csrf-protection","title":"CSRF Protection","text":"<p>The request package includes CSRF protection utilities:</p> <pre><code>import (\n    \"github.com/gin-gonic/gin\"\n    \"github.com/oddbit-project/blueprint/provider/httpserver/request\"\n)\n\nfunc SetupRouter() *gin.Engine {\n    router := gin.Default()\n\n    // Add CSRF protection middleware\n    router.Use(request.CSRFMiddleware())\n\n    // Generate CSRF token in handlers\n    router.GET(\"/form\", func(c *gin.Context) {\n        csrfToken := request.GenerateCSRFToken(c)\n        c.HTML(200, \"form.html\", gin.H{\n            \"csrfToken\": csrfToken,\n        })\n    })\n\n    return router\n}\n</code></pre>"},{"location":"provider/httpserver/request/#csrf-token-usage","title":"CSRF Token Usage","text":"<p>Include CSRF tokens in forms:</p> <pre><code>&lt;form method=\"POST\" action=\"/submit\"&gt;\n    &lt;input type=\"hidden\" name=\"_csrf\" value=\"{{.csrfToken}}\"&gt;\n    &lt;!-- other form fields --&gt;\n    &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n&lt;/form&gt;\n</code></pre> <p>Or in AJAX requests:</p> <pre><code>fetch('/api/data', {\n    method: 'POST',\n    headers: {\n        'Content-Type': 'application/json',\n        'X-CSRF-Token': csrfToken\n    },\n    body: JSON.stringify(data)\n});\n</code></pre>"},{"location":"provider/httpserver/request/#response-utilities","title":"Response Utilities","text":"<p>Blueprint provides standardized response helpers that automatically detect request type and format responses appropriately.</p>"},{"location":"provider/httpserver/request/#response-types","title":"Response Types","text":"<p>The response package defines standard structures for consistent API responses:</p> <pre><code>// Success response structure\ntype JSONResponse struct {\n    Success bool        `json:\"success\"`\n    Data    interface{} `json:\"data,omitempty\"`\n}\n\n// Error response structure\ntype JSONResponseError struct {\n    Success bool        `json:\"success\"`\n    Error   ErrorDetail `json:\"error\"`\n}\n\ntype ErrorDetail struct {\n    Message      string      `json:\"message,omitempty\"`\n    RequestError interface{} `json:\"requestError,omitempty\"`\n}\n</code></pre>"},{"location":"provider/httpserver/request/#error-response-functions","title":"Error Response Functions","text":"<p>All response functions automatically detect JSON requests using <code>request.IsJSONRequest()</code> and return appropriate responses:</p>"},{"location":"provider/httpserver/request/#http401-unauthorized","title":"Http401 - Unauthorized","text":"<pre><code>import \"github.com/oddbit-project/blueprint/provider/httpserver/response\"\n\nfunc protectedHandler(c *gin.Context) {\n    if !isAuthenticated(c) {\n        response.Http401(c)\n        return\n    }\n\n    // Handle authenticated request\n}\n</code></pre>"},{"location":"provider/httpserver/request/#http403-forbidden","title":"Http403 - Forbidden","text":"<pre><code>func adminHandler(c *gin.Context) {\n    if !isAdmin(c) {\n        response.Http403(c)\n        return\n    }\n\n    // Handle admin request\n}\n</code></pre>"},{"location":"provider/httpserver/request/#http404-not-found","title":"Http404 - Not Found","text":"<pre><code>func getUserHandler(c *gin.Context) {\n    userID := c.Param(\"id\")\n    user, err := findUser(userID)\n    if err != nil {\n        response.Http404(c)\n        return\n    }\n\n    c.JSON(200, user)\n}\n</code></pre>"},{"location":"provider/httpserver/request/#http400-bad-request","title":"Http400 - Bad Request","text":"<pre><code>func createUserHandler(c *gin.Context) {\n    var user User\n    if err := c.ShouldBindJSON(&amp;user); err != nil {\n        response.Http400(c, \"Invalid user data provided\")\n        return\n    }\n\n    // Process valid user data\n}\n</code></pre>"},{"location":"provider/httpserver/request/#http429-too-many-requests","title":"Http429 - Too Many Requests","text":"<pre><code>func rateLimitedHandler(c *gin.Context) {\n    if isRateLimited(c) {\n        response.Http429(c)\n        return\n    }\n\n    // Handle request\n}\n</code></pre>"},{"location":"provider/httpserver/request/#http500-internal-server-error","title":"Http500 - Internal Server Error","text":"<pre><code>func databaseHandler(c *gin.Context) {\n    data, err := queryDatabase()\n    if err != nil {\n        response.Http500(c, err)\n        return\n    }\n\n    c.JSON(200, data)\n}\n</code></pre>"},{"location":"provider/httpserver/request/#validationerror-request-validation-failed","title":"ValidationError - Request Validation Failed","text":"<pre><code>func validateAndCreateUser(c *gin.Context) {\n    var user User\n    if err := c.ShouldBindJSON(&amp;user); err != nil {\n        // Pass validation errors for detailed feedback\n        response.ValidationError(c, err)\n        return\n    }\n\n    // Additional validation\n    if validationErrors := validateUser(user); len(validationErrors) &gt; 0 {\n        response.ValidationError(c, validationErrors)\n        return\n    }\n\n    // Create user\n}\n</code></pre>"},{"location":"provider/httpserver/request/#response-behavior","title":"Response Behavior","text":""},{"location":"provider/httpserver/request/#json-requests","title":"JSON Requests","text":"<p>For requests with <code>Accept: application/json</code> or <code>Content-Type: application/json</code>, responses are structured JSON:</p> <pre><code>// Success response\n{\n    \"success\": true,\n    \"data\": {\n        \"id\": 123,\n        \"name\": \"John Doe\"\n    }\n}\n\n// Error response\n{\n    \"success\": false,\n    \"error\": {\n        \"message\": \"Resource not found\"\n    }\n}\n\n// Validation error response\n{\n    \"success\": false,\n    \"error\": {\n        \"message\": \"request validation failed\",\n        \"requestError\": {\n            \"field\": \"email\",\n            \"error\": \"invalid email format\"\n        }\n    }\n}\n</code></pre>"},{"location":"provider/httpserver/request/#non-json-requests","title":"Non-JSON Requests","text":"<p>For HTML or other content types, responses return appropriate HTTP status codes without JSON body.</p>"},{"location":"provider/httpserver/request/#logging-integration","title":"Logging Integration","text":"<p>All response helpers automatically log events with appropriate levels:</p> <ul> <li>Http401, Http403: Warning level with access attempt details</li> <li>Http404: Info level with resource path</li> <li>Http400, Http429: Warning level with request details</li> <li>Http500: Error level with full error details and stack trace</li> <li>ValidationError: Warning level with validation failure details</li> </ul>"},{"location":"provider/httpserver/request/#complete-usage-example","title":"Complete Usage Example","text":"<pre><code>package main\n\nimport (\n    \"github.com/gin-gonic/gin\"\n    \"github.com/oddbit-project/blueprint/provider/httpserver/request\"\n    \"github.com/oddbit-project/blueprint/provider/httpserver/response\"\n)\n\ntype User struct {\n    ID    int    `json:\"id\"`\n    Name  string `json:\"name\" binding:\"required\"`\n    Email string `json:\"email\" binding:\"required,email\"`\n}\n\nfunc main() {\n    router := gin.Default()\n\n    // Add CSRF protection\n    router.Use(request.CSRFMiddleware())\n\n    // Routes\n    router.GET(\"/users/:id\", getUserHandler)\n    router.POST(\"/users\", createUserHandler)\n    router.GET(\"/form\", formHandler)\n\n    router.Run(\":8080\")\n}\n\nfunc getUserHandler(c *gin.Context) {\n    userID := c.Param(\"id\")\n\n    user, err := findUserByID(userID)\n    if err != nil {\n        response.Http404(c)\n        return\n    }\n\n    if request.IsJSONRequest(c) {\n        c.JSON(200, response.JSONResponse{\n            Success: true,\n            Data:    user,\n        })\n    } else {\n        c.HTML(200, \"user.html\", gin.H{\"user\": user})\n    }\n}\n\nfunc createUserHandler(c *gin.Context) {\n    var user User\n\n    // Validate request data\n    if err := c.ShouldBindJSON(&amp;user); err != nil {\n        response.ValidationError(c, err)\n        return\n    }\n\n    // Business logic validation\n    if exists := checkUserExists(user.Email); exists {\n        response.Http400(c, \"User with this email already exists\")\n        return\n    }\n\n    // Create user\n    createdUser, err := createUser(user)\n    if err != nil {\n        response.Http500(c, err)\n        return\n    }\n\n    if request.IsJSONRequest(c) {\n        c.JSON(201, response.JSONResponse{\n            Success: true,\n            Data:    createdUser,\n        })\n    } else {\n        c.Redirect(302, \"/users/\"+string(createdUser.ID))\n    }\n}\n\nfunc formHandler(c *gin.Context) {\n    csrfToken := request.GenerateCSRFToken(c)\n    c.HTML(200, \"form.html\", gin.H{\n        \"csrfToken\": csrfToken,\n    })\n}\n\n// Helper functions (implement as needed)\nfunc findUserByID(id string) (*User, error) { /* ... */ }\nfunc checkUserExists(email string) bool { /* ... */ }\nfunc createUser(user User) (*User, error) { /* ... */ }\n</code></pre>"},{"location":"provider/httpserver/request/#best-practices","title":"Best Practices","text":""},{"location":"provider/httpserver/request/#request-handling","title":"Request Handling","text":"<ol> <li>Always validate user input using Gin's binding features</li> <li>Use content type detection to handle requests appropriately</li> <li>Implement CSRF protection for state-changing operations</li> <li>Handle both JSON and HTML requests in the same handlers when possible</li> </ol>"},{"location":"provider/httpserver/request/#response-handling","title":"Response Handling","text":"<ol> <li>Use standardized response helpers instead of manual status codes</li> <li>Provide meaningful error messages without exposing internal details</li> <li>Log errors appropriately using the built-in logging integration</li> <li>Return consistent response formats for API clients</li> <li>Handle validation errors gracefully with detailed feedback</li> </ol>"},{"location":"provider/httpserver/request/#security-considerations","title":"Security Considerations","text":"<ol> <li>Don't expose internal error details in production responses</li> <li>Use CSRF protection for all state-changing operations</li> <li>Validate all inputs before processing</li> <li>Log security events (unauthorized access, validation failures)</li> <li>Return appropriate HTTP status codes for different scenarios</li> </ol>"},{"location":"provider/httpserver/request/#error-handling-patterns","title":"Error Handling Patterns","text":"<pre><code>// Good: Use response helpers\nfunc goodHandler(c *gin.Context) {\n    if !isAuthenticated(c) {\n        response.Http401(c)  // Automatic logging and consistent format\n        return\n    }\n\n    data, err := processRequest()\n    if err != nil {\n        response.Http500(c, err)  // Error logged with stack trace\n        return\n    }\n\n    c.JSON(200, response.JSONResponse{Success: true, Data: data})\n}\n\n// Bad: Manual status codes\nfunc badHandler(c *gin.Context) {\n    if !isAuthenticated(c) {\n        c.JSON(401, gin.H{\"error\": \"unauthorized\"})  // No logging, inconsistent format\n        return\n    }\n\n    data, err := processRequest()\n    if err != nil {\n        c.JSON(500, gin.H{\"error\": err.Error()})  // Exposes internal errors\n        return\n    }\n\n    c.JSON(200, gin.H{\"data\": data})  // Inconsistent response format\n}\n</code></pre> <p>The request and response utilities work together to provide a complete foundation for HTTP handling in Blueprint applications, ensuring consistent behavior, proper logging, and security best practices.</p>"},{"location":"provider/httpserver/security/","title":"HTTP Security","text":"<p>Blueprint provides comprehensive security features for HTTP applications including authentication, authorization, security headers, CSRF protection, and rate limiting.</p>"},{"location":"provider/httpserver/security/#security-components","title":"Security Components","text":"<p>Blueprint's security system consists of several layers:</p> <ol> <li>Authentication: Identity verification (Authentication Documentation)</li> <li>Security Headers: Browser security protections  </li> <li>CSRF Protection: Cross-Site Request Forgery prevention</li> <li>Rate Limiting: Request throttling and DDoS protection</li> <li>Content Security Policy: XSS and injection prevention</li> </ol>"},{"location":"provider/httpserver/security/#security-headers-middleware","title":"Security Headers Middleware","text":"<p>Blueprint provides a comprehensive security headers middleware that implements industry best practices.</p>"},{"location":"provider/httpserver/security/#default-security-configuration","title":"Default Security Configuration","text":"<pre><code>import \"github.com/oddbit-project/blueprint/provider/httpserver/security\"\n\n// Apply default security headers\nsecurityConfig := security.DefaultSecurityConfig()\nrouter.Use(security.SecurityMiddleware(securityConfig))\n</code></pre> <p>Default Headers Applied: - Content Security Policy: Strict CSP with nonce support - X-XSS-Protection: Browser XSS filtering - X-Content-Type-Options: MIME type sniffing prevention - X-Frame-Options: Clickjacking prevention - Strict-Transport-Security: HTTPS enforcement - Referrer-Policy: Referrer information control - Feature-Policy/Permissions-Policy: Browser feature restrictions - Cache-Control: Sensitive data caching prevention</p>"},{"location":"provider/httpserver/security/#custom-security-configuration","title":"Custom Security Configuration","text":"<pre><code>securityConfig := &amp;security.SecurityConfig{\n    CSP:                \"default-src 'self'; script-src 'self' 'unsafe-inline'\",\n    XSSProtection:      \"1; mode=block\",\n    ContentTypeOptions: \"nosniff\",\n    ReferrerPolicy:     \"no-referrer\",\n    HSTS:               \"max-age=63072000; includeSubDomains; preload\",\n    FrameOptions:       \"SAMEORIGIN\",\n    FeaturePolicy:      \"camera 'none'; microphone 'none'\",\n    CacheControl:       \"no-store, must-revalidate\",\n    UseCSPNonce:        true,\n    EnableRateLimit:    true,\n    RateLimit:          100, // requests per minute\n}\n\nrouter.Use(security.SecurityMiddleware(securityConfig))\n</code></pre>"},{"location":"provider/httpserver/security/#content-security-policy-csp","title":"Content Security Policy (CSP)","text":""},{"location":"provider/httpserver/security/#csp-with-nonce-support","title":"CSP with Nonce Support","text":"<p>Blueprint automatically generates unique nonces for each request when enabled:</p> <pre><code>config := security.DefaultSecurityConfig()\nconfig.CSP = \"default-src 'self'; script-src 'self' 'nonce-{nonce}'; style-src 'self' 'nonce-{nonce}'\"\nconfig.UseCSPNonce = true\n\nrouter.Use(security.SecurityMiddleware(config))\n</code></pre> <p>In your templates: <pre><code>&lt;!-- Get nonce from context --&gt;\n{{ $nonce := .nonce }}\n\n&lt;!-- Use in script tags --&gt;\n&lt;script nonce=\"{{ $nonce }}\"&gt;\n    console.log('This script is CSP-compliant');\n&lt;/script&gt;\n\n&lt;!-- Use in style tags --&gt;\n&lt;style nonce=\"{{ $nonce }}\"&gt;\n    .secure-style { color: blue; }\n&lt;/style&gt;\n</code></pre></p> <p>In handlers: <pre><code>func pageHandler(c *gin.Context) {\n    // Get the CSP nonce\n    nonce, exists := c.Get(\"csp-nonce\")\n    if !exists {\n        nonce = \"\"\n    }\n\n    c.HTML(200, \"page.html\", gin.H{\n        \"nonce\": nonce,\n        \"data\":  pageData,\n    })\n}\n</code></pre></p>"},{"location":"provider/httpserver/security/#csp-reporting","title":"CSP Reporting","text":"<p>Set up CSP violation reporting:</p> <pre><code>config.CSP = \"default-src 'self'; script-src 'self' 'nonce-{nonce}'; report-uri /csp-report\"\n\n// Handle CSP reports\nrouter.POST(\"/csp-report\", func(c *gin.Context) {\n    var report map[string]interface{}\n    if err := c.ShouldBindJSON(&amp;report); err == nil {\n        // Log or process CSP violation\n        logger.Warn(\"CSP Violation\", \"report\", report)\n    }\n    c.Status(204)\n})\n</code></pre>"},{"location":"provider/httpserver/security/#csrf-protection","title":"CSRF Protection","text":"<p>Blueprint provides built-in CSRF (Cross-Site Request Forgery) protection.</p>"},{"location":"provider/httpserver/security/#basic-csrf-setup","title":"Basic CSRF Setup","text":"<pre><code>import \"github.com/oddbit-project/blueprint/provider/httpserver/security\"\n\n// Apply CSRF protection to all routes\nrouter.Use(security.CSRFProtection())\n\n// Generate CSRF tokens in handlers\nrouter.GET(\"/form\", func(c *gin.Context) {\n    csrfToken := security.GenerateCSRFToken(c)\n    c.HTML(200, \"form.html\", gin.H{\n        \"csrfToken\": csrfToken,\n    })\n})\n</code></pre>"},{"location":"provider/httpserver/security/#csrf-token-usage","title":"CSRF Token Usage","text":"<p>In HTML Forms: <pre><code>&lt;form method=\"POST\" action=\"/submit\"&gt;\n    &lt;!-- Include CSRF token as hidden field --&gt;\n    &lt;input type=\"hidden\" name=\"_csrf\" value=\"{{ .csrfToken }}\"&gt;\n\n    &lt;input type=\"text\" name=\"data\" required&gt;\n    &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n&lt;/form&gt;\n</code></pre></p> <p>In AJAX Requests: <pre><code>// Include CSRF token in header\nfetch('/api/data', {\n    method: 'POST',\n    headers: {\n        'Content-Type': 'application/json',\n        'X-CSRF-Token': csrfToken\n    },\n    body: JSON.stringify(data)\n});\n</code></pre></p> <p>Getting CSRF Token via API: <pre><code>router.GET(\"/csrf-token\", func(c *gin.Context) {\n    token := security.GenerateCSRFToken(c)\n    c.JSON(200, gin.H{\"csrf_token\": token})\n})\n</code></pre></p>"},{"location":"provider/httpserver/security/#csrf-with-sessions","title":"CSRF with Sessions","text":"<p>Combine CSRF with session management for enhanced security:</p> <pre><code>// Setup session middleware first\nsessionManager := session.NewManager(store, sessionConfig, logger)\nrouter.Use(sessionManager.Middleware())\n\n// Then add CSRF protection\nrouter.Use(security.CSRFProtection())\n\nfunc formHandler(c *gin.Context) {\n    // Generate CSRF token (stored in session)\n    csrfToken := security.GenerateCSRFToken(c)\n\n    // Get session for other data\n    sess := session.Get(c)\n\n    c.HTML(200, \"form.html\", gin.H{\n        \"csrfToken\": csrfToken,\n        \"user\":      sess.GetString(\"user_id\"),\n    })\n}\n</code></pre>"},{"location":"provider/httpserver/security/#rate-limiting","title":"Rate Limiting","text":"<p>Blueprint provides flexible rate limiting to protect against abuse and DDoS attacks.</p>"},{"location":"provider/httpserver/security/#basic-rate-limiting","title":"Basic Rate Limiting","text":"<pre><code>import (\n    \"golang.org/x/time/rate\"\n    \"github.com/oddbit-project/blueprint/provider/httpserver/security\"\n)\n\n// Apply rate limiting: 60 requests per minute, burst of 10\nrateLimit := rate.Every(time.Minute / 60) // 1 request per second\nburstSize := 10\n\nrouter.Use(security.RateLimitMiddleware(rateLimit, burstSize))\n</code></pre>"},{"location":"provider/httpserver/security/#different-rate-limits-for-different-routes","title":"Different Rate Limits for Different Routes","text":"<pre><code>func setupRateRoutes(router *gin.Engine) {\n    // Strict rate limiting for auth endpoints\n    authLimit := rate.Every(time.Minute / 5) // 5 requests per minute\n    auth := router.Group(\"/auth\")\n    auth.Use(security.RateLimitMiddleware(authLimit, 2))\n    {\n        auth.POST(\"/login\", loginHandler)\n        auth.POST(\"/register\", registerHandler)\n    }\n\n    // Moderate rate limiting for API\n    apiLimit := rate.Every(time.Second) // 1 request per second\n    api := router.Group(\"/api\")\n    api.Use(security.RateLimitMiddleware(apiLimit, 10))\n    {\n        api.GET(\"/data\", getDataHandler)\n        api.POST(\"/data\", createDataHandler)\n    }\n\n    // Lenient rate limiting for static content\n    staticLimit := rate.Every(time.Second / 10) // 10 requests per second\n    static := router.Group(\"/static\")\n    static.Use(security.RateLimitMiddleware(staticLimit, 50))\n    {\n        static.Static(\"/\", \"./static\")\n    }\n}\n</code></pre>"},{"location":"provider/httpserver/security/#rate-limiting-configuration","title":"Rate Limiting Configuration","text":"<pre><code>// Create custom rate limiter\nlimiter := security.NewClientRateLimiter(\n    rate.Every(time.Minute/100), // 100 requests per minute\n    20,                          // Burst size of 20\n)\n\n// The rate limiter automatically:\n// - Tracks per-IP limits\n// - Handles proxy headers (X-Forwarded-For)\n// - Cleans up old limiters\n// - Returns 429 Too Many Requests when exceeded\n</code></pre>"},{"location":"provider/httpserver/security/#comprehensive-security-setup","title":"Comprehensive Security Setup","text":"<p>Here's a complete example combining all security features:</p> <pre><code>package main\n\nimport (\n    \"github.com/gin-gonic/gin\"\n    \"github.com/oddbit-project/blueprint/provider/httpserver/auth\"\n    \"github.com/oddbit-project/blueprint/provider/httpserver/security\"\n    \"github.com/oddbit-project/blueprint/provider/httpserver/session\"\n    \"golang.org/x/time/rate\"\n    \"time\"\n)\n\nfunc setupSecureServer() *gin.Engine {\n    router := gin.Default()\n\n    // 1. Security Headers (apply first)\n    securityConfig := security.DefaultSecurityConfig()\n    securityConfig.CSP = \"default-src 'self'; script-src 'self' 'nonce-{nonce}'; style-src 'self' 'nonce-{nonce}'\"\n    router.Use(security.SecurityMiddleware(securityConfig))\n\n    // 2. Rate Limiting (apply early)\n    generalRateLimit := rate.Every(time.Second / 2) // 2 requests per second\n    router.Use(security.RateLimitMiddleware(generalRateLimit, 10))\n\n    // 3. Session Management\n    sessionConfig := session.NewConfig()\n    sessionManager := session.NewManager(sessionStore, sessionConfig, logger)\n    router.Use(sessionManager.Middleware())\n\n    // 4. CSRF Protection (after sessions)\n    router.Use(security.CSRFProtection())\n\n    // Public routes\n    setupPublicRoutes(router)\n\n    // Protected routes with authentication\n    setupProtectedRoutes(router)\n\n    return router\n}\n\nfunc setupPublicRoutes(router *gin.Engine) {\n    router.GET(\"/\", homeHandler)\n    router.GET(\"/login\", loginFormHandler)\n    router.POST(\"/login\", loginHandler)\n    router.GET(\"/csrf-token\", csrfTokenHandler)\n}\n\nfunc setupProtectedRoutes(router *gin.Engine) {\n    // JWT Authentication for API\n    jwtAuth := auth.NewAuthJWT(jwtProvider)\n    api := router.Group(\"/api\")\n    api.Use(auth.AuthMiddleware(jwtAuth))\n    {\n        // Stricter rate limit for API\n        apiRateLimit := rate.Every(time.Second) // 1 request per second\n        api.Use(security.RateLimitMiddleware(apiRateLimit, 5))\n\n        api.GET(\"/user/profile\", getProfileHandler)\n        api.PUT(\"/user/profile\", updateProfileHandler)\n    }\n\n    // Token Authentication for admin\n    tokenAuth := auth.NewAuthToken(\"X-Admin-Key\", adminKey)\n    admin := router.Group(\"/admin\")\n    admin.Use(auth.AuthMiddleware(tokenAuth))\n    {\n        // Very strict rate limit for admin\n        adminRateLimit := rate.Every(time.Minute / 10) // 10 requests per minute\n        admin.Use(security.RateLimitMiddleware(adminRateLimit, 2))\n\n        admin.GET(\"/users\", listUsersHandler)\n        admin.DELETE(\"/users/:id\", deleteUserHandler)\n    }\n}\n</code></pre>"},{"location":"provider/httpserver/security/#security-best-practices","title":"Security Best Practices","text":""},{"location":"provider/httpserver/security/#production-security-checklist","title":"Production Security Checklist","text":"<ol> <li> <p>HTTPS Configuration <pre><code>// Enforce HTTPS in production\nsecurityConfig.HSTS = \"max-age=63072000; includeSubDomains; preload\"\n\n// Redirect HTTP to HTTPS\nrouter.Use(func(c *gin.Context) {\n    if c.Request.Header.Get(\"X-Forwarded-Proto\") == \"http\" {\n        httpsURL := \"https://\" + c.Request.Host + c.Request.RequestURI\n        c.Redirect(301, httpsURL)\n        return\n    }\n    c.Next()\n})\n</code></pre></p> </li> <li> <p>Environment-based Configuration <pre><code>func getSecurityConfig() *security.SecurityConfig {\n    config := security.DefaultSecurityConfig()\n\n    if os.Getenv(\"ENV\") == \"production\" {\n        config.HSTS = \"max-age=63072000; includeSubDomains; preload\"\n        config.FrameOptions = \"DENY\"\n        config.RateLimit = 60 // Stricter in production\n    } else {\n        config.HSTS = \"\" // No HSTS in development\n        config.RateLimit = 1000 // More lenient in development\n    }\n\n    return config\n}\n</code></pre></p> </li> <li> <p>Logging and Monitoring <pre><code>// Log security events\nfunc securityLogger() gin.HandlerFunc {\n    return gin.LoggerWithFormatter(func(param gin.LogFormatterParams) string {\n        if param.StatusCode == 429 {\n            logger.Warn(\"Rate limit exceeded\", \n                \"ip\", param.ClientIP,\n                \"path\", param.Path,\n                \"user_agent\", param.Request.UserAgent())\n        }\n        if param.StatusCode == 403 {\n            logger.Warn(\"CSRF validation failed\",\n                \"ip\", param.ClientIP,\n                \"path\", param.Path)\n        }\n        return \"\"\n    })\n}\n</code></pre></p> </li> </ol>"},{"location":"provider/httpserver/security/#security-headers-explained","title":"Security Headers Explained","text":"<ol> <li>Content-Security-Policy (CSP)</li> <li>Prevents XSS attacks by controlling resource loading</li> <li>Use nonces for inline scripts/styles</li> <li> <p>Report violations for monitoring</p> </li> <li> <p>X-XSS-Protection</p> </li> <li>Enables browser XSS filtering</li> <li> <p><code>1; mode=block</code> blocks detected XSS attempts</p> </li> <li> <p>X-Content-Type-Options</p> </li> <li>Prevents MIME type sniffing</li> <li> <p><code>nosniff</code> forces declared content types</p> </li> <li> <p>X-Frame-Options</p> </li> <li>Prevents clickjacking attacks</li> <li> <p><code>DENY</code> blocks all framing, <code>SAMEORIGIN</code> allows same-origin framing</p> </li> <li> <p>Strict-Transport-Security (HSTS)</p> </li> <li>Enforces HTTPS connections</li> <li><code>includeSubDomains</code> applies to all subdomains</li> <li> <p><code>preload</code> allows inclusion in browser preload lists</p> </li> <li> <p>Referrer-Policy</p> </li> <li>Controls referrer information sent with requests</li> <li><code>strict-origin-when-cross-origin</code> balances privacy and functionality</li> </ol>"},{"location":"provider/httpserver/security/#rate-limiting-strategies","title":"Rate Limiting Strategies","text":"<ol> <li> <p>Endpoint-specific Limits <pre><code>// Authentication endpoints: 5 requests per minute\nauthRateLimit := rate.Every(time.Minute / 5)\n\n// Search endpoints: 100 requests per minute  \nsearchRateLimit := rate.Every(time.Minute / 100)\n\n// File upload: 10 requests per hour\nuploadRateLimit := rate.Every(time.Hour / 10)\n</code></pre></p> </li> <li> <p>User-based Rate Limiting <pre><code>func userBasedRateLimit() gin.HandlerFunc {\n    limiters := make(map[string]*rate.Limiter)\n    mu := sync.RWMutex{}\n\n    return func(c *gin.Context) {\n        userID := getUserID(c) // Get from JWT/session\n\n        mu.RLock()\n        limiter, exists := limiters[userID]\n        mu.RUnlock()\n\n        if !exists {\n            mu.Lock()\n            limiter = rate.NewLimiter(rate.Every(time.Minute/60), 10)\n            limiters[userID] = limiter\n            mu.Unlock()\n        }\n\n        if !limiter.Allow() {\n            c.AbortWithStatusJSON(429, gin.H{\"error\": \"Rate limit exceeded\"})\n            return\n        }\n\n        c.Next()\n    }\n}\n</code></pre></p> </li> </ol>"},{"location":"provider/httpserver/security/#csrf-best-practices","title":"CSRF Best Practices","text":"<ol> <li> <p>SameSite Cookies <pre><code>sessionConfig.SameSite = int(http.SameSiteStrictMode)\n</code></pre></p> </li> <li> <p>Double Submit Cookie Pattern <pre><code>func doubleSubmitCSRF() gin.HandlerFunc {\n    return func(c *gin.Context) {\n        if c.Request.Method != \"GET\" &amp;&amp; c.Request.Method != \"HEAD\" {\n            cookieToken, _ := c.Cookie(\"csrf-token\")\n            headerToken := c.GetHeader(\"X-CSRF-Token\")\n\n            if cookieToken == \"\" || cookieToken != headerToken {\n                c.AbortWithStatusJSON(403, gin.H{\"error\": \"CSRF token mismatch\"})\n                return\n            }\n        }\n        c.Next()\n    }\n}\n</code></pre></p> </li> </ol>"},{"location":"provider/httpserver/security/#integration-examples","title":"Integration Examples","text":""},{"location":"provider/httpserver/security/#security-with-authentication","title":"Security with Authentication","text":"<pre><code>// Complete secure setup\nfunc setupSecureAPI() *gin.Engine {\n    router := gin.Default()\n\n    // Security headers\n    router.Use(security.SecurityMiddleware(security.DefaultSecurityConfig()))\n\n    // Rate limiting\n    router.Use(security.RateLimitMiddleware(rate.Every(time.Second), 10))\n\n    // Authentication\n    jwtAuth := auth.NewAuthJWT(jwtProvider)\n\n    // Public endpoints\n    public := router.Group(\"/public\")\n    {\n        public.POST(\"/login\", loginHandler)\n        public.GET(\"/health\", healthHandler)\n    }\n\n    // Protected API with additional security\n    api := router.Group(\"/api\")\n    api.Use(auth.AuthMiddleware(jwtAuth))\n    api.Use(security.CSRFProtection())\n    {\n        api.GET(\"/user\", getUserHandler)\n        api.PUT(\"/user\", updateUserHandler)\n    }\n\n    return router\n}\n</code></pre>"},{"location":"provider/httpserver/security/#security-for-web-applications","title":"Security for Web Applications","text":"<pre><code>func setupSecureWebApp() *gin.Engine {\n    router := gin.Default()\n\n    // Security headers with CSP for web content\n    securityConfig := security.DefaultSecurityConfig()\n    securityConfig.CSP = \"default-src 'self'; script-src 'self' 'nonce-{nonce}'; style-src 'self' 'nonce-{nonce}' 'unsafe-inline'\"\n    router.Use(security.SecurityMiddleware(securityConfig))\n\n    // Session management\n    router.Use(sessionManager.Middleware())\n\n    // CSRF protection for forms\n    router.Use(security.CSRFProtection())\n\n    // Rate limiting\n    router.Use(security.RateLimitMiddleware(rate.Every(time.Second/2), 5))\n\n    // Routes\n    router.GET(\"/\", homeHandler)\n    router.GET(\"/form\", formHandler)\n    router.POST(\"/submit\", submitHandler)\n\n    return router\n}\n</code></pre> <p>The security middleware provides comprehensive protection against common web vulnerabilities while maintaining flexibility for different application types and requirements.</p>"},{"location":"provider/httpserver/session/","title":"Advanced Session Management","text":"<p>Blueprint provides a cookie-based session management system with encryption, multiple storage backends, and security features.</p> <p>Note: when using custom types with sessions, always register the types for serialization/deserialization with gob.Register()</p>"},{"location":"provider/httpserver/session/#architecture-overview","title":"Architecture Overview","text":"<p>The session system consists of four main components:</p> <ul> <li>SessionData (<code>session_data.go</code>): Core data structure with typed accessors and identity management</li> <li>SessionManager (<code>middleware.go</code>): Gin middleware for automatic session lifecycle management</li> <li>Store (<code>store.go</code>): Backend storage abstraction with encryption and automatic cleanup</li> <li>Config (<code>config.go</code>): Comprehensive configuration with security defaults and validation</li> </ul>"},{"location":"provider/httpserver/session/#features","title":"Features","text":""},{"location":"provider/httpserver/session/#core-session-features","title":"Core Session Features","text":"<ul> <li>Flexible Storage: Support for any KV backend (memory, Redis, or custom implementations)</li> <li>Session Encryption: Optional AES256GCM encryption for cookie data</li> <li>Type-safe Access: Typed getters for common data types (string, int, bool)</li> <li>Identity Management: Built-in user identity support with dedicated methods</li> <li>Flash Messages: One-time messages that persist across requests</li> <li>Session Regeneration: Built-in protection against session fixation attacks</li> <li>Automatic Cleanup: Configurable cleanup intervals for expired sessions</li> <li>Dual Expiration: Both absolute expiration and idle timeout support</li> </ul>"},{"location":"provider/httpserver/session/#security-features","title":"Security Features","text":"<ul> <li>Cookie Security: HttpOnly, Secure, and SameSite configuration</li> <li>Session Fixation Protection: Regenerate session IDs on authentication</li> <li>Encryption Support: Optional AES256GCM encryption for sensitive session data</li> <li>Secure Defaults: Production-ready security settings out of the box</li> </ul>"},{"location":"provider/httpserver/session/#session-setup","title":"Session Setup","text":""},{"location":"provider/httpserver/session/#option-1-memory-based-sessions","title":"Option 1: Memory-based Sessions","text":"<pre><code>package main\n\nimport (\n    \"github.com/oddbit-project/blueprint/provider/httpserver\"\n    \"github.com/oddbit-project/blueprint/provider/httpserver/session\"\n    \"github.com/oddbit-project/blueprint/provider/kv\"\n    \"github.com/oddbit-project/blueprint/log\"\n)\n\nfunc main() {\n    logger := log.New(\"session-app\")\n\n    // Server setup\n    config := httpserver.NewConfig()\n    server := httpserver.NewServer(config, logger)\n\n    // Session configuration\n    sessionConfig := session.NewConfig()\n    sessionConfig.CookieName = \"my_session\"\n    sessionConfig.ExpirationSeconds = 3600 // 1 hour\n    sessionConfig.IdleTimeoutSeconds = 1800 // 30 minutes\n\n    // Memory backend for development\n    backend := kv.NewMemoryKV()\n\n    // Setup session middleware\n    sessionManager, err := server.UseSession(sessionConfig, backend, logger)\n    if err != nil {\n        logger.Fatal(err, \"failed to setup sessions\")\n    }\n\n    setupRoutes(server)\n    server.Start()\n}\n</code></pre>"},{"location":"provider/httpserver/session/#option-2-redis-based-sessions","title":"Option 2: Redis-based Sessions","text":"<pre><code>func setupRedisSession(server *httpserver.Server, logger *log.Logger) {\n    // Redis configuration\n    redisConfig := redis.NewConfig()\n    redisConfig.Address = \"redis:6379\"\n    redisConfig.Database = 1\n    redisConfig.PoolSize = 10\n\n    // Create Redis client\n    redisClient, err := redis.NewClient(redisConfig)\n    if err != nil {\n        logger.Fatal(err, \"failed to connect to Redis\")\n    }\n\n    // Session configuration with encryption\n    sessionConfig := session.NewConfig()\n    sessionConfig.ExpirationSeconds = 7200 // 2 hours\n    sessionConfig.EncryptionKey = secure.DefaultCredentialConfig{\n        PasswordEnvVar: \"SESSION_ENCRYPTION_KEY\",\n    }\n\n    // Setup session middleware with Redis\n    sessionManager, err := server.UseSession(sessionConfig, redisClient, logger)\n    if err != nil {\n        logger.Fatal(err, \"failed to setup Redis sessions\")\n    }\n}\n</code></pre>"},{"location":"provider/httpserver/session/#option-3-manual-session-setup-advanced","title":"Option 3: Manual Session Setup (Advanced)","text":"<pre><code>func setupAdvancedSession(server *httpserver.Server, logger *log.Logger) {\n    // Custom backend\n    backend := kv.NewMemoryKV()\n\n    // Session configuration\n    sessionConfig := session.NewConfig()\n    sessionConfig.Secure = true\n    sessionConfig.HttpOnly = true\n    sessionConfig.SameSite = int(http.SameSiteStrictMode)\n    sessionConfig.CleanupIntervalSeconds = 300\n\n    // Create store manually\n    sessionStore, err := session.NewStore(sessionConfig, backend, logger)\n    if err != nil {\n        logger.Fatal(err, \"failed to create session store\")\n    }\n\n    // Create manager manually with options\n    sessionManager, err := session.NewManager(sessionConfig,\n        session.ManagerWithStore(sessionStore),\n        session.ManagerWithLogger(logger))\n    if err != nil {\n        logger.Fatal(err, \"failed to create session manager\")\n    }\n\n    // Add middleware\n    server.Router().Use(sessionManager.Middleware())\n}\n</code></pre>"},{"location":"provider/httpserver/session/#session-configuration","title":"Session Configuration","text":""},{"location":"provider/httpserver/session/#complete-configuration-reference","title":"Complete Configuration Reference","text":"<pre><code>type Config struct {\n    // Cookie configuration\n    CookieName             string `json:\"cookieName\"`             // Cookie name (default: \"blueprint_session\")\n    Domain                 string `json:\"domain\"`                 // Cookie domain scope\n    Path                   string `json:\"path\"`                   // Cookie path scope (default: \"/\")\n\n    // Security configuration\n    Secure                 bool   `json:\"secure\"`                 // HTTPS only (default: true)\n    HttpOnly               bool   `json:\"httpOnly\"`               // No JS access (default: true)\n    SameSite               int    `json:\"sameSite\"`               // CSRF protection (default: Strict)\n\n    // Expiration configuration\n    ExpirationSeconds      int    `json:\"expirationSeconds\"`      // Session lifetime (default: 1800)\n    IdleTimeoutSeconds     int    `json:\"idleTimeoutSeconds\"`     // Idle timeout (default: 900)\n    CleanupIntervalSeconds int    `json:\"cleanupIntervalSeconds\"` // Cleanup frequency (default: 300)\n\n    // Encryption configuration (optional)\n    EncryptionKey          secure.DefaultCredentialConfig `json:\"encryptionKey\"`\n}\n</code></pre>"},{"location":"provider/httpserver/session/#security-defaults","title":"Security Defaults","text":"<pre><code>const (\n    DefaultSessionCookieName  = \"blueprint_session\"\n    DefaultSessionExpiration  = 1800  // 30 minutes\n    DefaultSessionIdleTimeout = 900   // 15 minutes\n    DefaultSecure             = true  // HTTPS only\n    DefaultHttpOnly           = true  // No JS access\n    DefaultSameSite           = http.SameSiteStrictMode\n    DefaultCleanupInterval    = 300   // 5 minutes\n)\n</code></pre>"},{"location":"provider/httpserver/session/#production-configuration-example","title":"Production Configuration Example","text":"<pre><code>{\n  \"session\": {\n    \"cookieName\": \"app_session\",\n    \"expirationSeconds\": 7200,\n    \"idleTimeoutSeconds\": 3600,\n    \"secure\": true,\n    \"httpOnly\": true,\n    \"sameSite\": 1,\n    \"domain\": \".example.com\",\n    \"path\": \"/\",\n    \"encryptionKey\": {\n      \"passwordEnvVar\": \"SESSION_ENCRYPTION_KEY\"\n    },\n    \"cleanupIntervalSeconds\": 300\n  }\n}\n</code></pre>"},{"location":"provider/httpserver/session/#working-with-sessions","title":"Working with Sessions","text":""},{"location":"provider/httpserver/session/#session-data-structure","title":"Session Data Structure","text":"<pre><code>type SessionData struct {\n    Values       map[string]any `json:\"values\"`\n    LastAccessed time.Time      `json:\"lastAccessed\"`\n    Created      time.Time      `json:\"created\"`\n    ID           string         `json:\"id\"`\n}\n</code></pre>"},{"location":"provider/httpserver/session/#basic-session-operations","title":"Basic Session Operations","text":"<pre><code>func sessionHandler(c *gin.Context) {\n    // Get session from context\n    sess := session.Get(c)\n\n    // Store values\n    sess.Set(\"user_id\", 123)\n    sess.Set(\"username\", \"john_doe\")\n    sess.Set(\"preferences\", map[string]any{\n        \"theme\": \"dark\",\n        \"language\": \"en\",\n    })\n\n    // Retrieve values with type safety\n    userID, ok := sess.GetInt(\"user_id\")\n    if ok {\n        logger.Info(\"User ID\", \"id\", userID)\n    }\n\n    username, ok := sess.GetString(\"username\")\n    if ok {\n        logger.Info(\"Username\", \"username\", username)\n    }\n\n    // Check existence\n    if sess.Has(\"preferences\") {\n        prefs, _ := sess.Get(\"preferences\")\n        logger.Info(\"User preferences\", \"prefs\", prefs)\n    }\n\n    // Delete values\n    sess.Delete(\"temporary_data\")\n\n    c.JSON(200, gin.H{\n        \"session_id\": sess.ID,\n        \"user_id\": userID,\n        \"username\": username,\n    })\n}\n</code></pre>"},{"location":"provider/httpserver/session/#identity-management","title":"Identity Management","text":"<pre><code>// Custom identity type\ntype UserIdentity struct {\n    ID       int    `json:\"id\"`\n    Username string `json:\"username\"`\n    Email    string `json:\"email\"`\n    Roles    []string `json:\"roles\"`\n}\n\n// Register with GOB for serialization\nfunc init() {\n    gob.Register(&amp;UserIdentity{})\n}\n\nfunc loginHandler(c *gin.Context) {\n    var loginReq struct {\n        Username string `json:\"username\"`\n        Password string `json:\"password\"`\n    }\n\n    if err := c.ShouldBindJSON(&amp;loginReq); err != nil {\n        c.JSON(400, gin.H{\"error\": \"Invalid request\"})\n        return\n    }\n\n    // Authenticate user (your authentication logic)\n    user, err := authenticateUser(loginReq.Username, loginReq.Password)\n    if err != nil {\n        c.JSON(401, gin.H{\"error\": \"Invalid credentials\"})\n        return\n    }\n\n    // Get session\n    sess := session.Get(c)\n\n    // Set user identity\n    identity := &amp;UserIdentity{\n        ID:       user.ID,\n        Username: user.Username,\n        Email:    user.Email,\n        Roles:    user.Roles,\n    }\n    sess.SetIdentity(identity)\n\n    // Regenerate session ID for security\n    sessionManager.Regenerate(c)\n\n    c.JSON(200, gin.H{\"message\": \"Login successful\"})\n}\n\nfunc getCurrentUser(c *gin.Context) *UserIdentity {\n    sess := session.Get(c)\n    identity, ok := sess.GetIdentity()\n    if !ok {\n        return nil\n    }\n\n    user, ok := identity.(*UserIdentity)\n    if !ok {\n        return nil\n    }\n\n    return user\n}\n\nfunc protectedHandler(c *gin.Context) {\n    user := getCurrentUser(c)\n    if user == nil {\n        c.JSON(401, gin.H{\"error\": \"Not authenticated\"})\n        return\n    }\n\n    c.JSON(200, gin.H{\n        \"user\": user,\n        \"message\": \"Access granted\",\n    })\n}\n\nfunc logoutHandler(c *gin.Context) {\n    sess := session.Get(c)\n    sess.DeleteIdentity()\n\n    // Clear entire session\n    sessionManager.Clear(c)\n\n    c.JSON(200, gin.H{\"message\": \"Logged out\"})\n}\n</code></pre>"},{"location":"provider/httpserver/session/#flash-messages","title":"Flash Messages","text":"<pre><code>func setFlashMessage(c *gin.Context) {\n    sess := session.Get(c)\n\n    // Set flash message\n    sess.FlashString(\"Operation completed successfully!\")\n\n    c.Redirect(302, \"/dashboard\")\n}\n\nfunc displayFlashMessage(c *gin.Context) {\n    sess := session.Get(c)\n\n    // Get simple flash message\n    message, ok := sess.GetFlashString()\n    if ok {\n        c.HTML(200, \"dashboard.html\", gin.H{\n            \"flash_message\": message,\n        })\n        return\n    }\n\n    // No flash messages\n    c.HTML(200, \"dashboard.html\", gin.H{})\n}\n</code></pre>"},{"location":"provider/httpserver/session/#security-operations","title":"Security Operations","text":""},{"location":"provider/httpserver/session/#session-regeneration-important","title":"Session Regeneration (IMPORTANT)","text":"<pre><code>func loginHandler(c *gin.Context) {\n    // ... authentication logic ...\n\n    sess := session.Get(c)\n    sess.SetIdentity(user)\n\n    // IMPORTANT: Regenerate session ID after authentication\n    // This prevents session fixation attacks\n    sessionManager.Regenerate(c)\n\n    c.JSON(200, gin.H{\"message\": \"Login successful\"})\n}\n\nfunc elevatePrivilegesHandler(c *gin.Context) {\n    // When user gains elevated privileges, regenerate session\n    sess := session.Get(c)\n\n    // Update user role\n    user := getCurrentUser(c)\n    user.Roles = append(user.Roles, \"admin\")\n    sess.SetIdentity(user)\n\n    // Regenerate session for security\n    sessionManager.Regenerate(c)\n\n    c.JSON(200, gin.H{\"message\": \"Privileges elevated\"})\n}\n</code></pre>"},{"location":"provider/httpserver/session/#session-clearing","title":"Session Clearing","text":"<pre><code>func logoutHandler(c *gin.Context) {\n    // Option 1: Clear entire session\n    sessionManager.Clear(c)\n\n    c.JSON(200, gin.H{\"message\": \"Logged out\"})\n}\n\nfunc partialLogoutHandler(c *gin.Context) {\n    sess := session.Get(c)\n\n    // Option 2: Clear only identity but keep other session data\n    sess.DeleteIdentity()\n\n    // Keep non-sensitive data like preferences\n    c.JSON(200, gin.H{\"message\": \"Logged out, preferences retained\"})\n}\n</code></pre>"},{"location":"provider/httpserver/session/#session-encryption","title":"Session Encryption","text":""},{"location":"provider/httpserver/session/#encryption-configuration","title":"Encryption Configuration","text":"<pre><code>// Environment variable approach\nsessionConfig.EncryptionKey = secure.DefaultCredentialConfig{\n    PasswordEnvVar: \"SESSION_ENCRYPTION_KEY\",\n}\n\n// File-based key\nsessionConfig.EncryptionKey = secure.DefaultCredentialConfig{\n    PasswordFile: \"/etc/secrets/session-key\",\n}\n\n// Direct key (not recommended for production)\nsessionConfig.EncryptionKey = secure.DefaultCredentialConfig{\n    Password: \"your-32-byte-encryption-key-here\",\n}\n</code></pre>"},{"location":"provider/httpserver/session/#key-generation","title":"Key Generation","text":"<pre><code># Generate a secure 32-byte key\nopenssl rand -base64 32\n\n# Set as environment variable\nexport SESSION_ENCRYPTION_KEY=\"generated-key-here\"\n</code></pre>"},{"location":"provider/httpserver/session/#backend-storage-options","title":"Backend Storage Options","text":""},{"location":"provider/httpserver/session/#memory-backend-development","title":"Memory Backend (Development)","text":"<pre><code>backend := kv.NewMemoryKV()\n// Pros: Fast, simple setup\n// Cons: Not persistent, single instance only\n</code></pre>"},{"location":"provider/httpserver/session/#redis-backend-production","title":"Redis Backend (Production)","text":"<pre><code>redisConfig := redis.NewConfig()\nredisConfig.Address = \"redis-cluster:6379\"\nredisConfig.Password = \"redis-password\"\nredisConfig.Database = 1\nredisConfig.PoolSize = 20\n\nbackend, err := redis.NewClient(redisConfig)\n// Pros: Distributed, persistent, scalable\n// Cons: Network latency, additional infrastructure\n</code></pre>"},{"location":"provider/httpserver/session/#custom-backend","title":"Custom Backend","text":"<pre><code>type CustomKV struct {\n    // Your implementation\n}\n\nfunc (c *CustomKV) SetTTL(key string, value []byte, ttl time.Duration) error {\n    // Store with TTL\n    return nil\n}\n\nfunc (c *CustomKV) Get(key string) ([]byte, error) {\n    // Retrieve value\n    return nil, nil\n}\n\nfunc (c *CustomKV) Delete(key string) error {\n    // Delete value\n    return nil\n}\n\nfunc (c *CustomKV) Prune() error {\n    // Clean up expired entries\n    return nil\n}\n</code></pre>"},{"location":"provider/httpserver/session/#example-secure-web-application","title":"Example: Secure Web Application","text":"<pre><code>package main\n\nimport (\n    \"encoding/gob\"\n    \"net/http\"\n    \"github.com/gin-gonic/gin\"\n    \"github.com/oddbit-project/blueprint/provider/httpserver\"\n    \"github.com/oddbit-project/blueprint/provider/httpserver/auth\"\n    \"github.com/oddbit-project/blueprint/provider/httpserver/session\"\n    \"github.com/oddbit-project/blueprint/provider/httpserver/security\"\n    \"github.com/oddbit-project/blueprint/provider/kv\"\n    \"github.com/oddbit-project/blueprint/log\"\n)\n\ntype UserIdentity struct {\n    ID       int      `json:\"id\"`\n    Username string   `json:\"username\"`\n    Email    string   `json:\"email\"`\n    Roles    []string `json:\"roles\"`\n}\n\nfunc init() {\n    // Register custom types for GOB serialization\n    gob.Register(&amp;UserIdentity{})\n}\n\nfunc main() {\n    logger := log.New(\"secure-web-app\")\n\n    // Server configuration\n    serverConfig := httpserver.NewConfig()\n    serverConfig.Host = \"localhost\"\n    serverConfig.Port = 8443\n    serverConfig.CertFile = \"server.crt\"\n    serverConfig.CertKeyFile = \"server.key\"\n\n    server := httpserver.NewServer(serverConfig, logger)\n\n    // Session configuration\n    sessionConfig := session.NewConfig()\n    sessionConfig.CookieName = \"secure_session\"\n    sessionConfig.ExpirationSeconds = 7200 // 2 hours\n    sessionConfig.IdleTimeoutSeconds = 1800 // 30 minutes\n    sessionConfig.Secure = true\n    sessionConfig.HttpOnly = true\n    sessionConfig.SameSite = int(http.SameSiteStrictMode)\n    sessionConfig.EncryptionKey = secure.DefaultCredentialConfig{\n        PasswordEnvVar: \"SESSION_ENCRYPTION_KEY\",\n    }\n\n    // Setup session store\n    backend := kv.NewMemoryKV() // Use Redis in production\n    sessionManager, err := server.UseSession(sessionConfig, backend, logger)\n    if err != nil {\n        logger.Fatal(err, \"failed to setup sessions\")\n    }\n\n    // Security headers\n    securityConfig := security.DefaultSecurityConfig()\n    securityConfig.CSP = \"default-src 'self'; script-src 'self' 'nonce-{nonce}'\"\n    server.Router().Use(security.SecurityMiddleware(securityConfig))\n\n    // CSRF protection\n    server.Router().Use(security.CSRFProtection())\n\n    // Rate limiting\n    server.Router().Use(security.RateLimitMiddleware(rate.Every(time.Second), 10))\n\n    // Routes\n    setupRoutes(server, sessionManager)\n\n    // Start server\n    if err := server.Start(); err != nil {\n        logger.Fatal(err, \"failed to start server\")\n    }\n}\n\nfunc setupRoutes(server *httpserver.Server, sessionManager *session.Manager) {\n    router := server.Router()\n\n    // Public routes\n    router.GET(\"/\", homeHandler)\n    router.GET(\"/login\", loginFormHandler)\n    router.POST(\"/login\", loginHandler(sessionManager))\n    router.GET(\"/register\", registerFormHandler)\n    router.POST(\"/register\", registerHandler)\n\n    // Protected routes\n    protected := router.Group(\"/dashboard\")\n    protected.Use(auth.AuthMiddleware(auth.NewAuthSession(&amp;UserIdentity{})))\n    {\n        protected.GET(\"/\", dashboardHandler)\n        protected.GET(\"/profile\", profileHandler)\n        protected.POST(\"/profile\", updateProfileHandler)\n        protected.POST(\"/logout\", logoutHandler(sessionManager))\n    }\n\n    // Admin routes\n    admin := router.Group(\"/admin\")\n    admin.Use(auth.AuthMiddleware(auth.NewAuthSession(&amp;UserIdentity{})))\n    admin.Use(requireRole(\"admin\"))\n    {\n        admin.GET(\"/users\", listUsersHandler)\n        admin.DELETE(\"/users/:id\", deleteUserHandler)\n    }\n}\n\nfunc loginHandler(sessionManager *session.Manager) gin.HandlerFunc {\n    return func(c *gin.Context) {\n        var req struct {\n            Username string `json:\"username\" binding:\"required\"`\n            Password string `json:\"password\" binding:\"required\"`\n        }\n\n        if err := c.ShouldBindJSON(&amp;req); err != nil {\n            c.JSON(400, gin.H{\"error\": \"Invalid request\"})\n            return\n        }\n\n        // Authenticate user\n        user, err := authenticateUser(req.Username, req.Password)\n        if err != nil {\n            c.JSON(401, gin.H{\"error\": \"Invalid credentials\"})\n            return\n        }\n\n        // Get session and set identity\n        sess := session.Get(c)\n        identity := &amp;UserIdentity{\n            ID:       user.ID,\n            Username: user.Username,\n            Email:    user.Email,\n            Roles:    user.Roles,\n        }\n        sess.SetIdentity(identity)\n\n        // Set flash message\n        sess.FlashString(\"Welcome back, \" + user.Username + \"!\")\n\n        // Regenerate session ID for security\n        sessionManager.Regenerate(c)\n\n        c.JSON(200, gin.H{\n            \"message\": \"Login successful\",\n            \"redirect\": \"/dashboard\",\n        })\n    }\n}\n\nfunc dashboardHandler(c *gin.Context) {\n    sess := session.Get(c)\n    user := getCurrentUser(c)\n\n    // Get flash message\n    flashMessage, _ := sess.GetFlashString()\n\n    c.HTML(200, \"dashboard.html\", gin.H{\n        \"user\": user,\n        \"flash\": flashMessage,\n        \"csrf_token\": security.GenerateCSRFToken(c),\n    })\n}\n\nfunc logoutHandler(sessionManager *session.Manager) gin.HandlerFunc {\n    return func(c *gin.Context) {\n        // Clear session\n        sessionManager.Clear(c)\n\n        c.JSON(200, gin.H{\n            \"message\": \"Logged out successfully\",\n            \"redirect\": \"/\",\n        })\n    }\n}\n\nfunc requireRole(role string) gin.HandlerFunc {\n    return func(c *gin.Context) {\n        user := getCurrentUser(c)\n        if user == nil {\n            c.AbortWithStatusJSON(401, gin.H{\"error\": \"Not authenticated\"})\n            return\n        }\n\n        hasRole := false\n        for _, userRole := range user.Roles {\n            if userRole == role {\n                hasRole = true\n                break\n            }\n        }\n\n        if !hasRole {\n            c.AbortWithStatusJSON(403, gin.H{\"error\": \"Insufficient privileges\"})\n            return\n        }\n\n        c.Next()\n    }\n}\n\nfunc getCurrentUser(c *gin.Context) *UserIdentity {\n    sess := session.Get(c)\n    identity, ok := sess.GetIdentity()\n    if !ok {\n        return nil\n    }\n\n    user, ok := identity.(*UserIdentity)\n    if !ok {\n        return nil\n    }\n\n    return user\n}\n</code></pre>"},{"location":"provider/httpserver/session/#best-practices","title":"Best Practices","text":""},{"location":"provider/httpserver/session/#security-best-practices","title":"Security Best Practices","text":"<ol> <li> <p>Always use HTTPS in production <pre><code>sessionConfig.Secure = true\n</code></pre></p> </li> <li> <p>Regenerate session ID after authentication <pre><code>sessionManager.Regenerate(c)\n</code></pre></p> </li> <li> <p>Use encryption for sensitive data <pre><code>sessionConfig.EncryptionKey = secure.DefaultCredentialConfig{\n    PasswordEnvVar: \"SESSION_ENCRYPTION_KEY\",\n}\n</code></pre></p> </li> <li> <p>Set appropriate timeouts <pre><code>sessionConfig.ExpirationSeconds = 7200  // 2 hours max\nsessionConfig.IdleTimeoutSeconds = 1800 // 30 minutes idle\n</code></pre></p> </li> <li> <p>Use SameSite cookies <pre><code>sessionConfig.SameSite = int(http.SameSiteStrictMode)\n</code></pre></p> </li> </ol>"},{"location":"provider/httpserver/session/#performance-best-practices","title":"Performance Best Practices","text":"<ol> <li>Choose appropriate backend</li> <li>Memory: Development and single-instance applications</li> <li> <p>Redis: Production and distributed applications</p> </li> <li> <p>Configure cleanup intervals <pre><code>sessionConfig.CleanupIntervalSeconds = 300 // 5 minutes\n</code></pre></p> </li> <li> <p>Minimize session data</p> </li> <li>Store only essential user information</li> <li> <p>Use references to database records instead of full objects</p> </li> <li> <p>Register custom types with GOB <pre><code>func init() {\n    gob.Register(&amp;UserIdentity{})\n    gob.Register(&amp;CustomType{})\n}\n</code></pre></p> </li> </ol>"},{"location":"provider/httpserver/session/#development-vs-production","title":"Development vs Production","text":"<pre><code>func getSessionConfig(env string) *session.Config {\n    config := session.NewConfig()\n\n    if env == \"production\" {\n        config.Secure = true\n        config.HttpOnly = true\n        config.SameSite = int(http.SameSiteStrictMode)\n        config.ExpirationSeconds = 7200\n        config.EncryptionKey = secure.DefaultCredentialConfig{\n            PasswordEnvVar: \"SESSION_ENCRYPTION_KEY\",\n        }\n    } else {\n        config.Secure = false // Allow HTTP in development\n        config.ExpirationSeconds = 86400 // Longer for development\n    }\n\n    return config\n}\n</code></pre>"},{"location":"provider/httpserver/session/#troubleshooting","title":"Troubleshooting","text":""},{"location":"provider/httpserver/session/#common-issues","title":"Common Issues","text":"<ol> <li>Sessions not persisting</li> <li>Check cookie security settings</li> <li>Verify backend connectivity</li> <li> <p>Ensure middleware order</p> </li> <li> <p>\"gob: type not registered\" errors</p> </li> <li>Register custom types with <code>gob.Register()</code></li> <li> <p>Register in <code>init()</code> function</p> </li> <li> <p>Session expiration issues</p> </li> <li>Check system time synchronization</li> <li>Review timeout configurations</li> <li> <p>Monitor cleanup logs</p> </li> <li> <p>Performance issues</p> </li> <li>Monitor backend latency</li> <li>Optimize session data size</li> <li>Adjust cleanup intervals</li> </ol>"},{"location":"provider/httpserver/session/#debug-logging","title":"Debug Logging","text":"<pre><code>logger := log.New(\"session\")\nlogger.SetLevel(log.LevelDebug)\nsessionManager := server.UseSession(config, backend, logger)\n</code></pre>"},{"location":"provider/httpserver/troubleshooting/","title":"HTTP Server Troubleshooting Guide","text":"<p>Comprehensive troubleshooting guide for Blueprint's HTTP server framework covering common issues, debugging techniques, and solution strategies.</p>"},{"location":"provider/httpserver/troubleshooting/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"provider/httpserver/troubleshooting/#server-startup-issues","title":"Server Startup Issues","text":""},{"location":"provider/httpserver/troubleshooting/#server-fails-to-start-with-address-already-in-use","title":"Server fails to start with \"address already in use\"","text":"<p>Problem: Port is already bound by another process.</p> <p>Solutions: <pre><code># Check what's using the port\nlsof -i :8080\nnetstat -tulpn | grep :8080\n\n# Kill the process using the port\nkill -9 &lt;PID&gt;\n\n# Or change your server port\nconfig.Port = 8081\n</code></pre></p> <p>Code solution: <pre><code>// Graceful port handling\nfunc findAvailablePort(startPort int) int {\n    for port := startPort; port &lt; startPort+100; port++ {\n        listener, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", port))\n        if err == nil {\n            listener.Close()\n            return port\n        }\n    }\n    return startPort // fallback\n}\n\nconfig.Port = findAvailablePort(8080)\n</code></pre></p>"},{"location":"provider/httpserver/troubleshooting/#server-starts-but-returns-connection-refused","title":"Server starts but returns \"connection refused\"","text":"<p>Problem: Server binding to localhost but accessed from external IP.</p> <p>Solution: <pre><code>// Wrong - only binds to localhost\nconfig.Host = \"localhost\"\n\n// Correct - binds to all interfaces\nconfig.Host = \"0.0.0.0\"\nconfig.Host = \"\" // empty string also binds to all interfaces\n</code></pre></p>"},{"location":"provider/httpserver/troubleshooting/#tls-certificate-errors","title":"TLS certificate errors","text":"<p>Problem: Invalid or missing TLS certificates.</p> <p>Debugging: <pre><code>func validateTLSConfig(config *httpserver.ServerConfig) error {\n    if !config.TLSEnable {\n        return nil\n    }\n\n    // Check certificate files exist\n    if _, err := os.Stat(config.TLSCert); os.IsNotExist(err) {\n        return fmt.Errorf(\"TLS certificate file not found: %s\", config.TLSCert)\n    }\n\n    if _, err := os.Stat(config.TLSKey); os.IsNotExist(err) {\n        return fmt.Errorf(\"TLS key file not found: %s\", config.TLSKey)\n    }\n\n    // Test certificate loading\n    _, err := tls.LoadX509KeyPair(config.TLSCert, config.TLSKey)\n    if err != nil {\n        return fmt.Errorf(\"invalid TLS certificate/key pair: %v\", err)\n    }\n\n    return nil\n}\n</code></pre></p>"},{"location":"provider/httpserver/troubleshooting/#authentication-issues","title":"Authentication Issues","text":""},{"location":"provider/httpserver/troubleshooting/#jwt-tokens-not-working","title":"JWT tokens not working","text":"<p>Problem: JWT tokens are rejected or claims are not accessible.</p> <p>Debugging steps:</p> <ol> <li> <p>Check JWT Provider Configuration: <pre><code>func debugJWTProvider(provider jwtprovider.JWTParser) {\n    // Test token generation\n    claims := &amp;jwtprovider.Claims{\n        Subject: \"test-user\",\n        ID:      \"test-token\",\n        Data:    map[string]interface{}{\"role\": \"user\"},\n    }\n\n    token, err := provider.GenerateToken(claims)\n    if err != nil {\n        log.Error(\"JWT generation failed\", \"error\", err)\n        return\n    }\n\n    // Test token parsing\n    parsedClaims, err := provider.ParseToken(token)\n    if err != nil {\n        log.Error(\"JWT parsing failed\", \"error\", err)\n        return\n    }\n\n    log.Info(\"JWT test successful\", \"claims\", parsedClaims)\n}\n</code></pre></p> </li> <li> <p>Check Authorization Header Format: <pre><code>func debugAuthHeader(c *gin.Context) {\n    authHeader := c.GetHeader(\"Authorization\")\n    log.Info(\"Authorization header\", \"value\", authHeader)\n\n    if len(authHeader) &lt; 7 || authHeader[:7] != \"Bearer \" {\n        log.Error(\"Invalid authorization header format\")\n        return\n    }\n\n    token := authHeader[7:]\n    log.Info(\"Extracted token\", \"token\", token)\n}\n</code></pre></p> </li> <li> <p>Verify Claims Context: <pre><code>func debugJWTClaims(c *gin.Context) {\n    claimsValue, exists := c.Get(auth.ContextJwtClaims)\n    if !exists {\n        log.Error(\"JWT claims not found in context\")\n        return\n    }\n\n    claims, ok := claimsValue.(*jwtprovider.Claims)\n    if !ok {\n        log.Error(\"Invalid claims type in context\")\n        return\n    }\n\n    log.Info(\"JWT claims found\", \"subject\", claims.Subject, \"id\", claims.ID)\n}\n</code></pre></p> </li> </ol>"},{"location":"provider/httpserver/troubleshooting/#token-authentication-failing","title":"Token authentication failing","text":"<p>Problem: API key authentication not working.</p> <p>Common causes and solutions:</p> <ol> <li> <p>Wrong header name: <pre><code>// Check what header the client is sending\nfunc debugTokenAuth(c *gin.Context) {\n    // Log all headers\n    for name, values := range c.Request.Header {\n        log.Info(\"Header\", \"name\", name, \"values\", values)\n    }\n\n    // Check specific headers\n    apiKey := c.GetHeader(\"X-API-Key\")\n    authHeader := c.GetHeader(\"Authorization\")\n\n    log.Info(\"Auth headers\", \"x-api-key\", apiKey, \"authorization\", authHeader)\n}\n\n// Ensure header names match\ntokenAuth := auth.NewAuthToken(\"X-API-Key\", \"your-secret\") // Case sensitive\n</code></pre></p> </li> <li> <p>Empty token secret (allows all requests): <pre><code>// This allows all requests!\ntokenAuth := auth.NewAuthToken(\"X-API-Key\", \"\")\n\n// Use a proper secret\ntokenAuth := auth.NewAuthToken(\"X-API-Key\", \"your-secret-key\")\n</code></pre></p> </li> </ol>"},{"location":"provider/httpserver/troubleshooting/#session-issues","title":"Session Issues","text":""},{"location":"provider/httpserver/troubleshooting/#sessions-not-persisting","title":"Sessions not persisting","text":"<p>Problem: Session data is lost between requests.</p> <p>Debugging steps:</p> <ol> <li> <p>Check cookie settings: <pre><code>func debugSessionConfig(config *session.Config) {\n    log.Info(\"Session config\", \n        \"secure\", config.Secure,\n        \"httpOnly\", config.HttpOnly,\n        \"sameSite\", config.SameSite,\n        \"domain\", config.Domain,\n        \"path\", config.Path)\n\n    // For development over HTTP\n    if config.Secure &amp;&amp; isHTTP() {\n        log.Warn(\"Secure cookies enabled but using HTTP - sessions won't work\")\n    }\n}\n</code></pre></p> </li> <li> <p>Check session storage: <pre><code>func debugSessionStorage(c *gin.Context) {\n    sess := session.Get(c)\n\n    log.Info(\"Session info\",\n        \"id\", sess.ID,\n        \"created\", sess.Created,\n        \"lastAccessed\", sess.LastAccessed,\n        \"values\", sess.Values)\n}\n</code></pre></p> </li> <li> <p>Verify middleware order: <pre><code>// Wrong order - CSRF before sessions\nserver.UseCSRFProtection()\nserver.UseSession(config, backend, logger)\n\n// Correct order - sessions before CSRF\nserver.UseSession(config, backend, logger)\nserver.UseCSRFProtection()\n</code></pre></p> </li> </ol>"},{"location":"provider/httpserver/troubleshooting/#session-expires-too-quickly","title":"Session expires too quickly","text":"<p>Problem: Sessions expire unexpectedly.</p> <p>Solution: <pre><code>func adjustSessionTimeouts(config *session.Config) {\n    // Increase timeouts\n    config.ExpirationSeconds = 7200    // 2 hours absolute\n    config.IdleTimeoutSeconds = 1800   // 30 minutes idle\n    config.CleanupIntervalSeconds = 600 // 10 minutes cleanup\n\n    log.Info(\"Session timeouts\", \n        \"expiration\", config.ExpirationSeconds,\n        \"idle\", config.IdleTimeoutSeconds)\n}\n</code></pre></p>"},{"location":"provider/httpserver/troubleshooting/#csrf-protection-issues","title":"CSRF Protection Issues","text":""},{"location":"provider/httpserver/troubleshooting/#csrf-validation-failing","title":"CSRF validation failing","text":"<p>Problem: Valid requests are rejected with CSRF errors.</p> <p>Debugging:</p> <ol> <li> <p>Check token generation and inclusion: <pre><code>func debugCSRFToken(c *gin.Context) {\n    // Generate token\n    token := security.GenerateCSRFToken(c)\n    log.Info(\"Generated CSRF token\", \"token\", token)\n\n    // Check stored token\n    storedToken := c.GetString(\"csrf-token\")\n    log.Info(\"Stored CSRF token\", \"token\", storedToken)\n\n    // Check submitted token\n    submittedToken := c.GetHeader(\"X-CSRF-Token\")\n    if submittedToken == \"\" {\n        submittedToken = c.PostForm(\"_csrf\")\n    }\n    log.Info(\"Submitted CSRF token\", \"token\", submittedToken)\n}\n</code></pre></p> </li> <li> <p>Verify middleware order: <pre><code>// Sessions must come before CSRF protection\nserver.UseSession(config, backend, logger)\nserver.UseCSRFProtection()\n</code></pre></p> </li> <li> <p>Check request method: <pre><code>// CSRF only applies to state-changing methods\n// GET, HEAD, OPTIONS are automatically allowed\nlog.Info(\"Request method\", \"method\", c.Request.Method)\n</code></pre></p> </li> </ol>"},{"location":"provider/httpserver/troubleshooting/#rate-limiting-issues","title":"Rate Limiting Issues","text":""},{"location":"provider/httpserver/troubleshooting/#rate-limits-too-restrictive","title":"Rate limits too restrictive","text":"<p>Problem: Legitimate requests are being blocked.</p> <p>Solutions:</p> <ol> <li> <p>Adjust rate limits: <pre><code>// Too restrictive\nserver.UseRateLimiting(10) // 10 per minute\n\n// More reasonable\nserver.UseRateLimiting(100) // 100 per minute\n\n// Or use custom rate limiting\nr := rate.Every(time.Second / 10) // 10 requests per second\nburst := 20\nserver.AddMiddleware(security.RateLimitMiddleware(r, burst))\n</code></pre></p> </li> <li> <p>Different limits for different endpoints: <pre><code>func setupDifferentialRateLimiting(server *httpserver.Server) {\n    // Strict limits for auth endpoints\n    auth := server.Group(\"/auth\")\n    auth.Use(security.RateLimitMiddleware(rate.Every(time.Minute/5), 2))\n\n    // Moderate limits for API\n    api := server.Group(\"/api\")\n    api.Use(security.RateLimitMiddleware(rate.Every(time.Second), 10))\n\n    // Lenient limits for static content\n    static := server.Group(\"/static\")\n    static.Use(security.RateLimitMiddleware(rate.Every(time.Second/10), 50))\n}\n</code></pre></p> </li> </ol>"},{"location":"provider/httpserver/troubleshooting/#rate-limiting-not-working","title":"Rate limiting not working","text":"<p>Problem: Rate limiting isn't being applied.</p> <p>Debugging: <pre><code>func debugRateLimit(c *gin.Context) {\n    // Check client IP detection\n    clientIP := c.ClientIP()\n    log.Info(\"Client IP\", \"ip\", clientIP)\n\n    // Check headers for proxy information\n    forwardedFor := c.GetHeader(\"X-Forwarded-For\")\n    realIP := c.GetHeader(\"X-Real-IP\")\n\n    log.Info(\"Proxy headers\", \n        \"x-forwarded-for\", forwardedFor,\n        \"x-real-ip\", realIP)\n}\n</code></pre></p>"},{"location":"provider/httpserver/troubleshooting/#middleware-issues","title":"Middleware Issues","text":""},{"location":"provider/httpserver/troubleshooting/#middleware-not-executing","title":"Middleware not executing","text":"<p>Problem: Middleware doesn't seem to be running.</p> <p>Debugging:</p> <ol> <li> <p>Add logging to middleware: <pre><code>func debugMiddleware() gin.HandlerFunc {\n    return func(c *gin.Context) {\n        log.Info(\"Middleware executing\", \n            \"path\", c.Request.URL.Path,\n            \"method\", c.Request.Method)\n\n        c.Next()\n\n        log.Info(\"Middleware completed\",\n            \"status\", c.Writer.Status())\n    }\n}\n</code></pre></p> </li> <li> <p>Check middleware order: <pre><code>// Middleware executes in order of registration\nserver.AddMiddleware(debugMiddleware()) // Will run first\nserver.UseAuth(authProvider)           // Will run second\n</code></pre></p> </li> <li> <p>Verify middleware isn't being bypassed: <pre><code>func checkMiddlewareChain(c *gin.Context) {\n    log.Info(\"Handler chain length\", \"count\", len(c.Handlers))\n    for i, handler := range c.Handlers {\n        log.Info(\"Handler\", \"index\", i, \"name\", runtime.FuncForPC(reflect.ValueOf(handler).Pointer()).Name())\n    }\n}\n</code></pre></p> </li> </ol>"},{"location":"provider/httpserver/troubleshooting/#middleware-causing-panics","title":"Middleware causing panics","text":"<p>Problem: Custom middleware is causing server crashes.</p> <p>Safe middleware pattern: <pre><code>func safeMiddleware() gin.HandlerFunc {\n    return func(c *gin.Context) {\n        defer func() {\n            if r := recover(); r != nil {\n                log.Error(\"Middleware panic recovered\", \n                    \"panic\", r,\n                    \"path\", c.Request.URL.Path)\n\n                if !c.Writer.Written() {\n                    response.Http500(c, fmt.Errorf(\"internal error\"))\n                }\n            }\n        }()\n\n        // Your middleware logic here\n        c.Next()\n    }\n}\n</code></pre></p>"},{"location":"provider/httpserver/troubleshooting/#debugging-techniques","title":"Debugging Techniques","text":""},{"location":"provider/httpserver/troubleshooting/#enable-debug-mode","title":"Enable Debug Mode","text":"<pre><code>config := httpserver.NewServerConfig()\nconfig.Debug = true // Enables Gin debug mode\n\n// Or set Gin mode directly\ngin.SetMode(gin.DebugMode)\n</code></pre>"},{"location":"provider/httpserver/troubleshooting/#request-logging","title":"Request Logging","text":"<pre><code>func detailedRequestLogging() gin.HandlerFunc {\n    return func(c *gin.Context) {\n        start := time.Now()\n\n        // Log request\n        log.Info(\"Incoming request\",\n            \"method\", c.Request.Method,\n            \"path\", c.Request.URL.Path,\n            \"query\", c.Request.URL.RawQuery,\n            \"user-agent\", c.Request.UserAgent(),\n            \"client-ip\", c.ClientIP())\n\n        // Log headers\n        for name, values := range c.Request.Header {\n            log.Info(\"Request header\", \"name\", name, \"values\", values)\n        }\n\n        c.Next()\n\n        // Log response\n        duration := time.Since(start)\n        log.Info(\"Request completed\",\n            \"status\", c.Writer.Status(),\n            \"duration\", duration,\n            \"size\", c.Writer.Size())\n    }\n}\n</code></pre>"},{"location":"provider/httpserver/troubleshooting/#error-debugging","title":"Error Debugging","text":"<pre><code>func errorDebugMiddleware() gin.HandlerFunc {\n    return func(c *gin.Context) {\n        c.Next()\n\n        // Check for errors\n        if len(c.Errors) &gt; 0 {\n            for _, err := range c.Errors {\n                log.Error(\"Request error\",\n                    \"error\", err.Error(),\n                    \"type\", err.Type,\n                    \"meta\", err.Meta)\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"provider/httpserver/troubleshooting/#configuration-debugging","title":"Configuration Debugging","text":"<pre><code>func debugServerConfig(config *httpserver.ServerConfig) {\n    log.Info(\"Server configuration\",\n        \"host\", config.Host,\n        \"port\", config.Port,\n        \"debug\", config.Debug,\n        \"readTimeout\", config.ReadTimeout,\n        \"writeTimeout\", config.WriteTimeout,\n        \"tlsEnabled\", config.TLSEnable)\n\n    for key, value := range config.Options {\n        log.Info(\"Server option\", \"key\", key, \"value\", value)\n    }\n}\n</code></pre>"},{"location":"provider/httpserver/troubleshooting/#performance-debugging","title":"Performance Debugging","text":""},{"location":"provider/httpserver/troubleshooting/#slow-request-detection","title":"Slow Request Detection","text":"<pre><code>func slowRequestDetection(threshold time.Duration) gin.HandlerFunc {\n    return func(c *gin.Context) {\n        start := time.Now()\n        c.Next()\n\n        duration := time.Since(start)\n        if duration &gt; threshold {\n            log.Warn(\"Slow request detected\",\n                \"path\", c.Request.URL.Path,\n                \"method\", c.Request.Method,\n                \"duration\", duration,\n                \"threshold\", threshold)\n        }\n    }\n}\n\n// Usage\nserver.AddMiddleware(slowRequestDetection(500 * time.Millisecond))\n</code></pre>"},{"location":"provider/httpserver/troubleshooting/#memory-usage-monitoring","title":"Memory Usage Monitoring","text":"<pre><code>func memoryMonitoring() gin.HandlerFunc {\n    return func(c *gin.Context) {\n        var m runtime.MemStats\n        runtime.ReadMemStats(&amp;m)\n\n        log.Info(\"Memory stats\",\n            \"alloc\", bToMb(m.Alloc),\n            \"totalAlloc\", bToMb(m.TotalAlloc),\n            \"sys\", bToMb(m.Sys),\n            \"numGoroutines\", runtime.NumGoroutine())\n\n        c.Next()\n    }\n}\n\nfunc bToMb(b uint64) uint64 {\n    return b / 1024 / 1024\n}\n</code></pre>"},{"location":"provider/httpserver/troubleshooting/#testing-and-validation","title":"Testing and Validation","text":""},{"location":"provider/httpserver/troubleshooting/#configuration-validation","title":"Configuration Validation","text":"<pre><code>func validateConfiguration(config *httpserver.ServerConfig) error {\n    var errors []string\n\n    if config.Port &lt;= 0 || config.Port &gt; 65535 {\n        errors = append(errors, \"invalid port number\")\n    }\n\n    if config.ReadTimeout &lt;= 0 {\n        errors = append(errors, \"read timeout must be positive\")\n    }\n\n    if config.WriteTimeout &lt;= 0 {\n        errors = append(errors, \"write timeout must be positive\")\n    }\n\n    if config.TLSEnable {\n        if config.TLSCert == \"\" {\n            errors = append(errors, \"TLS certificate required when TLS enabled\")\n        }\n        if config.TLSKey == \"\" {\n            errors = append(errors, \"TLS key required when TLS enabled\")\n        }\n    }\n\n    if len(errors) &gt; 0 {\n        return fmt.Errorf(\"configuration errors: %s\", strings.Join(errors, \", \"))\n    }\n\n    return nil\n}\n</code></pre>"},{"location":"provider/httpserver/troubleshooting/#health-check-endpoint","title":"Health Check Endpoint","text":"<pre><code>func healthCheckEndpoint(server *httpserver.Server) {\n    server.Route().GET(\"/debug/health\", func(c *gin.Context) {\n        checks := map[string]string{\n            \"server\":    \"healthy\",\n            \"memory\":    checkMemoryUsage(),\n            \"goroutines\": checkGoroutineCount(),\n        }\n\n        allHealthy := true\n        for _, status := range checks {\n            if status != \"healthy\" {\n                allHealthy = false\n                break\n            }\n        }\n\n        statusCode := 200\n        if !allHealthy {\n            statusCode = 503\n        }\n\n        c.JSON(statusCode, gin.H{\n            \"status\": map[string]bool{\"healthy\": allHealthy},\n            \"checks\": checks,\n            \"timestamp\": time.Now(),\n        })\n    })\n}\n\nfunc checkMemoryUsage() string {\n    var m runtime.MemStats\n    runtime.ReadMemStats(&amp;m)\n\n    if m.Alloc &gt; 500*1024*1024 { // 500MB threshold\n        return \"warning\"\n    }\n    return \"healthy\"\n}\n\nfunc checkGoroutineCount() string {\n    count := runtime.NumGoroutine()\n    if count &gt; 1000 { // 1000 goroutines threshold\n        return \"warning\"\n    }\n    return \"healthy\"\n}\n</code></pre>"},{"location":"provider/httpserver/troubleshooting/#common-error-messages-and-solutions","title":"Common Error Messages and Solutions","text":""},{"location":"provider/httpserver/troubleshooting/#http-multiple-responsewriteheader-calls","title":"\"http: multiple response.WriteHeader calls\"","text":"<p>Cause: Multiple middleware or handlers trying to write response headers. Solution: Ensure only one response is sent per request, use <code>c.Writer.Written()</code> to check.</p>"},{"location":"provider/httpserver/troubleshooting/#context-canceled","title":"\"context canceled\"","text":"<p>Cause: Client disconnected or request timeout. Solution: Handle context cancellation in long-running operations.</p>"},{"location":"provider/httpserver/troubleshooting/#bind-address-already-in-use","title":"\"bind: address already in use\"","text":"<p>Cause: Port is already occupied. Solution: Check for existing processes, use different port, or implement port discovery.</p>"},{"location":"provider/httpserver/troubleshooting/#tls-private-key-does-not-match-public-key","title":"\"tls: private key does not match public key\"","text":"<p>Cause: TLS certificate and key files don't match. Solution: Regenerate certificate/key pair or verify correct file paths.</p>"},{"location":"provider/httpserver/troubleshooting/#session-not-found","title":"\"session not found\"","text":"<p>Cause: Session expired or storage backend unavailable. Solution: Check session configuration, verify backend connectivity.</p> <p>This troubleshooting guide covers the most common issues encountered when developing with Blueprint's HTTP server framework. Always check logs first, use debugging middleware, and validate configuration before deploying to production.</p>"},{"location":"threadpool/threadpool/","title":"ThreadPool","text":"<p>The ThreadPool package provides a robust, flexible worker pool implementation for Go applications.  It efficiently manages a pool of goroutines (workers) that execute jobs from a shared queue, providing graceful  resource management and concurrent execution control.</p>"},{"location":"threadpool/threadpool/#overview","title":"Overview","text":"<p>ThreadPool implements the classic worker pool pattern with several important features:</p> <ul> <li>Thread-safe job dispatch with multiple dispatch options</li> <li>Controlled concurrency with fixed worker count</li> <li>Automatic worker recovery from panics</li> <li>Queue-based job management</li> <li>Context cancellation support</li> <li>Performance metrics</li> </ul>"},{"location":"threadpool/threadpool/#usage","title":"Usage","text":""},{"location":"threadpool/threadpool/#basic-usage","title":"Basic Usage","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"github.com/oddbit-project/blueprint/log\"\n    \"github.com/oddbit-project/blueprint/threadpool\"\n    \"time\"\n)\n\n// Define a job that implements the threadpool.Job interface\ntype MyJob struct {\n    ID int\n}\n\n// Run is required by the threadpool.Job interface\nfunc (j *MyJob) Run(ctx context.Context) {\n    fmt.Printf(\"Job %d is running\\n\", j.ID)\n    // Simulate work\n    time.Sleep(100 * time.Millisecond)\n    fmt.Printf(\"Job %d completed\\n\", j.ID)\n}\n\nfunc main() {\n    // Create a logger\n    logger := log.NewLogger()\n\n    // Create a thread pool with 5 workers and a queue capacity of 10\n    // The pool will process at most 5 jobs concurrently\n    pool, err := threadpool.NewThreadPool(5, 10, threadpool.WithLogger(logger))\n    if err != nil {\n        panic(err)\n    }\n\n    // Start the pool with a context\n    ctx := context.Background()\n    if err := pool.Start(ctx); err != nil {\n        panic(err)\n    }\n\n    // Use defer to ensure the pool is gracefully stopped\n    defer pool.Stop()\n\n    // Submit 20 jobs to the pool\n    for i := 0; i &lt; 20; i++ {\n        job := &amp;MyJob{ID: i}\n\n        // Option 1: Blocking dispatch (blocks if queue is full)\n        pool.Dispatch(job)\n\n        // Option 2: Non-blocking dispatch (returns false if queue is full)\n        // if !pool.TryDispatch(job) {\n        //     fmt.Printf(\"Queue full, job %d rejected\\n\", i)\n        // }\n\n        // Option 3: Dispatch with timeout\n        // if !pool.DispatchWithTimeout(job, 100*time.Millisecond) {\n        //     fmt.Printf(\"Timeout while dispatching job %d\\n\", i)\n        // }\n\n        // Option 4: Dispatch with context cancellation support\n        // err := pool.DispatchWithContext(ctx, job)\n        // if err != nil {\n        //     fmt.Printf(\"Context cancelled while dispatching job %d: %v\\n\", i, err)\n        // }\n    }\n\n    // Display pool metrics\n    fmt.Printf(\"Total jobs processed: %d\\n\", pool.GetRequestCount())\n    fmt.Printf(\"Jobs in queue: %d\\n\", pool.GetQueueLen())\n    fmt.Printf(\"Worker count: %d\\n\", pool.GetWorkerCount())\n\n    // Wait for all jobs to complete (in a real application, you might want to use a WaitGroup or similar)\n    time.Sleep(1 * time.Second)\n}\n</code></pre>"},{"location":"threadpool/threadpool/#handling-job-panics","title":"Handling Job Panics","text":"<p>The ThreadPool automatically recovers from panics in job execution, ensuring that worker goroutines continue to operate even if a job panics:</p> <pre><code>// Even if this job panics, the worker will recover and continue processing\npool.Dispatch(&amp;PanicJob{})\n\n// Subsequent jobs will still be processed\npool.Dispatch(&amp;NormalJob{})\n</code></pre>"},{"location":"threadpool/threadpool/#context-cancellation","title":"Context Cancellation","text":"<p>You can stop all workers gracefully by canceling the context:</p> <pre><code>// Create a context that can be canceled\nctx, cancel := context.WithCancel(context.Background())\n\n// Start the pool with this context\npool.Start(ctx)\n\n// Later, when you want to stop processing:\ncancel()\n// All workers will finish their current job and then exit\n</code></pre>"},{"location":"threadpool/threadpool/#api-reference","title":"API Reference","text":""},{"location":"threadpool/threadpool/#types","title":"Types","text":""},{"location":"threadpool/threadpool/#threadpool_1","title":"ThreadPool","text":"<pre><code>type ThreadPool struct {\n    // Contains unexported fields\n}\n</code></pre> <p>The main type providing thread pool functionality.</p>"},{"location":"threadpool/threadpool/#job","title":"Job","text":"<pre><code>type Job interface {\n    Run(ctx context.Context)\n}\n</code></pre> <p>Interface that must be implemented by all jobs submitted to the thread pool.</p>"},{"location":"threadpool/threadpool/#functions","title":"Functions","text":""},{"location":"threadpool/threadpool/#newthreadpool","title":"NewThreadPool","text":"<pre><code>func NewThreadPool(\n    workerCount int, \n    queueSize int, \n    opts ...OptionsFn,\n) (*ThreadPool, error)\n</code></pre> <p>Creates a new thread pool with the specified parameters: - <code>workerCount</code> - Number of worker goroutines to create - <code>queueSize</code> - Capacity of the job queue - <code>opts</code> - Optional functional options</p> <p>Returns error if: - <code>workerCount</code> &lt; 1 (<code>ErrInvalidWorkerCount</code>) - <code>queueSize</code> &lt; 1 (<code>ErrInvalidQueueSize</code>)</p>"},{"location":"threadpool/threadpool/#available-options","title":"Available Options","text":"<pre><code>func WithLogger(logger *log.Logger) OptionsFn\n</code></pre> <p>Attaches a logger to the thread pool for operation logging and panic recovery.</p>"},{"location":"threadpool/threadpool/#methods","title":"Methods","text":""},{"location":"threadpool/threadpool/#start","title":"Start","text":"<pre><code>func (t *ThreadPool) Start(ctx context.Context) error\n</code></pre> <p>Starts the thread pool workers. The context allows for graceful cancellation.  Returns <code>ErrPoolAlreadyStarted</code> if the pool has already been started.</p>"},{"location":"threadpool/threadpool/#stop","title":"Stop","text":"<pre><code>func (t *ThreadPool) Stop() error\n</code></pre> <p>Gracefully stops all workers after they complete their current jobs. Returns <code>ErrPoolNotStarted</code> if the pool has not been started.</p>"},{"location":"threadpool/threadpool/#dispatch","title":"Dispatch","text":"<pre><code>func (t *ThreadPool) Dispatch(j Job)\n</code></pre> <p>Adds a job to the queue. Blocks if the queue is full.</p>"},{"location":"threadpool/threadpool/#trydispatch","title":"TryDispatch","text":"<pre><code>func (t *ThreadPool) TryDispatch(j Job) bool\n</code></pre> <p>Attempts to add a job to the queue without blocking. Returns true if successful, false if the queue is full.</p>"},{"location":"threadpool/threadpool/#dispatchwithtimeout","title":"DispatchWithTimeout","text":"<pre><code>func (t *ThreadPool) DispatchWithTimeout(j Job, timeout time.Duration) bool\n</code></pre> <p>Attempts to add a job to the queue with a timeout. Returns true if successful, false if the timeout was reached.</p>"},{"location":"threadpool/threadpool/#dispatchwithcontext","title":"DispatchWithContext","text":"<pre><code>func (t *ThreadPool) DispatchWithContext(ctx context.Context, j Job) error\n</code></pre> <p>Attempts to add a job to the queue, respecting context cancellation. Returns nil if successful, the context error if the context was canceled.</p>"},{"location":"threadpool/threadpool/#metrics-methods","title":"Metrics Methods","text":"<pre><code>func (t *ThreadPool) GetRequestCount() uint64\nfunc (t *ThreadPool) GetQueueLen() int\nfunc (t *ThreadPool) GetQueueCapacity() int\nfunc (t *ThreadPool) GetWorkerCount() int\n</code></pre> <p>Methods for retrieving performance metrics and status information.</p>"},{"location":"threadpool/threadpool/#best-practices","title":"Best Practices","text":"<ol> <li>Choose Appropriate Worker Count: The ideal number of workers depends on the nature of the tasks:</li> <li>CPU-bound tasks: roughly equal to the number of CPU cores</li> <li> <p>I/O-bound tasks: higher than CPU cores (experiment to find optimal)</p> </li> <li> <p>Queue Size Management: Set queue size based on expected job arrival rate and acceptable latency:</p> </li> <li>Smaller queues: Less memory usage, potentially more dropped jobs</li> <li> <p>Larger queues: Higher memory usage, lower job rejection rate</p> </li> <li> <p>Error Handling: Even though the pool recovers from panics, implement proper error handling in jobs:    <pre><code>func (j *MyJob) Run(ctx context.Context) {\n    defer func() {\n        if r := recover(); r != nil {\n            // Log the error but don't re-panic\n            log.Printf(\"Job recovered from panic: %v\", r)\n        }\n    }()\n\n    // Actual job logic\n}\n</code></pre></p> </li> <li> <p>Context Awareness: Make jobs respect the context for cancellation:    <pre><code>func (j *MyJob) Run(ctx context.Context) {\n    select {\n    case &lt;-ctx.Done():\n        // Clean up and exit\n        return\n    default:\n        // Continue processing\n    }\n\n    // For longer operations, check context periodically\n    for i := 0; i &lt; steps; i++ {\n        if ctx.Err() != nil {\n            return\n        }\n        // Do work step\n    }\n}\n</code></pre></p> </li> <li> <p>Clean Shutdown: Always call <code>Stop()</code> to ensure all resources are cleaned up properly.</p> </li> </ol>"},{"location":"threadpool/threadpool/#thread-safety","title":"Thread Safety","text":"<p>All ThreadPool operations are thread-safe and can be called from multiple goroutines concurrently.</p>"},{"location":"threadpool/threadpool/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Job Design: Keep jobs appropriately sized - not too small (overhead dominates) or too large (blocks workers)</li> <li>Dispatch Method: Use the appropriate dispatch method based on your needs:</li> <li><code>Dispatch</code>: When jobs must be processed and you can afford to wait</li> <li><code>TryDispatch</code>: When jobs can be dropped if system is under load</li> <li><code>DispatchWithTimeout</code>: When you need bounded wait times</li> <li><code>DispatchWithContext</code>: When you need cancellation support</li> <li>Worker Count: Monitor and adjust worker count based on CPU usage and throughput requirements</li> </ul>"}]}